<!DOCTYPE html>
<html>
  <head>
    <title>Shader Art</title>
    <script src="https://ordinals.com/content/7e37766541506810ba6399c4b2735121f508bd9209df43dd200bf2316b014594i0"></script>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000;
        }
        canvas {
            width: 100% !important;
            height: 100% !important;
            object-fit: contain !important;
            max-width: 100vw;
            max-height: 100vh;
        }
        main {
            display: flex;
            justify-content: center;
            width: 100%;
            align-items: center;
            height: 100%;
        }
    </style>
  </head>
  <body>
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec3 aPosition;
        attribute vec2 aTexCoord;
        varying vec2 vTexCoord;

        void main() {
            vTexCoord = aTexCoord;
            vec4 positionVec4 = vec4(aPosition, 1.0);
            positionVec4.xy = positionVec4.xy * 2.0 - 1.0;
            gl_Position = positionVec4;
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        precision lowp int;  // Integer precision can be low for most operations
        #endif

        #define M_PI 3.14159265358979323846

        varying vec2 vTexCoord;
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float u_cellSize;
        uniform float u_noiseScale;
        uniform float u_maxDepth;
        uniform float u_flowSpeed;
        uniform float u_nS;
        uniform float u_rSS;
        uniform float u_roA;
        uniform vec2 u_nOS;
        uniform float u_amplitude;
        uniform float u_scaleFactor;
        uniform vec2 u_translation;
        uniform float u_luminosity;
        uniform float u_vibrancy;
        uniform float u_initialFreq;
        uniform float u_bS;
        uniform float u_sortStrength;
        uniform float u_sortFrequency;
        uniform float u_sortAnimSpeed;
        uniform int u_currentPattern;
        uniform float u_baseModulation;
        uniform vec4 u_baseColor;
        uniform vec3 u_randomColor1;  // Add uniforms for random colors
        uniform vec3 u_randomColor2;
        uniform vec3 u_randomColor3;
        
        // Add new toggle uniforms
        uniform bool u_enableDomainWarp;    // Toggle domain warping
        uniform bool u_enableLayeredNoise;  // Toggle layered noise
        uniform bool u_enableFlowFields;    // Toggle flow field distortion
        uniform bool u_enableGlyphNoise;    // Toggle glyph pattern noise
        uniform bool u_enableGridDistort;   // Toggle grid distortion
        uniform bool u_enableGlyphNoiseDetail;    // Toggle detail noise within glyphs

        // Add the isLightBackground uniform to the shader
        uniform bool u_isLightBackground;   // Whether we're using a light background

        // Add this uniform after the other uniforms in the fragment shader
        uniform float u_caScaleVariation;  // Controls how much the CA scale varies

        lowp float random(vec2 st, float seed) {
            // Hash function only needs low precision output
            vec2 p = st + seed;
            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }

        mediump float noise(vec2 st, float seed) {
            // Integer and fractional parts
            vec2 i = floor(st);
            vec2 f = fract(st);
            
            // Optimized smoothstep with lowp precision
            lowp vec2 u = f * f * (3.0 - 2.0 * f);
            
            // Gather corners with low precision
            lowp float a = random(i, seed);
            lowp float b = random(i + vec2(1.0, 0.0), seed);
            lowp float c = random(i + vec2(0.0, 1.0), seed);
            lowp float d = random(i + vec2(1.0, 1.0), seed);
            
            // Mix can use low precision
            return mix(
                a + (b - a) * u.x,
                c + (d - c) * u.x,
                u.y);
        }

        lowp vec3 mod289(vec3 x) { 
            return x - floor(x / 289.0) * 289.0; 
        }

        lowp vec2 mod289(vec2 x) { 
            return x - floor(x / 289.0) * 289.0; 
        }

        lowp vec3 permute(vec3 x) { 
            return mod289((x * 34.0 + 1.0) * x); 
        }

        mediump float simplexNoise(mediump vec2 v, float time) {
            // Original simplex noise variables and setup
            mediump vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
            
            // Combine time addition into a single step
            v += time * 0.03;
            
            // Integer calculations can use low precision
            lowp vec2 i = floor(v + dot(v, C.yy));
            mediump vec2 x0 = v - i + dot(i, C.xx);
            
            // These boolean operations and offsets can use low precision
            lowp vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
            
            // Combined calculations to reduce register usage
            mediump vec4 x12 = x0.xyxy + C.xxzz;
            x12.xy -= i1;
            
            // Use existing mod289 function
            i = mod289(i);
            lowp vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
            
            // Dot products need medium precision
            mediump vec3 dots = vec3(
                dot(x0, x0),
                dot(vec2(x12.x, x12.y), vec2(x12.x, x12.y)),
                dot(vec2(x12.z, x12.w), vec2(x12.z, x12.w))
            );
            
            // These multiplications can use low precision
            lowp vec3 m = max(0.5 - dots, 0.0);
            m = m * m;
            m = m * m;
            
            // These can use low precision
            lowp vec3 x = 2.0 * fract(p * C.www) - 1.0;
            lowp vec3 h = abs(x) - 0.5;
            lowp vec3 ox = floor(x + 0.5);
            lowp vec3 a0 = x - ox;
            
            // Final calculation
            m *= 1.792842914 - 0.853734913 * (a0 * a0 + h * h);
            
            // Gradient calculation
            lowp vec3 g = vec3(
                a0.x * x0.x + h.x * x0.y,
                a0.y * x12.x + h.y * x12.y,
                a0.z * x12.z + h.z * x12.w
            );
            
            return 130.0 * dot(m, g);
        }

        lowp float fastSin(float x) {
            // Wrap to -PI to PI range
            x = mod(x + M_PI, 2.0 * M_PI) - M_PI;
            
            // Fast sine approximation
            // Error < 0.002
            float x2 = x * x;
            return x * (1.0 - x2 / (3.0 * 2.0) + x2 * x2 / (5.0 * 4.0 * 3.0 * 2.0));
        }

        lowp float fastCos(float x) {
            return fastSin(x + M_PI * 0.5);
        }

        vec2 domainWarp(vec2 p, float time) {
            float slowTime = time * 0.0001;
            
            float flow = simplexNoise(p * 0.05 * (u_resolution.y / u_cellSize) + slowTime, slowTime);
            float detail = simplexNoise(p * 0.1 * (u_resolution.y / u_cellSize) + slowTime * 1.5, slowTime * 2.0) * 0.3;
            
            // Use fast approximations
            float angle = slowTime * 0.1;
            float rotX = fastCos(angle) * flow;
            float rotY = fastSin(angle) * flow;
            
            return p + vec2(
                rotX * 1.5 + detail,
                rotY * 1.5 + detail
            );
        }

        float layeredNoise(vec2 p, float time) {
            // Simplified to single layer with detail
            float mainLayer = simplexNoise(p, time);
            float detail = simplexNoise(p * 2.0, time * 0.3) * 0.3;
            return mainLayer * 0.7 + detail * 0.3;
        }

        float fbmSimplexNoise(vec2 v, int octaves) {
            if (octaves <= 0) return 0.0;
            
            const float PERSISTENCE = 0.001;
            const float LACUNARITY = 0.0009;
            const int MAX_OCTAVES = 2;
            
            float total = 0.0;
            float amplitude = u_amplitude;
            float frequency = u_initialFreq;
            
            // Apply initial offsets
            v += u_nOS + vec2(u_nS);
            
            // Calculate base pattern with simplified domain warping
            vec2 warpedCoord = domainWarp(v, u_time * 0.1);
            float basePattern = layeredNoise(warpedCoord, u_time);
            total = amplitude * basePattern;
            
            // Simplified time influence - single noise sample
            float timeInfluence = simplexNoise(vec2(u_time * 0.05, 0.0), u_nS) * 0.5;
            
            // Only two octaves with simplified rotation
            float timeRotation = u_time * 0.05;
            // Precalculate sin/cos using fast approximations
            float sinRot = fastSin(timeRotation);
            float cosRot = fastCos(timeRotation);
            mat2 rot = mat2(cosRot, -sinRot, sinRot, cosRot);
            
            // First octave
            amplitude *= PERSISTENCE * 3.2;
            frequency *= LACUNARITY * (1.0 + timeInfluence * 0.2);
            total += amplitude * layeredNoise(rot * warpedCoord * frequency, u_time * 0.9);
            
            // Second octave (if needed)
            if (octaves > 1) {
                amplitude *= PERSISTENCE * 2.0;
                frequency *= LACUNARITY * (1.0 + timeInfluence * 0.2);
                total += amplitude * layeredNoise(rot * warpedCoord * frequency, u_time * 0.9);
            }
            
            // Apply final modulation
            return total * (timeInfluence * 0.9 + u_baseModulation);
        }

        lowp vec3 getColorFromPalette(float t) {
            t = clamp(t, 0.0, 4.0) * 7.0;
            int segment = int(t);
            float frac = t - float(segment);
            float phase = float(segment) / 7.0;
            
            vec3 color1, color2;
            
            // Use the random colors passed from JavaScript
                    color1 = mix(
                mix(u_randomColor1, u_randomColor2, sin(phase * 6.28318) * 0.5 + 0.5),
                u_randomColor3,
                        cos(phase * 9.42477) * 0.5 + 0.5
                    );
                    color2 = mix(
                mix(u_randomColor2, u_randomColor3, cos(phase * 12.56636) * 0.5 + 0.5),
                u_randomColor1,
                        sin(phase * 15.70796) * 0.5 + 0.5
                    );
            
            return mix(color1, color2, smoothstep(0.1, 0.9, frac));
        }

        lowp vec3 enhanceColor(vec3 color, float noiseValue) {
            const vec3 LUM_WEIGHTS = vec3(0.333, 0.333, 0.334);
            float luminance = dot(color, LUM_WEIGHTS);
            
            // Adjust enhancement based on background setting
            float noiseInfluence = 1.0 + noiseValue * (u_isLightBackground ? 0.02 : 0.04); // lower influence
            vec3 boosted = color * (1.0 + (1.0 - luminance) * noiseInfluence);
            
            // Adjust saturation based on background
            float saturationStrength = u_isLightBackground ? 1.1 : 1.2; // lower influence
            vec3 saturated = mix(
                vec3(luminance),
                boosted,
                vec3(saturationStrength)
            );
            
            float contrastPower = u_isLightBackground ? 0.95 : 0.92; // lower influence
            vec3 contrasted = pow(saturated, vec3(contrastPower));
            
            float highlightThreshold = u_isLightBackground ? 0.95 : 0.92; // lower influence
            vec3 highlights = smoothstep(highlightThreshold, 1.0, contrasted);
            contrasted = mix(contrasted, highlights * 0.9, 0.6); // higher influence

            // Final multiplier based on background
            float finalMultiplier = u_isLightBackground ? 0.95 : 1.05; // lower influence
            return contrasted * finalMultiplier;
        }

        lowp vec3 blendColors(lowp vec3 a, lowp vec3 b, lowp float factor) {
            // Screen blend can use low precision
            lowp vec3 screen = 1.0 - (1.0 - a) * (1.0 - b * factor * 0.8);
            
            // Addition blend can use low precision
            lowp vec3 add = a + b * factor * 0.3;
            
            // Rotation influence calculation
            lowp float rotationInfluence = (1.0 + sin(u_roA + u_time * 0.1)) * 0.5;
            
            return mix(screen, add, 2.5 + rotationInfluence);
        }

        lowp vec2 getFlowDirection(mediump vec2 position, float time) {
            lowp float slowTime = time * u_sortAnimSpeed * 0.05;
            
            // Create fractal Brownian motion with domain warping
            vec2 p = position * 0.01;
            
            // Initial domain warping
            vec2 warp1 = vec2(
                simplexNoise(p, slowTime),
                simplexNoise(p + vec2(5.2, 1.3), slowTime)
            ) * 2.0;
            
            // Secondary domain warping
            vec2 warp2 = vec2(
                simplexNoise(p + warp1, slowTime + 10.0),
                simplexNoise(p + warp1 + vec2(8.7, 2.3), slowTime + 20.0)
            ) * 1.5;
            
            // Final domain-warped position
            vec2 warped = p + warp1 + warp2;
            
            // Multi-octave flow field
            vec2 flow = vec2(0.0);
            float amplitude = 1.0;
            float frequency = 1.0;
            
            // Add multiple octaves with rotation
            for(int i = 0; i < 4; i++) {
                // Calculate noise gradient for this octave
                float noiseVal = simplexNoise(warped * frequency, slowTime * frequency * 0.2);
                float noiseX = simplexNoise(warped * frequency + vec2(0.01, 0.0), slowTime * frequency * 0.2);
                float noiseY = simplexNoise(warped * frequency + vec2(0.0, 0.01), slowTime * frequency * 0.2);
                
                // Approximate gradient
                vec2 noiseGrad = vec2(noiseX - noiseVal, noiseY - noiseVal) * 100.0;
                
                // Rotate gradient based on octave
                float octaveAngle = float(i) * 0.7 + slowTime * 0.1;
                vec2 rotatedGrad = vec2(
                    noiseGrad.x * cos(octaveAngle) - noiseGrad.y * sin(octaveAngle),
                    noiseGrad.x * sin(octaveAngle) + noiseGrad.y * cos(octaveAngle)
                );
                
                // Add to flow with amplitude scaling
                flow += rotatedGrad * amplitude;
                
                // Update for next octave
                frequency *= 2.0;
                amplitude *= 0.5;
            }
            
            return normalize(flow);
        }

        // Add this function before getGlyphPattern
        lowp vec4 getCASettings(float seed, float iter) {
            // Use seed and iteration to select pattern type
            float patternSeed = fract(seed * 12345.6789 + iter * 789.123);
            
            // Select one of four patterns based on the seed
            int patternType = int(mod(patternSeed * 4.0, 4.0));
            
            // Return vec4(dirBiasStrength, surviveThreshold, birthThreshold, edgeThreshold)
            if (patternType == 0) {
                // Organic, flowing patterns
                return vec4(
                    0.4,    // dirBias strength
                    1.3,    // surviveThreshold base
                    2.3,    // birthThreshold base
                    0.35    // edgeThreshold base
                );
            } else if (patternType == 1) {
                // Geometric, crystalline patterns
                return vec4(
                    0.15,   // dirBias strength
                    1.6,    // surviveThreshold base
                    2.7,    // birthThreshold base
                    0.5     // edgeThreshold base
                );
            } else if (patternType == 2) {
                // Chaotic, detailed patterns
                return vec4(
                    0.3,    // dirBias strength
                    1.7,    // surviveThreshold base
                    2.2,    // birthThreshold base
                    0.45    // edgeThreshold base
                );
            } else {
                // Symmetric patterns
                return vec4(
                    0.25,   // dirBias strength
                    1.5,    // surviveThreshold base
                    2.5,    // birthThreshold base
                    0.4     // edgeThreshold base
                );
            }
        }

        // Then modify getGlyphPattern to use these settings
        lowp float getGlyphPattern(vec2 cell, float depth, float seed, vec2 normalizedPos) {
            // Use cellular grid position for scaling with more stable transitions
            vec2 gridPos = floor(cell / 4.0) * 4.0;
            float gridValue = max(abs(gridPos.x), abs(gridPos.y)) * 0.25;
            float smoothGrid = smoothstep(0.0, 4.0, gridValue) * 0.5;
            
            // More stable noise calculation with reduced variation
            float stabilityNoise = noise(floor(cell / 8.0) * 8.0, seed) * 0.2; // Reduced from 0.3
            float scaleVariation = 1.0 + (smoothGrid * 0.3 + stabilityNoise) * u_caScaleVariation * 0.5;
            
            // Pre-calculate scaled cell position with reduced variation
            vec2 scaledCell = floor(cell * scaleVariation * 1.8) * 0.5; // Reduced from 2.0
            vec2 id = floor(scaledCell * 2.0);
            
            // Generate base pattern with more defined edges
            float basePattern = noise(floor(id * 0.5) * 2.0, seed + floor(depth));
            float state = step(0.6, basePattern); // Increased threshold for more defined edges
            
            // Geometric properties with reduced variation
            float angle = atan(scaledCell.y, scaledCell.x);
            float radius = length(scaledCell) * 1.8; // Reduced from 2.0
            
            // Get CA settings
            vec4 caSettings = getCASettings(seed, floor(depth));
            float dirBias = sin(angle * floor(depth + 1.0)) * caSettings.x;
            
            // CA simulation with fixed neighbors
            float neighbors = 0.0;
            
            // Calculate neighbors using individual offsets with reduced influence
            vec2 neighbor;
            float neighborState;
            
            // Right neighbor
            neighbor = floor(id + vec2(1.0, 0.0));
            neighborState = step(0.5, noise(neighbor * 0.5, seed));
            neighbors += neighborState * (1.0 + dirBias * 0.2);
            
            // Left neighbor
            neighbor = floor(id + vec2(-1.0, 0.0));
            neighborState = step(0.5, noise(neighbor * 0.5, seed));
            neighbors += neighborState * (1.0 + dirBias * 0.2);
            
            // Top neighbor
            neighbor = floor(id + vec2(0.0, 1.0));
            neighborState = step(0.5, noise(neighbor * 0.5, seed));
            neighbors += neighborState * (1.0 + dirBias * 0.2);
            
            // Bottom neighbor
            neighbor = floor(id + vec2(0.0, -1.0));
            neighborState = step(0.5, noise(neighbor * 0.5, seed));
            neighbors += neighborState * (1.0 + dirBias * 0.2);
            
            // Rule application
            float depthRule = floor(mod(depth * 1.618 + seed * 3.14159, 2.0));
            
            if (depthRule < 1.0) {
                float surviveThreshold = caSettings.y + sin(angle * 2.0) * 0.1;
                state = step(surviveThreshold - 0.1, neighbors) * 
                        step(neighbors, surviveThreshold + 1.1) * state + 
                        step(caSettings.z - 0.1, neighbors) * 
                        step(neighbors, caSettings.z + 0.1) * (1.0 - state);
                } else {
                float edgeThreshold = caSettings.w + cos(radius) * 0.1;
                state = step(edgeThreshold, abs(neighbors - 2.0 - dirBias));
            }
            
            // Geometric pattern
            float geoPattern = smoothstep(0.4, 0.6, 
                sin(radius * (3.0 + depth * 0.5) +    // Try 2.0 to 5.0
                    angle * (4.0 + depth * 0.3) +     // Try 3.0 to 6.0
                    depth + seed) * 0.5 + 0.5
            );
            
            // Blend CA result with geometric pattern based on depth
            float blendFactor = 0.3 + 0.2 * sin(depth * 1.5);  // Try different base values 0.2 to 0.6
            float finalPattern = mix(state, geoPattern, blendFactor);
            
            // Add detail noise if enabled
            if (u_enableGlyphNoiseDetail) {
                float detail = noise(scaledCell * (depth + 1.0) * 3.0, seed + depth);
                return mix(finalPattern, detail, 0.15);
            }
            
            return finalPattern;
        }

        void main() {
            // Constants can use low precision
            const lowp int MAX_LOOP_DEPTH = 6;
            
            // Coordinate calculations need medium precision
            mediump vec2 coord = (vTexCoord * u_resolution - u_resolution * 0.25) * u_scaleFactor + u_translation;
            coord = coord / u_bS;
            
            // Grid distortion calculation can use medium precision
            mediump float gridDistortTime = u_time * u_sortAnimSpeed * 0.1;
            mediump vec2 gridDistortCoord = coord * u_sortFrequency;
            
            // Most pattern calculations can use low precision
            lowp float distortNoise1 = fbmSimplexNoise(gridDistortCoord + vec2(gridDistortTime * 0.1), 2);
            lowp float distortNoise2 = fbmSimplexNoise(gridDistortCoord + vec2(gridDistortTime * -0.15), 2);
            
            // Pattern vectors can use low precision since normalized
            lowp vec2 expPattern, stepPattern, circularPattern, squarePattern, flowPattern, smoothFlowPattern;
            
            // Pattern 1: Exponential waves
            expPattern = vec2(
                exp(-abs(mod(distortNoise1 + gridDistortTime, 2.0) - 1.0)) - 0.5,
                exp(-abs(mod(distortNoise2 + gridDistortTime, 2.0) - 1.0)) - 0.5
            );
            
            // Pattern 2: Stepped/quantized movement
            stepPattern = vec2(
                floor(distortNoise1 * 4.0) / 4.0,
                floor(distortNoise2 * 4.0) / 4.0
            );
            
            // Pattern 3: Circular/spiral movement
            float angle = distortNoise1 * 6.28318;
            circularPattern = vec2(
                cos(angle) * distortNoise2,
                sin(angle) * distortNoise2
            );
            
            // Pattern 4: Square/diamond pattern
            squarePattern = vec2(
                sign(fract(distortNoise1 * 2.0) - 0.5) * abs(fract(distortNoise2 * 2.0) - 0.5),
                sign(fract(distortNoise2 * 2.0) - 0.5) * abs(fract(distortNoise1 * 2.0) - 0.5)
            );
            
            // Pattern 5: Smooth directional flow with rotation
            flowPattern = vec2(
                distortNoise1 * cos(gridDistortTime * 0.2) - distortNoise2 * sin(gridDistortTime * 0.15),
                distortNoise1 * sin(gridDistortTime * 0.2) + distortNoise2 * cos(gridDistortTime * 0.15)
            );
            
            // Add subtle vorticity
            float vortexStrength = 0.3;
            float vortexAngle = atan(coord.y, coord.x) + gridDistortTime * 0.1;
            vec2 vortexOffset = vec2(
                cos(vortexAngle) * length(flowPattern) * vortexStrength,
                sin(vortexAngle) * length(flowPattern) * vortexStrength
            );
            
            // Combine flow and vortex with smooth transition
            smoothFlowPattern = flowPattern + vortexOffset;
            
            // Add progressive movement (modified for more organic flow)
            float flowTime = gridDistortTime * 0.05;
            smoothFlowPattern += vec2(
                simplexNoise(vec2(flowTime * 0.7, 0.0), 0.0) * 0.15,
                simplexNoise(vec2(flowTime * 0.8, 1.0), 0.0) * 0.15
            );
            
            // Select pattern based on uniform
            vec2 finalPattern;
            if (u_currentPattern == 5) {
                finalPattern = smoothFlowPattern;
            } else if (u_currentPattern == 0) {
                // Mixed patterns with smooth transitions
                float patternMix = fract(gridDistortTime * 0.1);
                finalPattern = mix(
                    mix(expPattern, stepPattern, smoothstep(0.0, 0.33, patternMix)),
                    mix(circularPattern, squarePattern, smoothstep(0.66, 1.0, patternMix)),
                    smoothstep(0.33, 0.66, patternMix)
                );
            } else if (u_currentPattern == 1) {
                finalPattern = expPattern;
            } else if (u_currentPattern == 2) {
                finalPattern = stepPattern;
            } else if (u_currentPattern == 3) {
                finalPattern = circularPattern;
            } else {
                finalPattern = squarePattern;
            }
            
            // Apply grid distortion only if enabled
            mediump vec2 gridOffset = vec2(0.0);
            if (u_enableGridDistort) {
                gridOffset = finalPattern * u_sortStrength * u_cellSize;
                // Apply distortion to coordinates before grid calculation
                coord += gridOffset * (1.0 + sin(gridDistortTime) * 0.3);
            }
            
            vec2 gridCoord = floor(coord / u_cellSize);
            vec2 cellCenter = (gridCoord + 0.5) * u_cellSize;
            vec2 localPos = coord - cellCenter;

        // Cell boundary check can use lower precision
        lowp float cellBoundary = u_cellSize * 0.485;
        lowp float edgeFade = 0.005;
        bool isWithinCell = all(lessThanEqual(abs(localPos), vec2(cellBoundary)));
        if (!isWithinCell) {
            // Smooth edge transition
            vec2 edgeDistance = abs(localPos) - vec2(cellBoundary);
            float fadeAlpha = 1.0 - smoothstep(0.0, edgeFade, max(edgeDistance.x, edgeDistance.y));
            if (fadeAlpha <= 0.0) discard;
        }

            // Pre-calculate values needed for the depth loop
            float distToCenter = length(coord - cellCenter);
            float timeScale = u_time * 0.1;
            vec2 baseNoiseCoord = gridCoord * 0.1;
            vec2 timeOffset = vec2(timeScale, timeScale + 100.0);
            
            // Calculate distortion influence once
            float distortionInfluence = length(gridOffset) / (u_cellSize * 2.0);
            float baseNoiseFBM = fbmSimplexNoise(gridCoord * (u_cellSize / u_resolution.y) * 0.05, 4) + distortionInfluence * 0.2;
            
            vec2 noiseOffset = vec2(
                noise(baseNoiseCoord + timeOffset.xx, u_nS),
                noise(baseNoiseCoord + timeOffset.yy, u_nS)
            );
            
            // Pre-calculate common values for the loop
            float gridSize = u_cellSize * mix(0.3, 2.5, baseNoiseFBM + distortionInfluence * 0.2);
            vec2 localCoord = mod(coord + noiseOffset, gridSize);
            
            float randomAngle = floor(noise(gridCoord + noiseOffset, u_nS) * 4.0) * (M_PI * 0.5);
            float sinA = fastSin(randomAngle);
            float cosA = fastCos(randomAngle);
            vec2 rotatedCoord = vec2(
                localCoord.x * cosA - localCoord.y * sinA,
                localCoord.x * sinA + localCoord.y * cosA
            );
            
            float smoothedTime = u_time * 0.01 + simplexNoise(vec2(u_time * 0.3, 50.0), u_nS) * 0.005;
            
            vec2 noiseInput1 = rotatedCoord * ((u_cellSize / u_resolution.y) * 1.0) + smoothedTime;
            vec2 noiseInput2 = (rotatedCoord + gridCoord * gridSize) * ((u_cellSize / u_resolution.y) * 1.0) * u_noiseScale;
            
            float flowNoise = fbmSimplexNoise(noiseInput1, 6);
            vec2 animatedCoord = noiseInput2 + vec2(
                simplexNoise(vec2(flowNoise, u_time * 0.05), u_nS),
                simplexNoise(vec2(flowNoise, u_time * 0.05 + 100.0), u_nS)
            ) * u_flowSpeed * 0.005;
            
            float curlNoise = fbmSimplexNoise(animatedCoord * (u_cellSize / u_resolution.y) * 20.0 + vec2(u_nS), 8);
            animatedCoord += 4.0 * vec2(
                cos(curlNoise * 6.28318),
                sin(curlNoise * 6.28318)
            );
            
            // Color blending can use low precision
            lowp vec4 color = vec4(0.0);
            
            // Main loop variables
            mediump float depthNoiseValue, depthFactor, colorT;
            lowp vec3 color1, color2, enhancedColor1, enhancedColor2, blendedColor;
            
            // Calculate base noise values that won't change in the loop
            float baseNoise = fbmSimplexNoise(animatedCoord * (u_cellSize / u_resolution.y) * 0.15 + noiseOffset, 5);
            float combinedNoise = (baseNoise * 0.3 + baseNoiseFBM * 0.7 + 3.0) * 0.3;
            
            // Calculate depth once
            float clampedNoise = clamp(combinedNoise, 0.0, 1.0);
            int dynamicDepth = int(clamp(
                clampedNoise * float(u_maxDepth),
                1.0,
                min(float(u_maxDepth), float(MAX_LOOP_DEPTH))
            ));
            
            // Pre-calculate threshold and blend factor outside loop
            float threshold = 0.55 - (0.15 * pow(1.0 - u_bS, 2.0));
            
            float t = simplexNoise(vec2(u_time * 0.01), 0.0) * 0.5 + 0.5;
            float angleInfluence = simplexNoise(vec2(u_time * 0.005), 0.0) * 0.5 + 0.5;
            float blendFactor = t * t * (3.0 - 2.0 * t) * (1.0 + combinedNoise * 0.8 + angleInfluence * 1.2);
            
            // Prepare edge values for color transitions
            float edge0 = 0.2 + sin(u_time * 0.0002) * 0.3;
            float edge1 = 0.8 + cos(u_time * 0.0002) * 0.5;
            
            // Get flow direction for current cell
            vec2 flowDir = getFlowDirection(cellCenter, u_time);
            float flowAngle = atan(flowDir.y, flowDir.x);
            
            // Process each depth level with minimal branching
            for (int depth = 0; depth < MAX_LOOP_DEPTH; depth++) {
                // Break condition at the top to avoid unnecessary loop iterations
                if (depth >= dynamicDepth) break;
                
                // Early exit if we've achieved sufficient opacity
                if (color.a > 0.98) break;
                
                depthNoiseValue = noise(animatedCoord * float(depth + 1), u_nS);
                depthFactor = float(depth) / float(MAX_LOOP_DEPTH);
                
                // Skip early if noise threshold not met with a wider margin
                if (depthNoiseValue <= threshold - 0.1) continue;
                
                // Skip processing for areas with minimal contribution
                if (depthFactor > 0.9 && depthNoiseValue < threshold + 0.1) continue;
                
                // Get glyph parameters with distance-based detail reduction
                float currentSize = mix(0.3, 1.2, depthFactor) * u_cellSize;
                float distanceFromCenter = length(localPos);
                
                // Skip distant or small glyphs
                if (distanceFromCenter > currentSize * 3.0) continue;
                
                // Rotate point to align with flow
                vec2 rotatedP = vec2(
                    localPos.x * fastCos(-flowAngle) - localPos.y * fastSin(-flowAngle),
                    localPos.x * fastSin(-flowAngle) + localPos.y * fastCos(-flowAngle)
                );
                
                // Glyph grid calculation with optimized flow influence
                float flowStrength = length(flowDir);
                float mappedOffset = mix(0.5, 1.2, flowStrength);
                vec2 glyphCell = floor(rotatedP / currentSize + mappedOffset);
                vec2 localGlyphPos = rotatedP - glyphCell * currentSize;
                
                // Get glyph pattern with distance-based detail reduction
                float glyphNoise;
                if (distanceFromCenter > currentSize * 2.0) {
                    // Use simpler pattern for distant glyphs
                    glyphNoise = step(0.5, noise(floor(glyphCell * 0.5) * 2.0, u_nS));
                } else {
                    glyphNoise = getGlyphPattern(glyphCell, float(depth), u_nS, vTexCoord);
                }
                
                // Simplified glyph checks
                bool centerActive = abs(glyphCell.x) < 0.5 && abs(glyphCell.y) < 0.5;
                bool noiseActive = length(glyphCell) < 1.5 && glyphNoise > 0.5;
                bool lineActive = abs(localGlyphPos.x) < currentSize * 0.15 || abs(localGlyphPos.y) < currentSize * 0.15;
                
                bool insideGlyph = centerActive || noiseActive || lineActive;
                
                // Skip if not inside glyph
                if (!insideGlyph) continue;
                
                // Color calculation with optimized blending
                colorT = smoothstep(edge0, edge1, depthFactor + combinedNoise * 0.9);
                
                color1 = getColorFromPalette(colorT);
                color2 = getColorFromPalette(1.0 - colorT);
                
                // Apply depth boost with reduced calculations
                float depthBoost = 1.2 + (1.0 - depthFactor) * 0.8;
                color1 *= depthBoost;
                color2 *= depthBoost;
                
                enhancedColor1 = enhanceColor(color1, combinedNoise);
                enhancedColor2 = enhanceColor(color2, combinedNoise);
                
                blendedColor = blendColors(enhancedColor1, enhancedColor2, blendFactor);
                
                // Add to final color with optimized alpha blending
                float alphaFactor = 1.0 - depthNoiseValue * 0.7;
                if (alphaFactor > 0.01) { // Skip negligible contributions
                color.rgb *= 1.0;
                    color += vec4(blendedColor, 1.0) * alphaFactor;
                }
            }
            
            // Final color check
            if (color.a == 0.0) {
                color = u_baseColor;
            }
            
            gl_FragColor = color;
        }
    </script>

    <script>
        let bS = 1.0;     
        const cV = 6;  
        let tS;
        let dM = 0;
        let cS;      
        let bN = 0.002;  
        let nS;
        let fS = 0.005;
        let rSS;
        let roA;
        let nOX, nOY;
        let scF = 30;
        let tX = 0, tY = 0;
        let iTX = 0, iTY = 0;
        let pMX, pMY;
        let amV = [0.1, 0.075, 0.05]; 
        let isP = true;
        let stT = 0;
        let cuT = 0;
        let lum = 1.5;
        let vib = 2.5;
        let soS = 0.1;     
        let soF = 0.1;   
        let soA = 0.15;     
        let cuP;                  

        // Add performance monitoring system
        const TARGET_FRAMERATE = 60; // Target frame rate (can be lowered for better performance)
        let lastFrameTime = 0;      // For frame rate control
        let currentFPS = 60;        // Track current FPS
        let fpsUpdateTime = 0;      // Time of last FPS update
        const FPS_UPDATE_INTERVAL = 500; // Update FPS every 500ms
        const MIN_FPS_THRESHOLD = 20;    // Minimum FPS threshold for lowest quality
        const MID_FPS_THRESHOLD = 40;    // Medium FPS threshold for medium quality
        const PERFORMANCE_CHECK_INTERVAL = 2000; // Check performance every 2 seconds
        let lastPerformanceCheck = 0;    // Time of last performance check
        let currentPixelDensity;         // Track current pixel density
        let lastPixelDensityChange = 0;  // Track when we last changed pixel density
        const MIN_DENSITY_CHANGE_INTERVAL = 5000; // Minimum time between density changes (5 seconds)
        let canvasElement;               // Reference to canvas element
        let glContext;                   // Cached reference to WebGL context
        
        // Pre-allocate arrays for better memory management
        const PREALLOCATED_ARRAY_SIZE = 1000;
        const recordingChunkPool = [];   // Pool of pre-allocated chunks for recording
        let recordingChunkIndex = 0;     // Current index in the recording chunk pool
        
        // Memory management flags
        let isMemoryCleanupScheduled = false;
        const MEMORY_CLEANUP_INTERVAL = 30000; // Run memory cleanup every 30 seconds
        let lastMemoryCleanup = 0;
        let isTabVisible = true; // Track tab visibility for better performance

        // Handle visibility changes to pause rendering when tab not active
        function handleVisibilityChange() {
            isTabVisible = document.visibilityState === 'visible';
            
            if (isTabVisible) {
                // Reset frame time tracking to avoid jumps
                lastFrameTime = performance.now();
                // Restart animation if paused
                if (isP) {
                    requestAnimationFrame(draw);
                }
            }
            
            // Take opportunity to clean up memory when tab is hidden
            if (!isTabVisible && !isMemoryCleanupScheduled) {
                performMemoryCleanup();
            }
        }

        // Memory management function that optimizes memory use
        function performMemoryCleanup() {
            isMemoryCleanupScheduled = true;
            
            // Use setTimeout to defer heavy operations until the tab is idle
            setTimeout(() => {
                // Clear any unused recording chunks
                if (Array.isArray(reCN) && reCN.length > 0) {
                    // Keep only chunks that are actually in use
                    if (!isR) {
                        reCN.length = 0;
                    }
                }
                
                // Reset preallocated arrays to reduce memory fragmentation
                recordingChunkIndex = 0;
                
                // Force garbage collection on WebGL if possible
                if (glContext) {
                    // Attempt to reduce GL memory usage by reducing texture size temporarily
                    // This will be restored on next draw
                    const tempDensity = pixelDensity();
                    if (tempDensity > 1) {
                        pixelDensity(1);
                        clear();
                        pixelDensity(tempDensity);
                    }
                }
                
                lastMemoryCleanup = performance.now();
                isMemoryCleanupScheduled = false;
                
                // If tab visible, request a frame to restore rendering
                if (isTabVisible && isP) {
                    requestAnimationFrame(draw);
                }
            }, 100);
        }

        // Cached uniform values to prevent redundant updates
        const cachedUniforms = {
            bS: null,
            scaleFactor: null,
            translation: [null, null],
            resolution: [null, null],
            time: null,
            cellSize: null,
            flowSpeed: null,
            luminosity: null,
            vibrancy: null,
            sortStrength: null,
            sortFrequency: null,
            sortAnimSpeed: null,
            currentPattern: null,
            noiseScale: null,
            caScaleVariation: null
        };

        let inscription_id = window.location.pathname.split("/").pop();
        
        // REMOVE AFTER TESTING!!!
            let chars = "0123456789abcdefghijklmnopqrstuvwsyz";
            inscription_id = new URLSearchParams(window.location.search).get("seed") || Array(64).fill(0).map(_=>chars[(Math.random()*chars.length)|0]).join('');
        // REMOVE AFTER TESTING!!!



        class Rnd{
            constructor(seed) {
                const i=Math.imul,h=t=>{let e,l=0;for(e=1779033703^t.length;l<t.length;l++){let h=e^t.charCodeAt(l);e=i(h,3432918353),e=e<<13|e>>>19}return()=>(e=i(e^e>>>16,2246822507),e=i(e^e>>>13,3266489909),(e^=e>>>16)>>>0)},a=(e,r,t,a)=>()=>{let l=((e|=0)+(r|=0)|0)+(a|=0)|0;return a=a+1|0,e=r^r>>>9,r=(t|=0)+(t<<3)|0,t=(t=t<<21|t>>>11)+l|0,(l>>>0)/4294967296},X=h(seed);this.R=a(X(),X());
            }
            D=_=>this.R();                  
            N=(r,t)=>r+(t-r)*this.D();     
            I=(r,t)=>0|this.N(r,t+1);      
            B=r=>this.D()<r               
        };
        let R = new Rnd(inscription_id)

        console.log('Inscription ID:', inscription_id)


        function upTC() {
            // Calculate visible area size
            let viW, viH;
            
            if (ADAPTIVE_RESOLUTION.ENABLED) {
                // When using adaptive resolution, calculate with display dimensions
                const displayRatio = currentResolutionScale;
                viW = (width / displayRatio) / scF;
                viH = (height / displayRatio) / scF;
            } else {
                viW = width / scF;
                viH = height / scF;
            }
            
            tX = -width/2 + (viW * scF/2);
            tY = -height/2 + (viH * scF/2);
        }
        
        // Function to detect system capabilities for better default settings
        function detectDeviceCapabilities() {
            // User agent detection for device type
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isTablet = /iPad|tablet|Nexus 7|Nexus 10/i.test(navigator.userAgent);
            
            // GPU detection through WebGL
            let gpuInfo = "unknown";
            let isLowEndDevice = false;
            
            if (glContext) {
                const debugInfo = glContext.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    const renderer = glContext.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    gpuInfo = renderer;
                    
                    // Check for low-end GPUs or integrated graphics
                    const lowerRenderer = renderer.toLowerCase();
                    isLowEndDevice = lowerRenderer.includes('intel') || 
                                     lowerRenderer.includes('hd graphics') ||
                                     lowerRenderer.includes('mali') ||
                                     lowerRenderer.includes('adreno') ||
                                     isMobile;
                }
            }
            
            // Adjust resolution settings based on detected capabilities
            if (ADAPTIVE_RESOLUTION.ENABLED) {
                if (isLowEndDevice || isMobile) {
                    // Lower quality for mobile and low-end devices
                    ADAPTIVE_RESOLUTION.MIN_SCALE = 0.4;
                    ADAPTIVE_RESOLUTION.MAX_SCALE = 0.8;
                    ADAPTIVE_RESOLUTION.TARGET_FPS = 40;
                    
                    // Start with lower resolution
                    if (currentResolutionScale > 0.6) {
                        applyResolutionScale(0.6);
                    }
                } else if (isTablet) {
                    // Medium quality for tablets
                    ADAPTIVE_RESOLUTION.MIN_SCALE = 0.5;
                    ADAPTIVE_RESOLUTION.MAX_SCALE = 0.9;
                    ADAPTIVE_RESOLUTION.TARGET_FPS = 45;
                    
                    // Start with medium resolution
                    if (currentResolutionScale > 0.75) {
                        applyResolutionScale(0.75);
                    }
                } else {
                    // Higher quality for desktops
                    ADAPTIVE_RESOLUTION.MIN_SCALE = 0.6;
                    ADAPTIVE_RESOLUTION.MAX_SCALE = 1.0;
                    ADAPTIVE_RESOLUTION.TARGET_FPS = 50;
                }
            }
            
            // For pixel density-based quality approach, adjust based on device capabilities
            if (!ADAPTIVE_RESOLUTION.ENABLED && isLowEndDevice) {
                currentPixelDensity = 1.0;
                pixelDensity(currentPixelDensity);
            }
            
            // Log device information
            console.log(`Device detected: ${isMobile ? 'Mobile' : isTablet ? 'Tablet' : 'Desktop'}`);
            console.log(`GPU: ${gpuInfo}`);
            console.log(`Performance mode: ${isLowEndDevice ? 'Low-end' : 'High-end'}`);
            
            return {
                isMobile,
                isTablet,
                isLowEndDevice,
                gpuInfo
            };
        }

        function geT() {
            const d = new Date();
            const pad = n => n.toString().padStart(2, '0');
            return `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
        }

        function preload() {
            // Only initialize shader once for better performance
            if (!tS) {
            let vertexShader = document.getElementById('vertex-shader').textContent;
            let fragmentShader = document.getElementById('fragment-shader').textContent;
            tS = createShader(vertexShader, fragmentShader);
            }
        }

        function suEH() {
            // Cache canvas reference
            const canvas = canvasElement;
            
            // Event listener references for proper cleanup
            const eventListeners = {
                keydown: null,
                keyup: null,
                mousedown: null,
                mousemove: null,
                mouseup: null,
                touchstart: null,
                touchmove: null,
                touchend: null,
                visibilitychange: null,
                resize: null
            };
            
            // Throttling variables for mousemove/touchmove
            let lastMoveTime = 0;
            const MOVE_THROTTLE = 16; // ~ 60fps
            
            // Touch event tracking
            let lastTap = 0;
            let lastTapX = 0;
            let lastTapY = 0;
            let tapCount = 0;
            let tapTimeout = null;
            
            // Key state with Set for faster lookups
            const keyState = new Set();
            
            // Mouse/touch state
            let isDragging = false;
            let startX, startY;
            let startTX, startTY;
            
            // Clean up old event listeners if they exist
            function cleanupEventListeners() {
                // Remove existing listeners if they were created before
                for (const [type, handler] of Object.entries(eventListeners)) {
                    if (handler) {
                        if (type === 'resize') {
                            window.removeEventListener(type, handler);
                        } else if (type.startsWith('touch')) {
                            canvas.removeEventListener(type, handler, { passive: false });
                        } else {
                            document.removeEventListener(type, handler);
                        }
                    }
                }
            }
            
            // Optimized key event handler
            function handleKeyDown(e) {
                if (keyState.has(e.key)) return;
                keyState.add(e.key);
                
                switch(e.key.toLowerCase()) {
                    case 'a':
                        dM = (dM + 1) % 3;
                        requestAnimationFrame(upCS);
                        break;
                        
                    case 'r':
                        tX = iTX;
                        tY = iTY;
                        scF = 30;
                        upTC();
                        break;
                        
                    case 's':
                        isP = !isP;
                        if (isP) {
                            stT = millis() * 0.1;
                        } else {
                            cuT = (millis() - stT) / 1000.0;
                        }
                        break;
                        
                    case '1':
                    case '2':
                    case '3':
                        {  
                            const cuD = pixelDensity();
                            const nwD = e.key === '1' ? 4 : (e.key === '2' ? 5 : 5.5);
                            
                            pixelDensity(nwD);
                            draw();
                           
                            const tiS = geT();
                            const prefix = e.key === '1' ? 'shader_' : 'shader_hires_';
                            saveCanvas(prefix + tiS, 'png');
                            
                            pixelDensity(cuD);
                            draw();
                            break;  
                        }
                        
                    case 'd':
                        if (scF === 30) {
                            scF = 10;
                        } else {
                            scF = 30;
                        }
                        upTC();
                        break;
                    
                    case 'k':
                        if (!isR) {
                            stRe();
                        } else {
                            noRe();
                        }
                        break;
                }
            }
            
            function handleKeyUp(e) {
                keyState.delete(e.key);
            }
            
            // Optimized mouse event handlers with throttling
            function handleMouseDown(e) {
                if (e.button !== 0) return; // Only handle left mouse button
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startTX = tX;
                startTY = tY;
                
                // Apply cursor style once
                canvas.style.cursor = 'grabbing';
                
                // Prevent text selection while dragging
                e.preventDefault();
            }
            
            function handleMouseMove(e) {
                // Throttle move events
                const now = performance.now();
                if (isDragging && now - lastMoveTime > MOVE_THROTTLE) {
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    
                    // Apply translation directly with optimized calculation
                    tX = startTX - dx * (scF / 15);
                    tY = startTY + dy * (scF / 15);
                    
                    lastMoveTime = now;
                }
            }
            
            function handleMouseUp(e) {
                if (isDragging) {
                    isDragging = false;
                    canvas.style.cursor = 'grab';
                }
            }
            
            // Touch event handlers with optimization
            function handleTouchStart(e) {
                if (e.touches.length !== 1) return;
                
                const touch = e.touches[0];
                const currentTime = performance.now();
                
                isDragging = true;
                startX = touch.clientX;
                startY = touch.clientY;
                startTX = tX;
                startTY = tY;
                
                // Double/triple tap detection
                const tapDistance = Math.sqrt(
                    Math.pow(touch.clientX - lastTapX, 2) + 
                    Math.pow(touch.clientY - lastTapY, 2)
                );
                
                // Clear any existing timeout
                if (tapTimeout) {
                    clearTimeout(tapTimeout);
                }
                
                // Check if this is a quick consecutive tap
                if (currentTime - lastTap < 300 && tapDistance < 30) {
                    tapCount++;
                    
                    if (tapCount === 2) {
                        // Double tap - toggle pause
                        isP = !isP;
                        if (isP) {
                            stT = millis() * 0.1;
                        } else {
                            cuT = (millis() - stT) / 1000.0;
                        }
                        isDragging = false; // Prevent drag after double tap
                    } else if (tapCount === 3) {
                        // Triple tap - change scale
                        if (scF === 30) {
                            scF = 10;
                        } else {
                            scF = 30;
                        }
                        upTC();
                        tapCount = 0;
                        isDragging = false; // Prevent drag after triple tap
                    }
                } else {
                    // First tap of potential sequence
                    tapCount = 1;
                }
                
                // Update tap tracking
                lastTap = currentTime;
                lastTapX = touch.clientX;
                lastTapY = touch.clientY;
                
                // Set timeout to reset tap counter if no more taps happen
                tapTimeout = setTimeout(() => {
                    tapCount = 0;
                }, 300);
                
                // Prevent default to avoid scrolling
                e.preventDefault();
            }
            
            function handleTouchMove(e) {
                if (!isDragging || e.touches.length !== 1) return;
                
                // Throttle move events
                const now = performance.now();
                if (now - lastMoveTime > MOVE_THROTTLE) {
                    const touch = e.touches[0];
                    const dx = touch.clientX - startX;
                    const dy = touch.clientY - startY;
                    
                    // Apply optimized translation
                    tX = startTX - dx * (scF / 15);
                    tY = startTY + dy * (scF / 15);
                    
                    lastMoveTime = now;
                }
                
                // Prevent default to avoid scrolling
                e.preventDefault();
            }
            
            function handleTouchEnd(e) {
                isDragging = false;
                
                // Don't reset tap state here, as we want to track multi-taps
                // But ensure we prevent default for consistency
                e.preventDefault();
            }
            
            // Optimized resize handler using RAF for better performance
            function handleResize() {
                if (reTO) {
                    clearTimeout(reTO);
                    reTO = null;
                }
                
                reTO = setTimeout(() => {
                    requestAnimationFrame(upCS);
                }, 100);
            }
            
            // Clean up existing event listeners
            cleanupEventListeners();
            
            // Set up event listeners with proper options
            eventListeners.keydown = handleKeyDown;
            eventListeners.keyup = handleKeyUp;
            eventListeners.mousedown = handleMouseDown;
            eventListeners.mousemove = handleMouseMove;
            eventListeners.mouseup = handleMouseUp;
            eventListeners.touchstart = handleTouchStart;
            eventListeners.touchmove = handleTouchMove;
            eventListeners.touchend = handleTouchEnd;
            eventListeners.resize = handleResize;
            eventListeners.visibilitychange = handleVisibilityChange;
            
            // Add event listeners with appropriate options
            document.addEventListener('keydown', eventListeners.keydown);
            document.addEventListener('keyup', eventListeners.keyup);
            
            // Mouse events on document to catch cursor movement outside canvas
            document.addEventListener('mousedown', eventListeners.mousedown);
            document.addEventListener('mousemove', eventListeners.mousemove);
            document.addEventListener('mouseup', eventListeners.mouseup);
            
            // Touch events need { passive: false } to prevent scrolling
            canvas.addEventListener('touchstart', eventListeners.touchstart, { passive: false });
            canvas.addEventListener('touchmove', eventListeners.touchmove, { passive: false });
            canvas.addEventListener('touchend', eventListeners.touchend, { passive: false });
            
            // Window events
            window.addEventListener('resize', eventListeners.resize);
            document.addEventListener('visibilitychange', eventListeners.visibilitychange);
            
            // Initialize cursor style
            canvas.style.cursor = 'grab';
            
            // Return cleanup function for proper disposal
            return cleanupEventListeners;
        }

        function setup() {
            let canvas = createCanvas(windowWidth, windowHeight, WEBGL);
            // Store reference to canvas element
            canvasElement = document.querySelector('canvas');
            
            let gl = canvas.GL;
            // Cache GL context for better performance
            glContext = gl;
            
            // Apply WebGL optimizations
            gl.disable(gl.DEPTH_TEST);  
            gl.disable(gl.CULL_FACE);   
            gl.disable(gl.DITHER);      
            gl.disable(gl.STENCIL_TEST);
            
            // Enable optimizations for 2D rendering
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.hint(gl.GENERATE_MIPMAP_HINT, gl.FASTEST);
            
            // Initialize adaptive resolution
            currentResolutionScale = 1.0;
            fpsHistory = [60, 60, 60, 60, 60]; // Initialize with optimistic values
            lastResolutionCheck = performance.now();
            lastResolutionChange = performance.now();
            
            // Fixed depth for shader (not adaptive)
            const fixedMaxDepth = 5;
            
            // Detect device capabilities and adjust settings
            const deviceInfo = detectDeviceCapabilities();
            
            // Adjust resolution settings based on device type
            if (deviceInfo.isLowEndDevice) {
                // Start with lower resolution on low-end devices
                applyResolutionScale(0.7);
            } else if (deviceInfo.isTablet) {
                applyResolutionScale(0.85);
            }
            
            // Initialize pixel density (fixed at 1.0 since we're using adaptive resolution)
            currentPixelDensity = 1.0;
            pixelDensity(currentPixelDensity);
            
            // Initialize the cell size based on the fixed number of cells vertically
            // Regardless of resolution, we always want cV cells in the vertical dimension
            cS = windowHeight / cV;
            
            // Pre-allocate recording chunk pool if WebM recording is supported
            if (typeof MediaRecorder !== 'undefined') {
                // Initialize memory cleanup timer
                lastMemoryCleanup = performance.now();
                
                // Set up event listeners for visibility changes to optimize memory
                document.addEventListener('visibilitychange', handleVisibilityChange);
            }
            
            noStroke();
            
            // Use existing shader if available, otherwise create it
            if (!tS) {
            tS = createShader(
                document.getElementById('vertex-shader').textContent,
                document.getElementById('fragment-shader').textContent
            );
            }
            shader(tS);
            
            // Apply optimized WebGL rendering setup
            optimizeGLRendering();
            
            // Force initialize default values
            nS = nS || Math.floor(Math.random() * 1000);
            rSS = rSS || Math.floor(Math.random() * 1000);
            roA = roA || Math.floor(Math.random() * 360);
            cuP = typeof cuP !== 'undefined' ? cuP : Math.floor(Math.random() * 5);
            bN = bN || 0.002;
            fS = fS || 0.005;
            lum = lum || 1.5;
            vib = vib || 2.5;
            soS = soS || 0.1;
            soF = soF || 0.1;
            soA = soA || 0.15;
            bS = bS || 1.0;
            
            // Initialize essential uniforms with defaults to avoid black screen
            setShaderUniform('u_maxDepth', fixedMaxDepth); // Use fixed depth
            setShaderUniform('u_nS', nS);
            setShaderUniform('u_rSS', rSS);
            setShaderUniform('u_roA', radians(roA));
            setShaderUniform('u_nOS', [nOX || 0, nOY || 0]);
            setShaderUniform('u_amplitude', 0.1);
            setShaderUniform('u_initialFreq', 0.0005);
            setShaderUniform('u_baseModulation', 1.0);
            setShaderUniform('u_baseColor', [0.05, 0.05, 0.05, 1.0]);
            setShaderUniform('u_isLightBackground', false);
            setShaderUniform('u_randomColor1', [0.8, 0.2, 0.3]);
            setShaderUniform('u_randomColor2', [0.2, 0.7, 0.9]);
            setShaderUniform('u_randomColor3', [0.9, 0.8, 0.1]);
            setShaderUniform('u_luminosity', lum);
            setShaderUniform('u_vibrancy', vib);
            setShaderUniform('u_sortStrength', soS);
            setShaderUniform('u_sortFrequency', soF);
            setShaderUniform('u_sortAnimSpeed', soA);
            setShaderUniform('u_caScaleVariation', 0.5);
            
            // Update canvas size with the current aspect ratio and resolution settings
            upCS();
            
            if (inscription_id) {
                // Original initialization for specific inscription
                
                // Setup event handlers with optimized implementation
                suEH();
    
                nOX = R.I(0,2000);
                nOY = R.I(0,2000);
                setShaderUniform('u_nOS', [nOX, nOY]);

            let shiftX = -width/2;
            let shiftY = -height/2;
            iTX = shiftX;
            iTY = shiftY;
            tX = shiftX;
            tY = shiftY;
                setShaderUniform('u_translation', [tX, tY]);
    
                // Override random values for this inscription
                nS = R.I(0,1000);
                rSS = R.I(0,1000);
                roA = R.I(0, 360);
                cuP = R.I(0, 5);
                
                // Update uniforms with inscription-specific values
                setShaderUniform('u_nS', nS);
                setShaderUniform('u_rSS', rSS);
                setShaderUniform('u_roA', radians(roA));
                setShaderUniform('u_currentPattern', cuP);
            
            let teR = R.I(0, amV.length - 1);
            let raA = amV[teR];
                setShaderUniform('u_amplitude', raA);
            
            let inF = [0.0005, 0.0001, 0.005];
            let seF = inF[R.I(0,2)];
                setShaderUniform('u_initialFreq', seF);
            
            cS = windowHeight / cV;
            
            let noSO = [0.005, 0.003, 0.001];
            bN = noSO[R.I(0, 2)];  
                setShaderUniform('u_noiseScale', bN * (100.0 / floor(height / cV)));

            let baM = R.N(0.5, 2.0);  
                setShaderUniform('u_baseModulation', baM);

                // Color generation
            function caCD(color1, color2) {
                const dr = color1[0] - color2[0];
                const dg = color1[1] - color2[1];
                const db = color1[2] - color2[2];
                return Math.sqrt(dr * dr + dg * dg + db * db);
            }

            function geRC(brightnessType = 'light', baseHue = null, existingColors = []) {
                const miCD = 0.3;
                let at = 0;
                const maA = 10;

                while (at < maA) {
                    let h;
                    if (brightnessType === 'mid' && baseHue !== null) {
                        h = (baseHue + 0.5) % 1.0;
} else {
                        h = R.D();  
                    }

                    let s = R.N(0.8, 1.0);  
                    let v;
                    
                    switch(brightnessType) {
                        case 'dark':
                            v = R.N(0.15, 0.3);  
                            break;
                        case 'mid':
                            v = R.N(0.5, 0.65);  
                            break;
                        case 'light':
                            v = R.N(0.85, 1.0);  
                            break;
                    }
                    
                    let i = Math.floor(h * 6);
                    let f = h * 6 - i;
                    let p = v * (1 - s);
                    let q = v * (1 - f * s);
                    let t = v * (1 - (1 - f) * s);

                    let r, g, b;
                    switch (i % 6) {
                        case 0: r = v, g = t, b = p; break;
                        case 1: r = q, g = v, b = p; break;
                        case 2: r = p, g = v, b = t; break;
                        case 3: r = p, g = q, b = v; break;
                        case 4: r = t, g = p, b = v; break;
                        case 5: r = v, g = p, b = q; break;
                    }

                    const newColor = [r, g, b];
                   
                    let diC = true;
                    for (const existingColor of existingColors) {
                        if (caCD(newColor, existingColor) < miCD) {
                            diC = false;
                            break;
                        }
                    }

                    if (diC || at === maA - 1) {
                        return { color: newColor, hue: h };
                    }

                    at++;
                }
            }
            
            let liR = geRC('light', null, []);
            let rC1 = liR.color;  
            
            let miR = geRC('mid', liR.hue, [rC1]);
            let rC2 = miR.color;  
            
            let rC3 = geRC('dark', null, [rC1, rC2]).color;  

                // Update color uniforms with inscription-specific colors  
                setShaderUniform('u_randomColor1', rC1);
                setShaderUniform('u_randomColor2', rC2);
                setShaderUniform('u_randomColor3', rC3);
            
            let baC = [
                [0.05, 0.05, 0.05, 1.0],  
                [0.90, 0.87, 0.82, 1.0]    
            ];
            
            let sBaC = baC[R.D() < 0.6 ? 0 : 1];
            let liBc = sBaC[0] > 0.5;

                setShaderUniform('u_baseColor', sBaC);
                setShaderUniform('u_isLightBackground', liBc);
                
                let cASV = R.N(1.5, 3.0);
                setShaderUniform('u_caScaleVariation', cASV);
            } else {
                // Generic setup for no inscription
                suEH();
                
                // Set default scale and position
            scF = 30;
                tX = -width/2;
                tY = -height/2;
                iTX = tX;
                iTY = tY;

                // Update these in the shader too
                setShaderUniform('u_scaleFactor', scF);
                setShaderUniform('u_translation', [tX, tY]);
            }

            stT = millis();  
        }

        function upCS() {
            const wiR = windowWidth / windowHeight;
            let neW, neH;
            
            switch(dM) {
                case 0: 
                    neW = windowWidth;
                    neH = windowHeight;
                    break;
                
                case 1: 
                    if (wiR > 1) {
                        neH = windowHeight;
                        neW = windowHeight;
                    } else {
                        neW = windowWidth;
                        neH = windowWidth;
                    }
                    break;
                
                case 2: 
                    if (wiR > 2/3) {
                        neH = windowHeight;
                        neW = (windowHeight * 2) / 3;
                    } else {
                        neW = windowWidth;
                        neH = (windowWidth * 3) / 2;
                    }
                    break;
            }
            
            if (ADAPTIVE_RESOLUTION.ENABLED) {
                // Apply resolution scaling
                neW = Math.floor(neW * currentResolutionScale);
                neH = Math.floor(neH * currentResolutionScale);
            }
           
            if (width !== neW || height !== neH) {
                // Preserve current position relative to center 
                const oldCenterX = tX + width/2;
                const oldCenterY = tY + height/2;
                
                // Resize canvas
                resizeCanvas(neW, neH);
                
                // Update position to maintain view center
                tX = oldCenterX - neW/2;
                tY = oldCenterY - neH/2;
                
                // Set CSS display size to maintain proper display
                if (canvasElement) {
                    if (ADAPTIVE_RESOLUTION.ENABLED) {
                        // When using adaptive resolution, set display size to window dimensions
                        const displayWidth = dM === 0 ? windowWidth : 
                                            dM === 1 ? (wiR > 1 ? windowHeight : windowWidth) : 
                                            (wiR > 2/3 ? (windowHeight * 2) / 3 : windowWidth);
                                            
                        const displayHeight = dM === 0 ? windowHeight : 
                                             dM === 1 ? (wiR > 1 ? windowHeight : windowWidth) : 
                                             (wiR > 2/3 ? windowHeight : (windowWidth * 3) / 2);
                        
                        canvasElement.style.width = `${displayWidth}px`;
                        canvasElement.style.height = `${displayHeight}px`;
                    }
                    
                    canvasElement.style.position = 'absolute';
                    canvasElement.style.left = '50%';
                    canvasElement.style.top = '50%';
                    canvasElement.style.transform = 'translate(-50%,-50%)';
                }
            }
        }

        function draw() {
            // Skip rendering when tab is not visible
            if (!isTabVisible) {
                return;
            }
            
            // Request next frame early for better performance
            if (isP) {
                requestAnimationFrame(draw);
            }
            
            // Frame rate control for consistent animation
            const now = performance.now();
            const elapsed = now - lastFrameTime;
            const frameInterval = 1000 / TARGET_FRAMERATE;
            
            // FPS Calculation
            if (now - fpsUpdateTime > FPS_UPDATE_INTERVAL) {
                currentFPS = 1000 / (elapsed || 1);
                fpsUpdateTime = now;
                
                // Log FPS occasionally to avoid console spam
                if (frameCount % 60 === 0) {
                    console.log("FPS:", currentFPS.toFixed(1), "Resolution:", Math.round(currentResolutionScale * 100) + "%");
                }
                
                // Update performance tracking arrays
                fpsHistory.push(currentFPS);
                if (fpsHistory.length > 5) fpsHistory.shift();
                
                // Apply only adaptive resolution
                updateAdaptiveResolution();
            }
            
            // Periodic memory cleanup
            if (now - lastMemoryCleanup >= MEMORY_CLEANUP_INTERVAL) {
                performMemoryCleanup();
            }
            
            // Skip frame if we're rendering too quickly
            if (elapsed < frameInterval) {
                return;
            }
            
            // Update last frame time with adjustment to maintain consistent frame timing
            lastFrameTime = now - (elapsed % frameInterval);
            
            // Clear buffer with minimal overhead - add background for visibility
            clear();
            background(0); // Restore background to ensure visibility
            
            // Check if WebGL context is valid - recover if not
            if (!glContext || glContext.isContextLost()) {
                console.error("WebGL context lost, attempting to recover");
                // Try to reinitialize if context is lost
                if (canvasElement) {
                    glContext = canvasElement.getContext('webgl');
                    if (glContext) {
                        optimizeGLRendering();
                    }
                }
                return; // Skip this frame if we're trying to recover
            }
            
            // Synchronized time handling
            if (isP) {
                cuT = ((millis() - stT) / 1000.0);
            }

            if (mouseIsPressed && mouseButton === LEFT) {
                if (pMX !== undefined && pMY !== undefined) {
                    let deltaX = mouseX - pMX;
                    let deltaY = mouseY - pMY;
                    
                    tX -= deltaX * (scF / 5);
                    tY += deltaY * (scF / 5);
                }
                pMX = mouseX;
                pMY = mouseY;
            } else {
                pMX = undefined;
                pMY = undefined;
            }

            let scT = cuT; 

            // Ensure shader is bound correctly
            if (!tS) {
                console.error("Shader not initialized");
                // Recreate shader if it's null
                tS = createShader(
                    document.getElementById('vertex-shader').textContent,
                    document.getElementById('fragment-shader').textContent
                );
            }
            shader(tS);
            
            // Use fixed max depth of 5
            const fixedMaxDepth = 5;
            
            // Calculate cell size based on the fixed number of cells (cV)
            // When using adaptive resolution, adjust cell size to maintain proportions
            let displayHeight;
            if (ADAPTIVE_RESOLUTION.ENABLED) {
                // Calculate what the height would be at 100% resolution
                const fullResHeight = height / currentResolutionScale;
                // Use this for cell size calculation to maintain consistent cell count
                displayHeight = fullResHeight;
            } else {
                displayHeight = height;
            }
            
            // Update the cell size using the full resolution height to maintain proper scaling
            cS = displayHeight / cV;
            
            // Calculate noise scale properly based on the fixed cell count
            const cellSizePercent = displayHeight / cV;
            const noiseScale = bN * (100.0 / floor(cellSizePercent));
            
            // Batch update uniform values to minimize WebGL state changes
            // Use optimal shader uniform updates with caching to prevent redundant WebGL calls
            const uniforms = {
                'u_bS': bS,
                'u_scaleFactor': scF,
                'u_translation': [tX, tY],
                'u_resolution': [width, height],
                'u_time': scT,
                'u_cellSize': cS * bS, // Use properly calculated cell size
                'u_flowSpeed': fS,
                'u_luminosity': lum,
                'u_vibrancy': vib,
                'u_sortStrength': soS,
                'u_sortFrequency': soF,
                'u_sortAnimSpeed': soA,
                'u_currentPattern': cuP,
                'u_noiseScale': noiseScale,
                'u_caScaleVariation': 0.5,
                'u_maxDepth': fixedMaxDepth
            };
            
            try {
                // Update all uniforms at once to reduce shader binding state changes
                updateShaderUniforms(uniforms);
                
                // Use our optimized rendering function with fallbacks
                renderFullscreenQuad();
            } catch (e) {
                console.error("Error during rendering:", e);
                // Use most basic rendering as ultimate fallback
                rect(0, 0, width, height);
            }

            if (isR && (millis() - reST > reDu)) {
                noRe();
            }
        }
        
        function applyResolutionScale(scale) {
            // Skip if no change or outside valid range
            if (scale === currentResolutionScale || 
                scale < ADAPTIVE_RESOLUTION.MIN_SCALE || 
                scale > ADAPTIVE_RESOLUTION.MAX_SCALE) {
                return;
            }
            
            // Store current view center point in world coordinates
            // This is the key to maintaining visual position during resolution changes
            const viewCenterX = tX + (width / 2);
            const viewCenterY = tY + (height / 2);
            
            // Store current transformation scaling
            const oldScaleFactor = scF;
            
            // Store old dimensions for calculating scale ratio
            const oldWidth = width;
            const oldHeight = height;
            
            // Update resolution scale
            currentResolutionScale = scale;
            
            // Calculate new canvas size based on window size and scale
            const targetWidth = Math.floor(windowWidth * scale);
            const targetHeight = Math.floor(windowHeight * scale);
            
            // Only resize if significant change
            if (Math.abs(width - targetWidth) > 5 || Math.abs(height - targetHeight) > 5) {
                // Apply new size to the rendering buffer
                resizeCanvas(targetWidth, targetHeight);
                
                // Keep display size the same (CSS will handle scaling up)
                if (canvasElement) {
                    canvasElement.style.width = `${windowWidth}px`;
                    canvasElement.style.height = `${windowHeight}px`;
                    
                    // Ensure proper CSS centering
                    canvasElement.style.position = 'absolute';
                    canvasElement.style.left = '50%';
                    canvasElement.style.top = '50%';
                    canvasElement.style.transform = 'translate(-50%, -50%)';
                }
                
                console.log(`Adaptive resolution: ${Math.round(scale * 100)}% (${targetWidth}x${targetHeight})`);
                
                // Recalculate cell size to maintain the fixed number of cells vertically
                // This ensures visual consistency regardless of resolution
                cS = (windowHeight / cV);
                
                // Calculate new translation to maintain exact center point
                tX = viewCenterX - (width / 2);
                tY = viewCenterY - (height / 2);
            }
        }
        
        // Configure adaptive resolution system with stability settings
        const ADAPTIVE_RESOLUTION = {
            ENABLED: true,                  // Enable adaptive resolution
            MIN_SCALE: 0.4,                 // Minimum resolution scale (40% of full resolution)
            MAX_SCALE: 1.0,                 // Maximum resolution scale (100% of full resolution) 
            TARGET_FPS: 45,                 // Target FPS to maintain
            ADJUSTMENT_RATE: 0.1,           // How quickly to adjust resolution (higher = faster changes)
            CHECK_INTERVAL: 2000,           // How often to check performance (milliseconds)
            STABILITY_THRESHOLD: 8,         // FPS difference threshold for considering stable
            UPSCALE_DELAY: 5000,            // Wait time before attempting to increase resolution
            CHANGE_THRESHOLD: 0.05,         // Minimum FPS difference to trigger change (% of target)
            STABILITY_PERIOD: 20000,        // Once stable, lock resolution for this period (ms)
            MAX_CHANGES_PER_MINUTE: 4       // Limit total changes per minute to prevent oscillation
        };
        
        // Add variables to track resolution stability
        let resolutionStableUntil = 0;
        let lastResolutionChanges = [];
        
        // Update adaptive resolution to make smoother transitions
        function updateAdaptiveResolution() {
            // Skip if disabled
            if (!ADAPTIVE_RESOLUTION.ENABLED) return;
            
            const now = performance.now();
            
            // Only check periodically
            if (now - lastResolutionCheck < ADAPTIVE_RESOLUTION.CHECK_INTERVAL) return;
            lastResolutionCheck = now;
            
            // Check if we're in a stability period and should skip changes
            if (now < resolutionStableUntil) {
                return;
            }
            
            // Clean up old change timestamps
            const oneMinuteAgo = now - 60000;
            lastResolutionChanges = lastResolutionChanges.filter(time => time > oneMinuteAgo);
            
            // Check if we've made too many changes in the last minute
            if (lastResolutionChanges.length >= ADAPTIVE_RESOLUTION.MAX_CHANGES_PER_MINUTE) {
                console.log("Too many resolution changes recently, waiting to stabilize");
                return;
            }
            
            // Track FPS for stability detection
            const avgFps = fpsHistory.reduce((sum, fps) => sum + fps, 0) / fpsHistory.length;
            const fpsVariance = Math.max(...fpsHistory) - Math.min(...fpsHistory);
            isPerformanceStable = fpsVariance < ADAPTIVE_RESOLUTION.STABILITY_THRESHOLD;
            
            // Calculate FPS difference from target (as percentage)
            const fpsDiffPercent = Math.abs(avgFps - ADAPTIVE_RESOLUTION.TARGET_FPS) / ADAPTIVE_RESOLUTION.TARGET_FPS;
            
            // Only change if difference is significant
            if (fpsDiffPercent < ADAPTIVE_RESOLUTION.CHANGE_THRESHOLD && isPerformanceStable) {
                // If we're within threshold of target and stable, lock in this resolution
                if (resolutionStableUntil === 0) {
                    console.log(`Resolution ${Math.round(currentResolutionScale * 100)}% locked for stability period`);
                    resolutionStableUntil = now + ADAPTIVE_RESOLUTION.STABILITY_PERIOD;
                }
                return;
            }
            
            let newScale = currentResolutionScale;
            
            // If FPS is too low, decrease resolution more aggressively
            if (avgFps < ADAPTIVE_RESOLUTION.TARGET_FPS - 15) {
                // Large drop for very poor performance
                newScale = Math.max(
                    ADAPTIVE_RESOLUTION.MIN_SCALE,
                    currentResolutionScale - ADAPTIVE_RESOLUTION.ADJUSTMENT_RATE
                );
            } 
            // If FPS is slightly low, make smaller adjustments
            else if (avgFps < ADAPTIVE_RESOLUTION.TARGET_FPS - 5) {
                newScale = Math.max(
                    ADAPTIVE_RESOLUTION.MIN_SCALE,
                    currentResolutionScale - (ADAPTIVE_RESOLUTION.ADJUSTMENT_RATE / 2)
                );
            }
            // If FPS is good and we haven't changed recently, try increasing resolution
            else if (avgFps > ADAPTIVE_RESOLUTION.TARGET_FPS + 15 && 
                      now - lastResolutionChange > ADAPTIVE_RESOLUTION.UPSCALE_DELAY &&
                      isPerformanceStable) {
                // Only increase resolution when performance is very good and stable
                newScale = Math.min(
                    ADAPTIVE_RESOLUTION.MAX_SCALE,
                    currentResolutionScale + (ADAPTIVE_RESOLUTION.ADJUSTMENT_RATE / 4) // Very slow upscaling
                );
            }
            
            // Apply the change if it's different enough to matter
            if (Math.abs(newScale - currentResolutionScale) > 0.03) {
                applyResolutionScale(newScale);
                lastResolutionChange = now;
                lastResolutionChanges.push(now);
                
                // Reset stability period when we make a change
                resolutionStableUntil = 0;
            }
        }

        // Efficient batch update of shader uniforms
        function updateShaderUniforms(uniformsObj) {
            // Ensure shader is bound only once
            shader(tS);
            
            // Update all uniforms in a batch
            for (const [name, value] of Object.entries(uniformsObj)) {
                // Use our existing caching function to skip redundant updates
                setShaderUniform(name, value);
            }
        }
        
        // Modified optimizeGLRendering to enable faster draw paths
        function optimizeGLRendering() {
            // Ensure WebGL context is valid
            if (!glContext) {
                console.error("No WebGL context found when optimizing");
                if (canvasElement) {
                    try {
                        glContext = canvasElement.getContext('webgl');
                    } catch (e) {
                        console.error("Failed to get WebGL context:", e);
                        return;
                    }
                }
                if (!glContext) return;
            }
            
            // Reset WebGL context state to known good values
            try {
                // Optimize WebGL state for this specific renderer
                glContext.disable(glContext.DEPTH_TEST);
                glContext.disable(glContext.CULL_FACE);
                glContext.disable(glContext.DITHER);
                glContext.disable(glContext.STENCIL_TEST);
                
                // Enable blend mode optimized for our 2D rendering
                glContext.enable(glContext.BLEND);
                glContext.blendFunc(glContext.SRC_ALPHA, glContext.ONE_MINUS_SRC_ALPHA);
                
                // Set rendering hints
                glContext.hint(glContext.GENERATE_MIPMAP_HINT, glContext.FASTEST);
                
                // Create complete shader program for direct rendering
                try {
                    // Get the shader source code
                    const vertSrc = document.getElementById('vertex-shader').textContent;
                    const fragSrc = document.getElementById('fragment-shader').textContent;
                    
                    // Create program
                    const directProgram = glContext.createProgram();
                    
                    // Create and compile vertex shader
                    const vertShader = glContext.createShader(glContext.VERTEX_SHADER);
                    glContext.shaderSource(vertShader, vertSrc);
                    glContext.compileShader(vertShader);
                    
                    // Create and compile fragment shader
                    const fragShader = glContext.createShader(glContext.FRAGMENT_SHADER);
                    glContext.shaderSource(fragShader, fragSrc);
                    glContext.compileShader(fragShader);
                    
                    // Attach shaders to program and link
                    glContext.attachShader(directProgram, vertShader);
                    glContext.attachShader(directProgram, fragShader);
                    glContext.linkProgram(directProgram);
                    
                    // Check for errors
                    if (!glContext.getProgramParameter(directProgram, glContext.LINK_STATUS)) {
                        throw new Error("Direct rendering program failed to link: " + 
                                        glContext.getProgramInfoLog(directProgram));
                    }
                    
                    // Store program for direct rendering
                    glContext.directProgram = directProgram;
                    
                    // Get attribute locations
                    glContext.posAttribLoc = glContext.getAttribLocation(directProgram, "aPosition");
                    glContext.texAttribLoc = glContext.getAttribLocation(directProgram, "aTexCoord");
                } catch (e) {
                    console.error("Failed to create direct rendering program:", e);
                }
                
                // Create vertex buffer for more efficient quad rendering
                const buffer = glContext.createBuffer();
                if (!buffer) {
                    console.error("Failed to create WebGL buffer");
                    glContext.isOptimizedRenderingEnabled = false;
                    return;
                }
                
                glContext.bindBuffer(glContext.ARRAY_BUFFER, buffer);
                
                // Create better structured quad with positions and texcoords interleaved
                // Format: x, y, z, s, t (position and texcoord)
                const vertices = new Float32Array([
                    -1.0, -1.0, 0.0, 0.0, 0.0,
                    1.0, -1.0, 0.0, 1.0, 0.0,
                    1.0, 1.0, 0.0, 1.0, 1.0,
                    -1.0, 1.0, 0.0, 0.0, 1.0
                ]);
                
                glContext.bufferData(glContext.ARRAY_BUFFER, vertices, glContext.STATIC_DRAW);
                
                // Store the vertices buffer for later use
                glContext.quadBuffer = buffer;
                glContext.isOptimizedRenderingEnabled = true;
                console.log("WebGL optimization successful - direct rendering enabled");
            } catch (e) {
                // Fallback if custom buffer creation fails
                console.error("WebGL optimization failed:", e);
                glContext.isOptimizedRenderingEnabled = false;
            }
        }

        // Add debug helper function for direct WebGL path
        function debugRenderingInfo(message, level = 'info') {
            // Only log in development mode or when forced
            const isDebugEnabled = false; // Change to true for debugging
            if (isDebugEnabled) {
                switch(level) {
                    case 'error': console.error('[WebGL Direct]', message); break;
                    case 'warn': console.warn('[WebGL Direct]', message); break;
                    default: console.log('[WebGL Direct]', message);
                }
            }
        }
        
        // Optimized function to render a fullscreen quad with minimal state changes
        function renderFullscreenQuad() {
            if (!glContext) {
                console.error("No GL context for rendering fullscreen quad");
                return;
            }
            
            try {
                // Temporarily disable direct WebGL rendering path - use p5's path instead
                if (false && glContext.isOptimizedRenderingEnabled && glContext.directProgram) {
                    // Direct WebGL rendering path code left in place but disabled
                    // ...
                } else {
                    debugRenderingInfo("Using p5 fallback path", 'info');
                }
                
                // Always use p5's rendering path for now
            beginShape();
            vertex(0, 0, 0, 0, 0);
            vertex(2, 0, 0, 1, 0);
            vertex(2, 2, 0, 1, 1);
            vertex(0, 2, 0, 0, 1);
            endShape(CLOSE);
            } catch (e) {
                console.error("Error in renderFullscreenQuad:", e);
                // Ultimate fallback
                rect(0, 0, width, height);
            }
        }

        

        function upCS() {
            const wiR = windowWidth / windowHeight;
            let neW, neH;
            
            switch(dM) {
                case 0: 
                    neW = windowWidth;
                    neH = windowHeight;
                    break;
                
                case 1: 
                    if (wiR > 1) {
                        neH = windowHeight;
                        neW = windowHeight;
                    } else {
                        neW = windowWidth;
                        neH = windowWidth;
                    }
                    break;
                
                case 2: 
                    if (wiR > 2/3) {
                        neH = windowHeight;
                        neW = (windowHeight * 2) / 3;
                    } else {
                        neW = windowWidth;
                        neH = (windowWidth * 3) / 2;
                    }
                    break;
            }
           
            if (width !== neW || height !== neH) {
                resizeCanvas(neW, neH);
                
                tX = -neW/2;
                tY = -neH/2;
                
                // Use cached canvas reference instead of querying the DOM again
                if (canvasElement) {
                    canvasElement.style.cssText = 'position:absolute;left:50%;top:50%;transform:translate(-50%,-50%)';
                }
            }
        }

        
        let reTO;
        function windowResized() {
            // Cancel previous timeout to avoid memory leaks
            if (reTO) {
            clearTimeout(reTO);
                reTO = null;
            }
            
            // Use requestAnimationFrame for smoother updates and less performance impact
            // Debounce with setTimeout as a backup for consistent timing
            reTO = setTimeout(() => {
                // Use requestAnimationFrame to align with browser's render cycle
                requestAnimationFrame(upCS);
            }, 100);
        }

        
        let meR;
        let reCN = [];
        let isR = false;
        let reST;
        const reDu = 30000; 

        // Add these new functions
        function stRe() {
            // Clear previous chunks but keep the array to reduce allocations
            reCN.length = 0;
            recordingChunkIndex = 0;
            
            // Use cached canvas element reference
            const stream = canvasElement.captureStream(60); 
            meR = new MediaRecorder(stream, {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 50000000 
            });

            meR.ondataavailable = (e) => {
                if (e.data && e.data.size > 0) {
                    // Store only non-empty chunks
                    reCN.push(e.data);
                }
            };

            meR.onstop = saRe;

            // Schedule regular data chunks to avoid memory spikes
            meR.start(1000); // Request data in 1-second chunks
            isR = true;
            reST = millis();
        }

        function noRe() {
            if (meR && meR.state !== 'inactive') {
            meR.stop();
            isR = false;
            }
        }

        function saRe() {
            if (reCN.length === 0) {
                console.log('No recording data available.');
                return;
            }
            
            // Create blob using a single operation
            const blob = new Blob(reCN, {type: 'video/webm'});
            
            // Generate timestamp for filename
            const timestamp = geT();
            
            // Create download link
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `recording_${timestamp}.webm`;
            a.style.display = 'none';
            
            // Add to DOM, click, and remove to trigger download
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
                // Clear chunks array
                reCN.length = 0;
            }, 100);
        }

        // Function to set uniform values to shader with caching
        function setShaderUniform(name, value, cachedName = null) {
            // Use provided cachedName or derive from uniform name
            const cacheKey = cachedName || name.replace('u_', '');
            
            // Handle array values
            if (Array.isArray(value)) {
                // Check each element in array
                if (
                    !cachedUniforms[cacheKey] || 
                    value.some((v, i) => v !== cachedUniforms[cacheKey][i])
                ) {
                    // Update cache with defensive copy
                    cachedUniforms[cacheKey] = [...value];
                    
                    // Set the actual WebGL uniform
                    tS.setUniform(name, value);
                }
            } else {
                // For primitive values, simple comparison
                if (cachedUniforms[cacheKey] !== value) {
                    // Update cache
                    cachedUniforms[cacheKey] = value;
                    
                    // Set the actual WebGL uniform
                    tS.setUniform(name, value);
                }
            }
        }

        // Add these variables to track adaptive resolution state
        let currentResolutionScale = 1.0;
        let lastResolutionCheck = 0;
        let lastResolutionChange = 0;
        let fpsHistory = [];
        let isPerformanceStable = false;
        
        function updateAdaptiveComplexity() {
            // Skip if disabled
            if (!ADAPTIVE_COMPLEXITY.ENABLED) return;
            
            const now = performance.now();
            
            // Only check periodically
            if (now - lastDepthCheck < ADAPTIVE_COMPLEXITY.CHECK_INTERVAL) return;
            lastDepthCheck = now;
            
            // Only adjust if enough time has passed since last change
            if (now - lastDepthChange < ADAPTIVE_COMPLEXITY.CHANGE_DELAY) return;
            
            // Use the same FPS data we're already collecting
            const avgFps = fpsHistory.reduce((sum, fps) => sum + fps, 0) / fpsHistory.length;
            
            // Determine if we need to adjust depth
            let newDepth = currentDepth;
            
            // If FPS is too low, decrease depth
            if (avgFps < ADAPTIVE_COMPLEXITY.TARGET_FPS) {
                // Find the highest quality level that's lower than current
                for (let i = ADAPTIVE_COMPLEXITY.QUALITY_LEVELS.length - 1; i >= 0; i--) {
                    if (ADAPTIVE_COMPLEXITY.QUALITY_LEVELS[i] < currentDepth) {
                        newDepth = ADAPTIVE_COMPLEXITY.QUALITY_LEVELS[i];
                        break;
                    }
                }
                // Ensure we don't go below minimum
                newDepth = Math.max(ADAPTIVE_COMPLEXITY.MIN_DEPTH, newDepth);
            } 
            // If FPS is high, try increasing depth
            else if (avgFps > ADAPTIVE_COMPLEXITY.UPSCALE_THRESHOLD) {
                // Find the lowest quality level that's higher than current
                for (let i = 0; i < ADAPTIVE_COMPLEXITY.QUALITY_LEVELS.length; i++) {
                    if (ADAPTIVE_COMPLEXITY.QUALITY_LEVELS[i] > currentDepth) {
                        newDepth = ADAPTIVE_COMPLEXITY.QUALITY_LEVELS[i];
                        break;
                    }
                }
                // Ensure we don't exceed maximum
                newDepth = Math.min(ADAPTIVE_COMPLEXITY.MAX_DEPTH, newDepth);
            }
            
            // Apply the change if it's different
            if (newDepth !== currentDepth) {
                applyDepthChange(newDepth);
                lastDepthChange = now;
            }
        }
        
        function applyDepthChange(depth) {
            if (depth === currentDepth) return;
            
            currentDepth = depth;
            setShaderUniform('u_maxDepth', depth);
            
            // You can also adjust other complexity parameters here if needed
            // For example, reducing noise detail, disabling effects, etc.
            
            // Optionally disable certain effects at very low depths
            if (depth <= ADAPTIVE_COMPLEXITY.MIN_DEPTH) {
                setShaderUniform('u_enableGlyphNoiseDetail', false);
            } else {
                setShaderUniform('u_enableGlyphNoiseDetail', true);
            }
            
            console.log(`Adaptive complexity: Depth set to ${depth}`);
        }
    </script>
  </body>
</html>
