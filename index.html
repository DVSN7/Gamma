<!DOCTYPE html>
<html>
  <head>
    <title>Shader Art</title>
    <script src="https://ordinals.com/content/7e37766541506810ba6399c4b2735121f508bd9209df43dd200bf2316b014594i0"></script>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000;
        }
        canvas {
            width: 100% !important;
            height: 100% !important;
            object-fit: contain !important;
            max-width: 100vw;
            max-height: 100vh;
        }
        main {
            display: flex;
            justify-content: center;
            width: 100%;
            align-items: center;
            height: 100%;
        }
    </style>
  </head>
  <body>
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec3 aPosition;
        attribute vec2 aTexCoord;
        varying vec2 vTexCoord;

        void main() {
            vTexCoord = aTexCoord;
            vec4 positionVec4 = vec4(aPosition, 1.0);
            positionVec4.xy = positionVec4.xy * 2.0 - 1.0;
            gl_Position = positionVec4;
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        #endif

        #define M_PI 3.14159265358979323846

        varying vec2 vTexCoord;
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float u_cellSize;
        uniform float u_noiseScale;
        uniform float u_maxDepth;
        uniform float u_flowSpeed;
        uniform int u_paletteIndex1;
        uniform int u_paletteIndex2;
        uniform float u_noiseSeed;
        uniform float u_randomScaleSeed;
        uniform float u_rotationAngle;
        uniform vec2 u_noiseOffset;
        uniform float u_amplitude;
        uniform float u_scaleFactor;
        uniform vec2 u_translation;
        uniform vec4 u_backgroundColor;
        uniform float u_luminosity;
        uniform float u_vibrancy;
        uniform float u_initialFreq;
        uniform float u_baseScale;

        float random(vec2 st, float seed) {
            vec2 s = vec2(12.9898, 78.233);
            return fract(sin(dot(st.xy + seed, s)));
        }

        float noise(vec2 st, float seed) {
            vec2 i = floor(st);
            vec2 f = fract(st);
            
            vec2 u = f * f * (3.0 - 2.0 * f);
            
            float a = random(i, seed);
            float b = random(i + vec2(1.0, 0.0), seed);
            float c = random(i + vec2(0.0, 1.0), seed);
            float d = random(i + vec2(1.0, 1.0), seed);
            
            return mix(
                mix(a, b, u.x),
                mix(c, d, u.x),
                u.y);
        }

        vec3 mod289(vec3 x) { 
            return x - floor(x / 289.0) * 289.0; 
        }

        vec2 mod289(vec2 x) { 
            return x - floor(x / 289.0) * 289.0; 
        }

        vec3 permute(vec3 x) { 
            return mod289((x * 34.0 + 1.0) * x); 
        }

        float simplexNoise(vec2 v, float time) {
            const vec4 C = vec4(
                0.211324865405187,
                0.366025403784439,
                -0.577350269189626,
                0.024390243902439
            );
            
            v += vec2(time * 0.03);
            
            vec2 i = floor(v + dot(v, C.yy));
            vec2 x0 = v - i + dot(i, C.xx);
            
            vec2 i1 = x0.x > x0.y ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
            vec4 x12 = vec4(x0.x + C.x, x0.y + C.x, x0.x + C.z, x0.y + C.z);
            x12.xy -= i1;
            
            i = mod289(i);
            vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
            
            vec3 m = max(0.5 - vec3(
                dot(x0, x0),
                dot(vec2(x12.x, x12.y), vec2(x12.x, x12.y)),
                dot(vec2(x12.z, x12.w), vec2(x12.z, x12.w))
            ), 0.0);
            m = m * m * m * m;
            
            vec3 x = 2.0 * fract(p * C.www) - 1.0;
            vec3 h = abs(x) - 0.5;
            vec3 ox = floor(x + 0.5);
            vec3 a0 = x - ox;
            
            m *= 1.792842914 - 0.853734721 * (a0 * a0 + h * h);
            
            vec3 g = vec3(
                a0.x * x0.x + h.x * x0.y,
                a0.y * x12.x + h.y * x12.y,
                a0.z * x12.z + h.z * x12.w
            );
            
            return 130.0 * dot(m, g);
        }

        vec2 domainWarp(vec2 p, float time) {
            float distortion1 = simplexNoise(p * 0.3 + time * 0.001, time * 0.001);
            float distortion2 = simplexNoise((p + vec2(5.2, 1.3)) * 0.2 - time * 0.0015, time * 0.001);
            
            return p + vec2(
                distortion1 * 2.0 + sin(time * 0.1) * 0.5,
                distortion2 * 2.0 + cos(time * 0.05) * 0.5
            );
        }

        float layeredNoise(vec2 p, float time) {
            vec2 warped = domainWarp(p, time);
            
            float mainLayer = simplexNoise(warped, time);
            float detail = simplexNoise(warped * 1.0 + mainLayer * 0.5, time * 0.3) * 0.5;
            float background = simplexNoise(p * 0.1 + time * 0.01, time) * 0.3;
            
            return mainLayer * 0.6 + detail * 0.3 + background * 0.1;
        }

        float fbmSimplexNoise(vec2 v, int octaves) {
            if (octaves <= 0) return 0.0;
            
            v += u_noiseOffset;
            v += vec2(u_noiseSeed);
            
            const float PERSISTENCE = 0.15;
            const float LACUNARITY = 0.04;
            float INITIAL_FREQ = u_initialFreq;
            
            float total = 0.0;
            float amplitude = u_amplitude;
            float frequency = INITIAL_FREQ;
            
            vec2 warpedCoord = domainWarp(v, u_time * 0.1);
            float basePattern = layeredNoise(warpedCoord, u_time);
            
            total = amplitude * basePattern;
            
            for(int i = 1; i < 4; i++) {
                amplitude *= PERSISTENCE * (1.0 + float(i) * 0.3);
                frequency *= LACUNARITY * (1.0 + sin(u_time * 0.1) * 0.2);
                
                float angle = float(i) * 0.8 + u_time * 0.05;
                mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
                vec2 rotated = rot * warpedCoord;
                
                total += amplitude * layeredNoise(rotated * frequency, u_time * 0.9);
            }
            
            float modulation = sin(u_time * 0.1) * 0.2 + 0.9;
            total *= modulation;
            
            return total;
        }

        mat2 getRotationMatrix(float angle) {
            float c = cos(angle);
            float s = sin(angle);
            return mat2(c, -s, s, c);
        }

        vec3 getColorFromPalette(int pIdx, float t) {
            t = clamp(t, 0.0, 4.0) * 7.0;
            
            int segment = int(t);
            float frac = t - float(segment);
            
            vec3 c1, c2, c3, c4, c5, c6, c7, c8;
            
            if (pIdx == 0) {
                c1 = vec3(0.945, 0.165, 0.000);
                c2 = vec3(0.843, 0.145, 0.000);
                c3 = vec3(0.745, 0.129, 0.000);
                c4 = vec3(0.647, 0.110, 0.000);
                c5 = vec3(0.561, 0.184, 0.043);
                c6 = vec3(0.867, 0.545, 0.059);
                c7 = vec3(0.137, 0.820, 0.216);
                c8 = vec3(0.220, 0.400, 0.188);
            } else if (pIdx == 1) {
                c1 = vec3(1.000, 0.000, 0.000);
                c2 = vec3(1.000, 0.200, 0.000);
                c3 = vec3(1.000, 0.000, 0.200);
                c4 = vec3(1.000, 0.300, 0.000);
                c5 = vec3(1.000, 0.000, 0.300);
                c6 = vec3(1.000, 0.150, 0.000);
                c7 = vec3(1.000, 0.000, 0.150);
                c8 = vec3(1.000, 0.100, 0.100);
            } else if (pIdx == 2) {
                c1 = vec3(0.800, 0.100, 0.100);
                c2 = vec3(0.000, 0.700, 0.800);
                c3 = vec3(0.900, 0.200, 0.200);
                c4 = vec3(0.000, 0.800, 0.900);
                c5 = vec3(0.700, 0.000, 0.000);
                c6 = vec3(0.000, 0.700, 0.700);
                c7 = vec3(1.000, 0.300, 0.300);
                c8 = vec3(0.600, 0.000, 0.000);
            } else if (pIdx == 3) {
                c1 = vec3(0.900, 0.100, 0.100);
                c2 = vec3(0.900, 0.400, 0.100);
                c3 = vec3(0.900, 0.100, 0.400);
                c4 = vec3(0.500, 0.500, 0.000);
                c5 = vec3(1.000, 0.000, 0.500);
                c6 = vec3(0.800, 0.300, 0.000);
                c7 = vec3(0.800, 0.000, 0.300);
                c8 = vec3(0.700, 0.100, 0.100);
            } else if (pIdx == 4) {
                c1 = vec3(0.965, 0.925, 0.376);
                c2 = vec3(0.976, 0.839, 0.306);
                c3 = vec3(0.976, 0.784, 0.306);
                c4 = vec3(0.976, 0.659, 0.141);
                c5 = vec3(0.976, 0.659, 0.141);
                c6 = vec3(0.957, 0.498, 0.122);
                c7 = vec3(0.957, 0.498, 0.122);
                c8 = vec3(0.827, 0.192, 0.192);
            } else if (pIdx == 5) {
                c1 = vec3(0.965, 0.925, 0.376);
                c2 = vec3(0.965, 0.820, 0.173);
                c3 = vec3(0.961, 0.706, 0.000);
                c4 = vec3(0.961, 0.639, 0.000);
                c5 = vec3(0.659, 0.792, 0.941);
                c6 = vec3(0.420, 0.612, 0.820);
                c7 = vec3(0.231, 0.420, 0.608);
                c8 = vec3(0.169, 0.298, 0.490);
            } else if (pIdx == 6) {
                c1 = vec3(0.800, 0.600, 0.000);
                c2 = vec3(0.500, 0.100, 0.900);
                c3 = vec3(0.900, 0.700, 0.000);
                c4 = vec3(0.600, 0.200, 1.000);
                c5 = vec3(1.000, 0.800, 0.000);
                c6 = vec3(0.400, 0.000, 0.800);
                c7 = vec3(1.000, 0.850, 0.200);
                c8 = vec3(0.700, 0.500, 0.000);
            } else if (pIdx == 7) {
                c1 = vec3(1.000, 0.918, 0.000);
                c2 = vec3(1.000, 0.835, 0.000);
                c3 = vec3(1.000, 0.765, 0.000);
                c4 = vec3(1.000, 0.718, 0.000);
                c5 = vec3(1.000, 0.616, 0.000);
                c6 = vec3(1.000, 0.549, 0.000);
                c7 = vec3(1.000, 0.502, 0.000);
                c8 = vec3(1.000, 0.431, 0.000);
            } else if (pIdx == 8) {
                c1 = vec3(0.400, 0.300, 0.450);
                c2 = vec3(0.500, 0.400, 0.550);
                c3 = vec3(0.350, 0.250, 0.400);
                c4 = vec3(0.600, 0.500, 0.650);
                c5 = vec3(0.300, 0.200, 0.350);
                c6 = vec3(0.450, 0.350, 0.500);
                c7 = vec3(0.550, 0.450, 0.600);
                c8 = vec3(0.250, 0.150, 0.300);
            } else if (pIdx == 9) {
                c1 = vec3(0.455, 0.910, 0.824);
                c2 = vec3(0.776, 0.373, 0.271);
                c3 = vec3(0.847, 0.051, 0.302);
                c4 = vec3(0.824, 0.208, 0.541);
                c5 = vec3(0.804, 0.263, 0.761);
                c6 = vec3(0.784, 0.275, 0.976);
                c7 = vec3(0.847, 0.459, 0.996);
                c8 = vec3(0.910, 0.616, 0.996);
            } else if (pIdx == 10) {
                c1 = vec3(0.500, 0.100, 0.700);
                c2 = vec3(0.900, 0.800, 0.000);
                c3 = vec3(0.600, 0.200, 0.800);
                c4 = vec3(1.000, 0.900, 0.200);
                c5 = vec3(0.400, 0.000, 0.600);
                c6 = vec3(0.800, 0.700, 0.000);
                c7 = vec3(0.700, 0.300, 0.900);
                c8 = vec3(0.300, 0.000, 0.500);
            } else if (pIdx == 11) {
                c1 = vec3(0.500, 0.100, 0.700);
                c2 = vec3(0.300, 0.100, 0.800);
                c3 = vec3(0.700, 0.100, 0.600);
                c4 = vec3(0.400, 0.050, 0.900);
                c5 = vec3(0.800, 0.100, 0.500);
                c6 = vec3(0.200, 0.050, 0.700);
                c7 = vec3(0.900, 0.200, 0.600);
                c8 = vec3(0.600, 0.150, 0.800);
            } else if (pIdx == 12) {
                c1 = vec3(0.300, 0.350, 0.450);
                c2 = vec3(0.400, 0.450, 0.550);
                c3 = vec3(0.250, 0.300, 0.400);
                c4 = vec3(0.500, 0.550, 0.650);
                c5 = vec3(0.200, 0.250, 0.350);
                c6 = vec3(0.350, 0.400, 0.500);
                c7 = vec3(0.450, 0.500, 0.600);
                c8 = vec3(0.150, 0.200, 0.300);
            } else if (pIdx == 13) {
                c1 = vec3(0.000, 0.400, 1.000);
                c2 = vec3(0.000, 0.800, 1.000);
                c3 = vec3(0.200, 0.600, 1.000);
                c4 = vec3(0.000, 1.000, 1.000);
                c5 = vec3(0.000, 0.200, 1.000);
                c6 = vec3(0.400, 0.800, 1.000);
                c7 = vec3(0.000, 0.600, 1.000);
                c8 = vec3(0.200, 1.000, 1.000);
            } else if (pIdx == 14) {
                c1 = vec3(0.100, 0.300, 0.800);
                c2 = vec3(1.000, 0.500, 0.000);
                c3 = vec3(0.200, 0.400, 0.900);
                c4 = vec3(1.000, 0.600, 0.200);
                c5 = vec3(0.000, 0.200, 0.700);
                c6 = vec3(0.900, 0.400, 0.000);
                c7 = vec3(0.300, 0.500, 1.000);
                c8 = vec3(0.000, 0.100, 0.600);
            } else if (pIdx == 15) {
                c1 = vec3(0.200, 0.400, 0.900);
                c2 = vec3(0.000, 0.600, 0.800);
                c3 = vec3(0.300, 0.200, 0.100);
                c4 = vec3(0.000, 0.800, 0.800);
                c5 = vec3(0.400, 0.100, 0.800);
                c6 = vec3(0.100, 0.500, 0.700);
                c7 = vec3(0.500, 0.300, 0.900);
                c8 = vec3(0.100, 0.300, 0.800);
            } else if (pIdx == 16) {
                c1 = vec3(0.455, 0.910, 0.824);
                c2 = vec3(0.776, 0.373, 0.271);
                c3 = vec3(0.847, 0.051, 0.302);
                c4 = vec3(0.824, 0.208, 0.541);
                c5 = vec3(0.804, 0.263, 0.761);
                c6 = vec3(0.784, 0.275, 0.976);
                c7 = vec3(0.847, 0.459, 0.996);
                c8 = vec3(0.910, 0.616, 0.996);
            } else if (pIdx == 17) {
                c1 = vec3(0.500, 0.100, 0.700);
                c2 = vec3(0.900, 0.800, 0.000);
                c3 = vec3(0.600, 0.200, 0.800);
                c4 = vec3(1.000, 0.900, 0.200);
                c5 = vec3(0.400, 0.000, 0.600);
                c6 = vec3(0.800, 0.700, 0.000);
                c7 = vec3(0.700, 0.300, 0.900);
                c8 = vec3(0.300, 0.000, 0.500);
            } else if (pIdx == 18) {
                c1 = vec3(0.500, 0.100, 0.700);
                c2 = vec3(0.300, 0.100, 0.800);
                c3 = vec3(0.700, 0.100, 0.600);
                c4 = vec3(0.400, 0.050, 0.900);
                c5 = vec3(0.800, 0.100, 0.500);
                c6 = vec3(0.200, 0.050, 0.700);
                c7 = vec3(0.900, 0.200, 0.600);
                c8 = vec3(0.600, 0.150, 0.800);
            } else if (pIdx == 19) {
                c1 = vec3(0.765, 0.329, 0.208);
                c2 = vec3(0.867, 0.396, 0.247);
                c3 = vec3(0.949, 0.451, 0.294);
                c4 = vec3(0.984, 0.478, 0.345);
                c5 = vec3(1.000, 0.443, 0.427);
                c6 = vec3(1.000, 0.322, 0.518);
                c7 = vec3(0.992, 0.329, 0.569);
                c8 = vec3(0.976, 0.396, 0.608);
            } else if (pIdx == 20) {
                c1 = vec3(1.000, 0.780, 0.541);
                c2 = vec3(1.000, 0.792, 0.569);
                c3 = vec3(0.780, 0.976, 0.231);
                c4 = vec3(0.678, 0.957, 0.604);
                c5 = vec3(1.000, 0.827, 0.639);
                c6 = vec3(1.000, 0.839, 0.667);
                c7 = vec3(1.000, 0.851, 0.690);
                c8 = vec3(1.000, 0.863, 0.714);
            } else if (pIdx == 21) {
                c1 = vec3(1.000, 0.500, 0.000);
                c2 = vec3(0.000, 0.400, 1.000);
                c3 = vec3(1.000, 0.600, 0.200);
                c4 = vec3(0.200, 0.500, 1.000);
                c5 = vec3(0.900, 0.400, 0.000);
                c6 = vec3(0.000, 0.300, 0.900);
                c7 = vec3(1.000, 0.700, 0.300);
                c8 = vec3(0.800, 0.300, 0.000);
            } else if (pIdx == 22) {
                c1 = vec3(1.000, 0.500, 0.000);
                c2 = vec3(1.000, 0.300, 0.000);
                c3 = vec3(1.000, 0.700, 0.000);
                c4 = vec3(1.000, 0.200, 0.000);
                c5 = vec3(1.000, 0.800, 0.000);
                c6 = vec3(0.900, 0.400, 0.000);
                c7 = vec3(1.000, 0.600, 0.200);
                c8 = vec3(0.800, 0.400, 0.000);
            } else if (pIdx == 23) {
                c1 = vec3(0.914, 0.863, 0.804);
                c2 = vec3(0.867, 0.835, 0.831);
                c3 = vec3(0.820, 0.812, 0.859);
                c4 = vec3(0.773, 0.784, 0.882);
                c5 = vec3(0.725, 0.757, 0.906);
                c6 = vec3(0.682, 0.729, 0.929);
                c7 = vec3(0.635, 0.702, 0.949);
                c8 = vec3(0.592, 0.671, 0.969);
            } else if (pIdx == 24) {
                c1 = vec3(0.725, 1.000, 0.859);
                c2 = vec3(0.667, 1.000, 0.824);
                c3 = vec3(0.608, 1.000, 0.792);
                c4 = vec3(0.537, 1.000, 0.757);
                c5 = vec3(0.447, 0.933, 0.675);
                c6 = vec3(0.337, 0.800, 0.545);
                c7 = vec3(0.224, 0.671, 0.416);
                c8 = vec3(0.090, 0.549, 0.294);
            } else if (pIdx == 25) {
                c1 = vec3(0.100, 0.100, 0.100);
                c2 = vec3(0.900, 0.900, 0.900);
                c3 = vec3(0.200, 0.200, 0.200);
                c4 = vec3(0.800, 0.800, 0.800);
                c5 = vec3(0.300, 0.300, 0.300);
                c6 = vec3(0.700, 0.700, 0.700);
                c7 = vec3(0.400, 0.400, 0.400);
                c8 = vec3(0.600, 0.600, 0.600);
            } else if (pIdx == 26) {
                c1 = vec3(0.000, 0.000, 0.000);
                c2 = vec3(0.150, 0.150, 0.150);
                c3 = vec3(0.300, 0.300, 0.300);
                c4 = vec3(0.450, 0.450, 0.450);
                c5 = vec3(0.600, 0.600, 0.600);
                c6 = vec3(0.750, 0.750, 0.750);
                c7 = vec3(0.900, 0.900, 0.900);
                c8 = vec3(1.000, 1.000, 1.000);
            } else if (pIdx == 27) {
                c1 = vec3(1.000, 0.200, 0.200);
                c2 = vec3(0.200, 0.200, 1.000);
                c3 = vec3(1.000, 1.000, 0.200);
                c4 = vec3(0.800, 0.100, 0.100);
                c5 = vec3(0.100, 0.100, 0.800);
                c6 = vec3(0.800, 0.800, 0.100);
                c7 = vec3(1.000, 0.300, 0.300);
                c8 = vec3(0.300, 0.300, 1.000);
            } else if (pIdx == 28) {
                c1 = vec3(0.800, 0.200, 1.000);
                c2 = vec3(0.200, 0.800, 0.200);
                c3 = vec3(1.000, 0.600, 0.000);
                c4 = vec3(0.600, 0.100, 0.800);
                c5 = vec3(0.100, 0.600, 0.100);
                c6 = vec3(0.800, 0.400, 0.000);
                c7 = vec3(1.000, 0.400, 1.000);
                c8 = vec3(0.400, 1.000, 0.400);
            } else if (pIdx == 29) {
                c1 = vec3(0.000, 1.000, 1.000);
                c2 = vec3(1.000, 0.000, 1.000);
                c3 = vec3(1.000, 1.000, 0.000);
                c4 = vec3(0.000, 0.800, 0.800);
                c5 = vec3(0.800, 0.000, 0.800);
                c6 = vec3(0.800, 0.800, 0.000);
                c7 = vec3(0.400, 1.000, 1.000);
                c8 = vec3(1.000, 0.400, 1.000);
            } else if (pIdx == 30) {
                c1 = vec3(0.000, 0.800, 0.600);
                c2 = vec3(1.000, 0.400, 0.200);
                c3 = vec3(0.400, 0.200, 1.000);
                c4 = vec3(0.000, 1.000, 0.800);
                c5 = vec3(1.000, 0.600, 0.400);
                c6 = vec3(0.600, 0.400, 1.000);
                c7 = vec3(0.200, 0.600, 0.400);
                c8 = vec3(0.800, 0.200, 0.000);
            } else if (pIdx == 31) {
                c1 = vec3(0.600, 1.000, 0.000);
                c2 = vec3(0.400, 0.000, 1.000);
                c3 = vec3(1.000, 0.400, 0.000);
                c4 = vec3(0.800, 1.000, 0.200);
                c5 = vec3(0.600, 0.200, 1.000);
                c6 = vec3(1.000, 0.600, 0.200);
                c7 = vec3(0.400, 0.800, 0.000);
                c8 = vec3(0.200, 0.000, 0.800);
            } else if (pIdx == 32) {
                c1 = vec3(0.000, 0.600, 0.600);
                c2 = vec3(0.600, 0.000, 0.800);
                c3 = vec3(1.000, 0.800, 0.000);
                c4 = vec3(0.200, 0.800, 0.800);
                c5 = vec3(0.800, 0.200, 1.000);
                c6 = vec3(1.000, 1.000, 0.200);
                c7 = vec3(0.000, 0.400, 0.400);
                c8 = vec3(0.400, 0.000, 0.600);
            }

            vec3 color1, color2;
            if (segment == 0) { color1 = c1; color2 = c2; }
            else if (segment == 1) { color1 = c2; color2 = c3; }
            else if (segment == 2) { color1 = c3; color2 = c4; }
            else if (segment == 3) { color1 = c4; color2 = c5; }
            else if (segment == 4) { color1 = c5; color2 = c6; }
            else if (segment == 5) { color1 = c6; color2 = c7; }
            else { color1 = c7; color2 = c8; }
            
            return mix(color1, color2, smoothstep(0.1, 0.9, frac));
        }

        vec3 enhanceColor(vec3 color, float noiseValue) {
            const vec3 luminanceWeights = vec3(0.2126, 0.7152, 0.0722);
            float luminance = dot(color, luminanceWeights);
            
            float noiseInfluence = 1.0 + noiseValue * 0.1;
            vec3 boosted = color * (1.0 + (1.0 - luminance) * 1.5 * noiseInfluence);
            
            vec3 saturated = mix(
                vec3(luminance),
                boosted,
                vec3(5.0)
            );
            
            vec3 contrasted = pow(saturated, vec3(0.9));
            
            float highlightThreshold = 0.85;
            vec3 highlights = smoothstep(highlightThreshold, 1.0, contrasted);
            contrasted = mix(contrasted, highlights * 0.8, 0.2);
            
            return contrasted * 0.85;
        }

        vec3 blendColors(vec3 a, vec3 b, float factor) {
            float rotationInfluence = (1.0 + sin(u_rotationAngle + u_time * 0.1)) * 0.5;
            vec3 screen = 1.0 - (1.0 - a) * (1.0 - b * factor * 1.2);
            vec3 add = a + b * factor * 0.5;
            
            return mix(screen, add, 2.5 + rotationInfluence);
        }

        void main() {
            vec2 coord = (vTexCoord * u_resolution - u_resolution * 0.25) * u_scaleFactor + u_translation;
            coord = coord / u_baseScale;
            
            vec2 gridCoord = floor(coord / u_cellSize);
            vec2 cellCenter = gridCoord * u_cellSize + u_cellSize * 0.5;
            
            float timeScale = u_time * 0.1;
            vec2 baseNoiseCoord = gridCoord * 0.1;
            vec2 timeOffset = vec2(timeScale, timeScale + 100.0);
            
            float baseNoiseFBM = fbmSimplexNoise(gridCoord * 0.05, 4);

            vec2 noiseOffset = vec2(
                noise(baseNoiseCoord + timeOffset.xx, u_noiseSeed),
                noise(baseNoiseCoord + timeOffset.yy, u_noiseSeed)
            );
            
            float gridSize = u_cellSize * mix(0.3, 2.5, baseNoiseFBM);
            vec2 localCoord = mod(coord + noiseOffset, gridSize);
            
            float randomAngle = floor(noise(gridCoord + noiseOffset, u_noiseSeed) * 4.0) * (M_PI * 0.5);
            mat2 rotationMatrix = getRotationMatrix(randomAngle);
            vec2 rotatedCoord = rotationMatrix * localCoord;
            
            float smoothedTime = u_time * 0.01 + sin(u_time * 0.005) * 0.005;
            
            vec2 noiseInput1 = rotatedCoord * 0.1 + smoothedTime;
            vec2 noiseInput2 = (rotatedCoord + gridCoord * gridSize) * u_noiseScale;
            
            float flowNoise = fbmSimplexNoise(noiseInput1, 6);
            vec2 animatedCoord = noiseInput2 + vec2(
                cos(flowNoise * 6.28318), 
                sin(flowNoise * 6.28318)
            ) * u_flowSpeed * 0.005;
            
            float curlNoise = fbmSimplexNoise(animatedCoord * 1.5 + vec2(u_noiseSeed), 8);
            animatedCoord += 4.0 * vec2(
                cos(curlNoise * 6.28318),
                sin(curlNoise * 6.28318)
            );
            float baseNoise = fbmSimplexNoise(animatedCoord + noiseOffset, 5);
            
            vec4 color = vec4(0.0);
            const int MAX_LOOP_DEPTH = 8;
            float combinedNoise = (baseNoise * 0.3 + baseNoiseFBM * 0.7 + 1.0) * 0.3;
            
            float clampedNoise = clamp(combinedNoise, 0.0, 1.0);
            int dynamicDepth = int(clamp(
                clampedNoise * float(u_maxDepth),
                1.0,
                min(float(u_maxDepth), float(MAX_LOOP_DEPTH))
            ));
            
            float t = 0.5 + 0.5 * sin(u_time * 2.0 * u_flowSpeed);
            float angleInfluence = sin(u_rotationAngle * 0.1 + u_time * 0.2) * 0.5 + 0.5;
            float blendFactor = t * t * (3.0 - 2.0 * t) * (1.0 + combinedNoise * 0.6 + angleInfluence);
            
            int paletteIndex1 = int(u_paletteIndex1);
            int paletteIndex2 = int(u_paletteIndex2);
            
            for (int depth = 0; depth < MAX_LOOP_DEPTH; depth++) {
                if (depth >= dynamicDepth) break;
                
                float depthNoiseValue = noise(animatedCoord * float(depth + 1), u_noiseSeed);
                
                float threshold = 0.6 + combinedNoise * 0.6;
                if (depthNoiseValue > threshold) {
                    float size = gridSize / max(exp2(float(depth)), 0.0001);
                    vec2 cellCoord = mod(coord, size);
                    
                    
                    float depthFactor = float(depth) / float(MAX_LOOP_DEPTH);
                    float circleSize = mix(0.45, 0.05, depthFactor);  
                    
                    
                    float distToCenter = length(coord - cellCenter);
                    if (distToCenter > u_cellSize * circleSize) {
                        continue;  
                    }
                    
                    if (cellCoord.x < size * 0.5 && cellCoord.y < size * 0.5) {
                        float edge0 = 0.2 + sin(u_time * 0.05) * 0.2;
                        float edge1 = 0.8 + cos(u_time * 0.05) * 0.2;
                        float colorT = smoothstep(edge0, edge1, depthFactor + combinedNoise * 0.6);

                        vec3 color1 = getColorFromPalette(paletteIndex1, colorT);
                        vec3 color2 = getColorFromPalette(paletteIndex2, 1.0 - colorT);

                        float depthBoost = 1.0 + (1.0 - depthFactor) * 0.5;
                        color1 *= depthBoost;
                        color2 *= depthBoost;
                        
                        vec3 enhancedColor1 = enhanceColor(color1, combinedNoise);
                        vec3 enhancedColor2 = enhanceColor(color2, combinedNoise);
                        
                        vec3 blendedColor = blendColors(enhancedColor1, enhancedColor2, blendFactor);
                        
                        color.rgb *= 1.0;
                        color += vec4(blendedColor, 1.0) * (1.0 - depthNoiseValue * 0.5);
                    }
                }
            }
            
            if (color.a == 0.0) {
                color = vec4(0.0, 0.0, 0.0, 1.0);
            }
            
            gl_FragColor = color;
        }
    </script>

    <script>
        const BASE_HEIGHT = 900; // Reference height for 100% scale
        let baseScale = 1.0;     // Will be updated based on canvas height
        let theShader;
        let displayMode = 0;
        let cellSize = 100;      // Base cell size that will be scaled
        let noiseScale = 0.0001;
        let maxDepth;
        let noiseSeed;
        let flowSpeed = 0.005;
        let paletteIndex1, paletteIndex2;
        let randomScaleSeed;
        let rotationAngle;
        let noiseOffsetX, noiseOffsetY;
        let scaleFactor = 30;
        let translateX = 0, translateY = 0;
        let initialTranslateX = 0, initialTranslateY = 0;
        let previousMouseX, previousMouseY;
        let amplitudeValues = [0.05, 0.075, 0.1];
        let isPlaying = true;
        let startTime = 0;
        let currentTime = 0;
        let pauseStartTime = 0;  // Track when pause started
        let totalPausedTime = 0; // Track total paused time
        let luminosity = 2.5;
        let vibrancy = 7.5;
        let targetFrameRate = 30;  // Minimum acceptable FPS
        let fpsHistory = [];
        let fpsHistoryLength = 30;  // Number of frames to average
        let currentPixelDensity = 2;  // Start with your current pixel density
        let lastAdjustTime = 0;
        let adjustCooldown = 1000;  // Wait 1 second between adjustments

        let inscription_id = window.location.pathname.split("/").pop();
        
        // REMOVE AFTER TESTING!!!
            let chars = "0123456789abcdefghijklmnopqrstuvwsyz";
            inscription_id = new URLSearchParams(window.location.search).get("seed") || Array(64).fill(0).map(_=>chars[(Math.random()*chars.length)|0]).join('');
        // REMOVE AFTER TESTING!!!

        // BUGGY SEEDS - for you to test :)

        // kftyk5iyj23pt7y3g3wib9vc4ebqs3pmsszbz1ehibedey2lgfe0pqu0m1078re5
        // q6vlo1umitq2d5ugtlvc1h0j78gvqwr1yp689jzbq3i6h1cl4y6iigfqdh7skt3i
        // 9d7fq3qtqgpuvsdo384maqs8q2ydai2nrg8ik8sdtw5ypa7selz3y3y1q2no2gio
        // d22y74bs6dlq3o23d4zl2cjkge8rqsewu2nh393b7ds87ts5wvla50hrhln99lbf
        // wraa45m0mfd2to4l1gfer4h2nawueqsf4ynjyoby8hdya62zamvbhzsir45hstot

        // Class to use inscription ID hash as a PRNG (PseudoRandom Number Generator).
        // Helpful with vanilla JS.
        // Can be replaced or removed if you use another PRNG.
        class Rnd{
            constructor(seed) {
                const i=Math.imul,h=t=>{let e,l=0;for(e=1779033703^t.length;l<t.length;l++){let h=e^t.charCodeAt(l);e=i(h,3432918353),e=e<<13|e>>>19}return()=>(e=i(e^e>>>16,2246822507),e=i(e^e>>>13,3266489909),(e^=e>>>16)>>>0)},a=(e,r,t,a)=>()=>{let l=((e|=0)+(r|=0)|0)+(a|=0)|0;return a=a+1|0,e=r^r>>>9,r=(t|=0)+(t<<3)|0,t=(t=t<<21|t>>>11)+l|0,(l>>>0)/4294967296},X=h(seed);this.R=a(X(),X());
            }
            D=_=>this.R();                  // returns a random value in range <0, 1)
            N=(r,t)=>r+(t-r)*this.D();      // returns a random number in range <r, t)
            I=(r,t)=>0|this.N(r,t+1);       // returns a random integer in range <r, t>
            B=r=>this.D()<r                 // returns true if lower than r
        };
        let R = new Rnd(inscription_id)

        console.log('Inscription ID:', inscription_id)

        function updateTranslationForCenter() {
            let visibleWidth = width / scaleFactor;
            let visibleHeight = height / scaleFactor;
            
            translateX = -width/2 + (visibleWidth * scaleFactor/2);
            translateY = -height/2 + (visibleHeight * scaleFactor/2);
        }

        function preload() {
            let vertexShader = document.getElementById('vertex-shader').textContent;
            let fragmentShader = document.getElementById('fragment-shader').textContent;
            theShader = createShader(vertexShader, fragmentShader);
            console.log("Shader created:", theShader);
        }

        function setup() {
            console.log("Starting setup...");
            
            console.log("inscription_id:", inscription_id);
            
            if (!inscription_id) {
                console.error("Could not retrieve inscription ID");
                return;
            }
            
            createCanvas(windowWidth, windowHeight, WEBGL);
            noStroke();
            shader(theShader);
            pixelDensity(2);
            
            updateCanvasSize();
            
            noiseOffsetX = R.I(0,2000)
            noiseOffsetY = R.I(0,2000)

            let shiftX = -width/2;
            let shiftY = -height/2;
            initialTranslateX = shiftX;
            initialTranslateY = shiftY;
            translateX = shiftX;
            translateY = shiftY;

            noiseSeed = R.I(0,1000)

            let u_maxDepth = 100 + R.I(0,101)

            paletteIndex1 = R.I(0,32)
            paletteIndex2 = R.I(0,32)

            randomScaleSeed = R.I(0,1000)

            rotationAngle = R.I(0, 360)
            
            let tempRand = R.I(0, amplitudeValues.length - 1);
            let randomAmplitude = amplitudeValues[ tempRand];

            let initialFreqOptions = [0.00005, 0.0005, 0.005];
            let selectedFreq = initialFreqOptions[ R.I(0,2) ];

            theShader.setUniform('u_paletteIndex1', paletteIndex1);
            theShader.setUniform('u_paletteIndex2', paletteIndex2);
            theShader.setUniform('u_noiseSeed', noiseSeed);
            theShader.setUniform('u_randomScaleSeed', randomScaleSeed);
            theShader.setUniform('u_rotationAngle', radians(rotationAngle));
            theShader.setUniform('u_noiseOffset', [noiseOffsetX, noiseOffsetY]);
            theShader.setUniform('u_amplitude', randomAmplitude);
            theShader.setUniform('u_maxDepth', u_maxDepth);
            theShader.setUniform('u_backgroundColor', [0.0, 0.0, 0.0, 1.0]);
            theShader.setUniform('u_luminosity', luminosity);
            theShader.setUniform('u_vibrancy', vibrancy);
            theShader.setUniform('u_initialFreq', selectedFreq);

            scaleFactor = 30;
            updateTranslationForCenter();

            document.addEventListener('keydown', (e) => {
                if (e.key === 'a' || e.key === 'A') {
                    displayMode = (displayMode + 1) % 3;
                    updateCanvasSize();
                    console.log('Display mode:', ['fullscreen', '16:9', '9:16'][displayMode]);
                }
                if (e.key === 'r' || e.key === 'R') {
                    updateTranslationForCenter();
                    scaleFactor = 30;
                    console.log('Position reset');
                }
                if (e.key === 's' || e.key === 'S') {
                    isPlaying = !isPlaying;
                    if (isPlaying) {
                        startTime = millis() - currentTime * 1000;
                    } else {
                        currentTime = (millis() - startTime) / 1000.0;
                    }
                    console.log('Animation ' + (isPlaying ? 'playing' : 'paused'));
                }
                if (e.key === '1') {
                    let currentDensity = pixelDensity();
                    
                    pixelDensity(4);
                    
                    draw();
                    
                    let timestamp = year() + nf(month(), 2) + nf(day(), 2) + '_' + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);
                    saveCanvas('shader_' + timestamp, 'png');
                    
                    pixelDensity(currentDensity);
                    
                    draw();
                    
                    console.log('Canvas saved as shader_' + timestamp + '.png');
                }
                if (e.key === '2') {
                    let currentDensity = pixelDensity();
                    
                    pixelDensity(5);
                    
                    draw();
                    
                    let timestamp = year() + nf(month(), 2) + nf(day(), 2) + '_' + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);
                    saveCanvas('shader_hires_' + timestamp, 'png');
                    
                    pixelDensity(currentDensity);
                    
                    draw();
                    
                    console.log('High-res canvas saved as shader_hires_' + timestamp + '.png');
                }
                if (e.key === '3') {
                    let currentDensity = pixelDensity();
                    
                    pixelDensity(5.5);
                    
                    draw();
                    
                    let timestamp = year() + nf(month(), 2) + nf(day(), 2) + '_' + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);
                    saveCanvas('shader_hires_' + timestamp, 'png');
                    
                    pixelDensity(currentDensity);
                    
                    draw();
                    
                    console.log('Very high-res canvas saved as shader_hires_' + timestamp + '.png');
                }
                if (e.key === 'd' || e.key === 'D') {
                    if (scaleFactor === 30) scaleFactor = 10;
                    else scaleFactor = 30;
                    updateTranslationForCenter();
                    console.log('Scale factor:', scaleFactor);
                }
            });
            startTime = millis();

            // Set initial pixel density based on device
            if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
                currentPixelDensity = 1;  // Start lower on mobile devices
                targetFrameRate = 30;     // Lower target FPS for mobile
            } else {
                currentPixelDensity = 2;  // Start higher on desktop
                targetFrameRate = 45;     // Higher target FPS for desktop
            }
            pixelDensity(currentPixelDensity);
        }

        function calculateAverageFPS() {
            if (fpsHistory.length === 0) return 0;
            return fpsHistory.reduce((a, b) => a + b) / fpsHistory.length;
        }

        function draw() {
            // Update timing
            let now = millis();
            
            if (isPlaying) {
                currentTime = (now - startTime - totalPausedTime) / 1000.0;
                
                // Only calculate FPS and adjust resolution when playing
                let currentFPS = frameRate();
                fpsHistory.push(currentFPS);
                if (fpsHistory.length > fpsHistoryLength) {
                    fpsHistory.shift();
                }

                // Performance check
                if (now - lastAdjustTime > adjustCooldown) {
                    let avgFPS = calculateAverageFPS();
                    // ... resolution adjustment code ...
                    lastAdjustTime = now;
                }
            }

            console.log("Draw called, canvas size:", width, height);
            clear();
            background(0);
            
            if (isPlaying) {
                currentTime = (now - startTime - totalPausedTime) / 1000.0;
            }

            if (mouseIsPressed && mouseButton === LEFT) {
                if (previousMouseX !== undefined && previousMouseY !== undefined) {
                    let deltaX = mouseX - previousMouseX;
                    let deltaY = mouseY - previousMouseY;
                    translateX -= deltaX;
                    translateY += deltaY;
                }
                previousMouseX = mouseX;
                previousMouseY = mouseY;
            } else {
                previousMouseX = undefined;
                previousMouseY = undefined;
            }

            let scaledTime = currentTime;

            theShader.setUniform('u_baseScale', baseScale);
            theShader.setUniform('u_scaleFactor', scaleFactor);
            theShader.setUniform('u_translation', [translateX, translateY]);
            theShader.setUniform('u_resolution', [width, height]);
            theShader.setUniform('u_time', scaledTime);
            theShader.setUniform('u_cellSize', cellSize * baseScale);
            theShader.setUniform('u_noiseScale', noiseScale);
            theShader.setUniform('u_flowSpeed', flowSpeed);
            theShader.setUniform('u_backgroundColor', [0.0, 0.0, 0.0, 1.0]);
            theShader.setUniform('u_luminosity', luminosity);
            theShader.setUniform('u_vibrancy', vibrancy);

            beginShape();
            vertex(0, 0, 0, 0, 0);
            vertex(2, 0, 0, 1, 0);
            vertex(2, 2, 0, 1, 1);
            vertex(0, 2, 0, 0, 1);
            endShape(CLOSE);
        }

        function updateBaseScale() {
            let rawScale = height / BASE_HEIGHT;
            // Dampen scale changes when canvas is smaller than base height
            if (rawScale < 1) {
                // Make scaling even less aggressive by using 0.5 instead of 0.7
                baseScale = 1 - ((1 - rawScale) * 0.5);  // Changed from 0.7 to 0.5
            } else {
                baseScale = rawScale;
            }
            return baseScale;
        }

        function getScaledValue(baseValue) {
            return baseValue * baseScale;
        }

        function updateCanvasSize() {
            let newWidth, newHeight;
            
            switch(displayMode) {
                case 0:
                    resizeCanvas(windowWidth, windowHeight);
                    break;
                
                case 1:
                    if (windowWidth < windowHeight) {
                        newWidth = windowWidth;
                        newHeight = windowWidth;
                    } else {
                        newHeight = windowHeight;
                        newWidth = windowHeight;
                    }
                    resizeCanvas(newWidth, newHeight);
                    break;
                
                case 2:
                    if (windowWidth / windowHeight > 2/3) {
                        newHeight = windowHeight;
                        newWidth = (windowHeight * 2) / 3;
                    } else {
                        newWidth = windowWidth;
                        newHeight = (windowWidth * 3) / 2;
                    }
                    resizeCanvas(newWidth, newHeight);
                    break;
            }
            
            updateBaseScale();
            updateTranslationForCenter();
            
            let canvas = document.querySelector('canvas');
            canvas.style.position = 'absolute';
            canvas.style.left = '50%';
            canvas.style.top = '50%';
            canvas.style.transform = 'translate(-50%, -50%)';
        }

        function windowResized() {
            updateCanvasSize();
        }

        function drawPerformanceStats() {
            let avgFPS = calculateAverageFPS();
            push();
            noStroke();
            fill(255);
            textSize(12);
            text(`FPS: ${avgFPS.toFixed(1)} | Resolution: ${currentPixelDensity.toFixed(2)}x`, 10, 20);
            pop();
        }
    </script>
  </body>
</html>
