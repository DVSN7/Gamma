<!DOCTYPE html>
<html>
  <head>
    <title>Shader Art</title>
    <script src="https://ordinals.com/content/7e37766541506810ba6399c4b2735121f508bd9209df43dd200bf2316b014594i0"></script>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000;
        }
        canvas {
            width: 100% !important;
            height: 100% !important;
            object-fit: contain !important;
            max-width: 100vw;
            max-height: 100vh;
        }
        main {
            display: flex;
            justify-content: center;
            width: 100%;
            align-items: center;
            height: 100%;
        }
    </style>
  </head>
  <body>
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec3 aPosition;
        attribute vec2 aTexCoord;
        varying vec2 vTexCoord;

        void main() {
            vTexCoord = aTexCoord;
            vec4 positionVec4 = vec4(aPosition, 1.0);
            positionVec4.xy = positionVec4.xy * 2.0 - 1.0;
            gl_Position = positionVec4;
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        #endif

        #define M_PI 3.14159265358979323846

        varying vec2 vTexCoord;
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float u_cellSize;
        uniform float u_noiseScale;
        uniform float u_maxDepth;
        uniform float u_flowSpeed;
        uniform int u_paletteIndex1;
        uniform int u_paletteIndex2;
        uniform float u_noiseSeed;
        uniform float u_randomScaleSeed;
        uniform float u_rotationAngle;
        uniform vec2 u_noiseOffset;
        uniform float u_amplitude;
        uniform float u_scaleFactor;
        uniform vec2 u_translation;
        uniform vec4 u_backgroundColor;
        uniform float u_luminosity;
        uniform float u_vibrancy;
        uniform float u_initialFreq;
        uniform float u_baseScale;

        float noise(vec2 st, float seed) {
            // Pre-calculate floor and fract in one step
            vec2 i = floor(st);
            vec2 f = st - i;  // More efficient than fract(st)
            
            // Combine seed with coordinates
            vec2 seeded = st.xy + seed;
            
            // Cubic interpolation for smoother result
            vec2 u = f * f * (3.0 - 2.0 * f);  // No change needed, already efficient
            
            // Combine dot products for random values
            vec2 s = vec2(12.9898, 78.233);
            float a = fract(sin(dot(i, s) + seed));
            float b = fract(sin(dot(i + vec2(1.0, 0.0), s) + seed));
            float c = fract(sin(dot(i + vec2(0.0, 1.0), s) + seed));
            float d = fract(sin(dot(i + vec2(1.0, 1.0), s) + seed));
            
            // Single mix operation
            return mix(
                mix(a, b, u.x),
                mix(c, d, u.x),
                u.y
            );
        }

        vec3 mod289(vec3 x) { 
            return x - floor(x / 289.0) * 289.0; 
        }

        vec2 mod289(vec2 x) { 
            return x - floor(x / 289.0) * 289.0; 
        }

        vec3 permute(vec3 x) { 
            return mod289((x * 34.0 + 1.0) * x); 
        }

        float simplexNoise(vec2 v, float time) {
            const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
            
            // Combine time addition with input
            v += vec2(time * 0.03);
            
            // Pre-calculate dot products used multiple times
            float dotv = dot(v, C.yy);
            vec2 i = floor(v + dotv);
            vec2 x0 = v - i + dot(i, C.xx);
            
            // Simplify i1 calculation
            vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
            
            // Combine x12 calculations
            vec4 x12 = x0.xyxy + C.xxzz;
            x12.xy -= i1;
            
            i = mod289(i);
            vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
            
            // Pre-calculate dot products for m
            vec3 dots = vec3(
                dot(x0, x0),
                dot(vec2(x12.x, x12.y), vec2(x12.x, x12.y)),
                dot(vec2(x12.z, x12.w), vec2(x12.z, x12.w))
            );
            vec3 m = max(0.5 - dots, 0.0);
            m = m * m * m * m;
            
            // Rest of the function remains the same
            vec3 x = 2.0 * fract(p * C.www) - 1.0;
            vec3 h = abs(x) - 0.5;
            vec3 ox = floor(x + 0.5);
            vec3 a0 = x - ox;
            
            m *= 1.792842914 - 0.853734721 * (a0 * a0 + h * h);
            
            vec3 g = vec3(
                a0.x * x0.x + h.x * x0.y,
                a0.y * x12.x + h.y * x12.y,
                a0.z * x12.z + h.z * x12.w
            );
            
            return 130.0 * dot(m, g);
        }

        vec2 domainWarp(vec2 p, float time) {
            float distortion1 = simplexNoise(p * 0.3 + time * 0.001, time * 0.001);
            float distortion2 = simplexNoise((p + vec2(5.2, 1.3)) * 0.2 - time * 0.0015, time * 0.001);
            
            return p + vec2(
                distortion1 * 2.0 + sin(time * 0.1) * 0.5,
                distortion2 * 2.0 + cos(time * 0.05) * 0.5
            );
        }

        float layeredNoise(vec2 p, float time) {
            // Pre-calculate warped coordinates once
            vec2 warped = domainWarp(p, time);
            
            // Calculate all noise values with single warped coordinate
            float mainLayer = simplexNoise(warped, time);
            float detail = simplexNoise(warped + mainLayer * 0.5, time * 0.3) * 0.5;  // Simplified multiplication
            float background = simplexNoise(p * 0.1, time) * 0.3;  // Reduced coordinate scaling
            
            // Combine layers with single operation
            return dot(vec3(mainLayer, detail, background), vec3(0.6, 0.3, 0.1));  // Use dot product instead of multiple adds
        }

        float fbmSimplexNoise(vec2 v, int octaves) {
            if (octaves <= 0) return 0.0;
            
            v += u_noiseOffset;
            v += vec2(u_noiseSeed);
            
            const float PERSISTENCE = 0.15;
            const float LACUNARITY = 0.04;
            float INITIAL_FREQ = u_initialFreq;
            
            float total = 0.0;
            float amplitude = u_amplitude;
            float frequency = INITIAL_FREQ;
            
            vec2 warpedCoord = domainWarp(v, u_time * 0.1);
            float basePattern = layeredNoise(warpedCoord, u_time);
            
            total = amplitude * basePattern;
            
            for(int i = 1; i < 3; i++) {
                amplitude *= PERSISTENCE * (1.0 + float(i) * 0.3);
                frequency *= LACUNARITY * (1.0 + sin(u_time * 0.1) * 0.2);
                
                float angle = float(i) * 0.8 + u_time * 0.05;
                mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
                vec2 rotated = rot * warpedCoord;
                
                total += amplitude * layeredNoise(rotated * frequency, u_time * 0.9);
            }
            
            float modulation = sin(u_time * 0.1) * 0.2 + 0.9;
            total *= modulation;
            
            return total;
        }

        mat2 getRotationMatrix(float angle) {
            float c = cos(angle);
            float s = sin(angle);
            return mat2(c, -s, s, c);
        }

        vec3 getColorFromPalette(int pIdx, float t) {
            t = clamp(t, 0.0, 4.0) * 7.0;
            int segment = int(t);
            float frac = t - float(segment);
            
            vec3 c1, c2, c3, c4, c5, c6, c7, c8;
            
            if (pIdx == 0) {
                c1 = vec3(0.945, 0.165, 0.000);  // #f12a00 - Bright red
                c2 = vec3(0.843, 0.145, 0.000);  // #d72500 - Deep red
                c3 = vec3(0.745, 0.129, 0.000);  // #be2100 - Dark red
                c4 = vec3(0.647, 0.110, 0.000);  // #a51c00 - Very dark red
                c5 = vec3(0.561, 0.184, 0.043);  // #8f2f0b - Burnt red
                c6 = vec3(0.867, 0.545, 0.059);  // #dd8b0f - Orange
                c7 = vec3(0.137, 0.820, 0.216);  // #23d137 - Bright green
                c8 = vec3(0.220, 0.400, 0.188);  // #386630 - Forest green
            } else if (pIdx == 1) {
                // Neon red palette
                c1 = vec3(1.000, 0.000, 0.000);  // Pure red
                c2 = vec3(1.000, 0.200, 0.000);  // Hot red
                c3 = vec3(1.000, 0.000, 0.200);  // Neon red-pink
                c4 = vec3(1.000, 0.300, 0.000);  // Electric orange-red
                c5 = vec3(1.000, 0.000, 0.300);  // Bright pink-red
                c6 = vec3(1.000, 0.150, 0.000);  // Glowing red
                c7 = vec3(1.000, 0.000, 0.150);  // Radiant red
                c8 = vec3(1.000, 0.100, 0.100);  // Neon rose
            } else if (pIdx == 2) {
                // Red with complementary cyan
                c1 = vec3(0.800, 0.100, 0.100);  // Medium red
                c2 = vec3(0.000, 0.700, 0.800);  // Cyan (complement)
                c3 = vec3(0.900, 0.200, 0.200);  // Bright red
                c4 = vec3(0.000, 0.800, 0.900);  // Light cyan (complement)
                c5 = vec3(0.700, 0.000, 0.000);  // Deep red
                c6 = vec3(0.000, 0.700, 0.700);  // Dark cyan (complement)
                c7 = vec3(1.000, 0.300, 0.300);  // Light red
                c8 = vec3(0.600, 0.000, 0.000);  // Darkest red
            } else if (pIdx == 3) {
                // Red with analogous oranges and magentas
                c1 = vec3(0.900, 0.100, 0.100);  // Pure red
                c2 = vec3(0.900, 0.400, 0.100);  // Orange-red
                c3 = vec3(0.900, 0.100, 0.400);  // Magenta-red
                c4 = vec3(0.500, 0.500, 0.000);  // Bright orange
                c5 = vec3(1.000, 0.000, 0.500);  // Bright magenta
                c6 = vec3(0.800, 0.300, 0.000);  // Dark orange-red
                c7 = vec3(0.800, 0.000, 0.300);  // Dark magenta-red
                c8 = vec3(0.700, 0.100, 0.100);  // Deep red
            } else if (pIdx == 4) {
                // Yellow to red gradient
                c1 = vec3(0.965, 0.925, 0.376);  // #f6ec60 - Light yellow
                c2 = vec3(0.976, 0.839, 0.306);  // #f9d64e - Golden yellow
                c3 = vec3(0.976, 0.784, 0.306);  // #f9c84e - Deep yellow
                c4 = vec3(0.976, 0.659, 0.141);  // #f9a824 - Yellow-orange
                c5 = vec3(0.976, 0.659, 0.141);  // #f9a824 - Yellow-orange
                c6 = vec3(0.957, 0.498, 0.122);  // #f47f1f - Orange
                c7 = vec3(0.957, 0.498, 0.122);  // #f47f1f - Orange
                c8 = vec3(0.827, 0.192, 0.192);  // #d33131 - Red
            } else if (pIdx == 5) {
                // Yellow to blue gradient
                c1 = vec3(0.965, 0.925, 0.376);  // #f6ec60 - Bright yellow
                c2 = vec3(0.965, 0.820, 0.173);  // #f6d12c - Golden yellow
                c3 = vec3(0.961, 0.706, 0.000);  // #f5b400 - Deep yellow
                c4 = vec3(0.961, 0.639, 0.000);  // #f5a300 - Orange yellow
                c5 = vec3(0.659, 0.792, 0.941);  // #a8caf0 - Light blue
                c6 = vec3(0.420, 0.612, 0.820);  // #6b9cd1 - Medium blue
                c7 = vec3(0.231, 0.420, 0.608);  // #3b6b9b - Deep blue
                c8 = vec3(0.169, 0.298, 0.490);  // #2b4c7d - Dark blue
            } else if (pIdx == 6) {
                // Golden yellow with purple complements
                c1 = vec3(0.800, 0.600, 0.000);  // Deep gold
                c2 = vec3(0.500, 0.100, 0.900);  // Purple (complement)
                c3 = vec3(0.900, 0.700, 0.000);  // Rich gold
                c4 = vec3(0.600, 0.200, 1.000);  // Light purple (complement)
                c5 = vec3(1.000, 0.800, 0.000);  // Bright gold
                c6 = vec3(0.400, 0.000, 0.800);  // Dark purple (complement)
                c7 = vec3(1.000, 0.850, 0.200);  // Light gold
                c8 = vec3(0.700, 0.500, 0.000);  // Dark amber
            } else if (pIdx == 7) {
                // Yellow to orange gradient
                c1 = vec3(1.000, 0.918, 0.000);  // #ffea00 - Bright yellow
                c2 = vec3(1.000, 0.835, 0.000);  // #ffd500 - Golden yellow
                c3 = vec3(1.000, 0.765, 0.000);  // #ffc300 - Deep yellow
                c4 = vec3(1.000, 0.718, 0.000);  // #ffb700 - Yellow-orange
                c5 = vec3(1.000, 0.616, 0.000);  // #ff9d00 - Light orange
                c6 = vec3(1.000, 0.549, 0.000);  // #ff8c00 - Orange
                c7 = vec3(1.000, 0.502, 0.000);  // #ff8000 - Deep orange
                c8 = vec3(1.000, 0.431, 0.000);  // #ff6e00 - Burnt orange
            } else if (pIdx == 8) {
                // Muted purple palette
                c1 = vec3(0.400, 0.300, 0.450);  // Dusty purple
                c2 = vec3(0.500, 0.400, 0.550);  // Muted lavender
                c3 = vec3(0.350, 0.250, 0.400);  // Deep muted purple
                c4 = vec3(0.600, 0.500, 0.650);  // Soft mauve
                c5 = vec3(0.300, 0.200, 0.350);  // Dark muted purple
                c6 = vec3(0.450, 0.350, 0.500);  // Medium dusty purple
                c7 = vec3(0.550, 0.450, 0.600);  // Light mauve
                c8 = vec3(0.250, 0.150, 0.300);  // Darkest muted purple
            } else if (pIdx == 9) {
                // Turquoise to purple gradient
                c1 = vec3(0.455, 0.910, 0.824);  // #74e8d2 - Turquoise
                c2 = vec3(0.776, 0.373, 0.271);  // #c65f45 - Coral red
                c3 = vec3(0.847, 0.051, 0.302);  // #d80d4d - Deep pink
                c4 = vec3(0.824, 0.208, 0.541);  // #d2358a - Rose pink
                c5 = vec3(0.804, 0.263, 0.761);  // #cd43c2 - Magenta
                c6 = vec3(0.784, 0.275, 0.976);  // #c846f9 - Bright purple
                c7 = vec3(0.847, 0.459, 0.996);  // #d875fe - Light purple
                c8 = vec3(0.910, 0.616, 0.996);  // #e89dfe - Pale purple
            } else if (pIdx == 10) {
                // Purple with complementary yellow
                c1 = vec3(0.500, 0.100, 0.700);  // Medium purple
                c2 = vec3(0.900, 0.800, 0.000);  // Golden yellow (complement)
                c3 = vec3(0.600, 0.200, 0.800);  // Bright purple
                c4 = vec3(1.000, 0.900, 0.200);  // Light yellow (complement)
                c5 = vec3(0.400, 0.000, 0.600);  // Deep purple
                c6 = vec3(0.800, 0.700, 0.000);  // Dark yellow (complement)
                c7 = vec3(0.700, 0.300, 0.900);  // Light purple
                c8 = vec3(0.300, 0.000, 0.500);  // Darkest purple
            } else if (pIdx == 11) {
                // Purple with analogous blues and magentas
                c1 = vec3(0.500, 0.100, 0.700);  // Medium purple
                c2 = vec3(0.300, 0.100, 0.800);  // Blue-purple
                c3 = vec3(0.700, 0.100, 0.600);  // Magenta-purple
                c4 = vec3(0.400, 0.050, 0.900);  // Deep blue-purple
                c5 = vec3(0.800, 0.100, 0.500);  // Pink-purple
                c6 = vec3(0.200, 0.050, 0.700);  // Dark blue-purple
                c7 = vec3(0.900, 0.200, 0.600);  // Bright magenta-purple
                c8 = vec3(0.600, 0.150, 0.800);  // Rich purple
            } else if (pIdx == 12) {
                // Muted blue palette
                c1 = vec3(0.300, 0.350, 0.450);  // Dusty blue
                c2 = vec3(0.400, 0.450, 0.550);  // Muted steel blue
                c3 = vec3(0.250, 0.300, 0.400);  // Deep muted blue
                c4 = vec3(0.500, 0.550, 0.650);  // Soft slate blue
                c5 = vec3(0.200, 0.250, 0.350);  // Dark muted blue
                c6 = vec3(0.350, 0.400, 0.500);  // Medium dusty blue
                c7 = vec3(0.450, 0.500, 0.600);  // Light slate
                c8 = vec3(0.150, 0.200, 0.300);  // Darkest muted blue
            } else if (pIdx == 13) {
                // Neon blue palette
                c1 = vec3(0.000, 0.400, 1.000);  // Electric blue
                c2 = vec3(0.000, 0.800, 1.000);  // Bright cyan
                c3 = vec3(0.200, 0.600, 1.000);  // Neon sky blue
                c4 = vec3(0.000, 1.000, 1.000);  // Pure cyan
                c5 = vec3(0.000, 0.200, 1.000);  // Deep electric blue
                c6 = vec3(0.400, 0.800, 1.000);  // Glowing light blue
                c7 = vec3(0.000, 0.600, 1.000);  // Bright azure
                c8 = vec3(0.200, 1.000, 1.000);  // Luminous cyan
            } else if (pIdx == 14) {
                // Blue with complementary orange
                c1 = vec3(0.100, 0.300, 0.800);  // Medium blue
                c2 = vec3(1.000, 0.500, 0.000);  // Orange (complement)
                c3 = vec3(0.200, 0.400, 0.900);  // Bright blue
                c4 = vec3(1.000, 0.600, 0.200);  // Light orange (complement)
                c5 = vec3(0.000, 0.200, 0.700);  // Deep blue
                c6 = vec3(0.900, 0.400, 0.000);  // Dark orange (complement)
                c7 = vec3(0.300, 0.500, 1.000);  // Light blue
                c8 = vec3(0.000, 0.100, 0.600);  // Darkest blue
            } else if (pIdx == 15) {
                // Blue with analogous cyans and violets
                c1 = vec3(0.200, 0.400, 0.900);  // Pure blue
                c2 = vec3(0.000, 0.600, 0.800);  // Blue-cyan
                c3 = vec3(0.300, 0.200, 0.100);  // Blue-violet
                c4 = vec3(0.000, 0.800, 0.800);  // Bright cyan
                c5 = vec3(0.400, 0.100, 0.800);  // Bright violet
                c6 = vec3(0.100, 0.500, 0.700);  // Dark blue-cyan
                c7 = vec3(0.500, 0.300, 0.900);  // Light blue-violet
                c8 = vec3(0.100, 0.300, 0.800);  // Deep blue
            } else if (pIdx == 16) {
                // Turquoise to purple gradient
                c1 = vec3(0.455, 0.910, 0.824);  // #74e8d2 - Turquoise
                c2 = vec3(0.776, 0.373, 0.271);  // #c65f45 - Coral red
                c3 = vec3(0.847, 0.051, 0.302);  // #d80d4d - Deep pink
                c4 = vec3(0.824, 0.208, 0.541);  // #d2358a - Rose pink
                c5 = vec3(0.804, 0.263, 0.761);  // #cd43c2 - Magenta
                c6 = vec3(0.784, 0.275, 0.976);  // #c846f9 - Bright purple
                c7 = vec3(0.847, 0.459, 0.996);  // #d875fe - Light purple
                c8 = vec3(0.910, 0.616, 0.996);  // #e89dfe - Pale purple
            } else if (pIdx == 17) {
                // Purple with complementary yellow
                c1 = vec3(0.500, 0.100, 0.700);  // Medium purple
                c2 = vec3(0.900, 0.800, 0.000);  // Golden yellow (complement)
                c3 = vec3(0.600, 0.200, 0.800);  // Bright purple
                c4 = vec3(1.000, 0.900, 0.200);  // Light yellow (complement)
                c5 = vec3(0.400, 0.000, 0.600);  // Deep purple
                c6 = vec3(0.800, 0.700, 0.000);  // Dark yellow (complement)
                c7 = vec3(0.700, 0.300, 0.900);  // Light purple
                c8 = vec3(0.300, 0.000, 0.500);  // Darkest purple
            } else if (pIdx == 18) {
                // Purple with analogous blues and magentas
                c1 = vec3(0.500, 0.100, 0.700);  // Medium purple
                c2 = vec3(0.300, 0.100, 0.800);  // Blue-purple
                c3 = vec3(0.700, 0.100, 0.600);  // Magenta-purple
                c4 = vec3(0.400, 0.050, 0.900);  // Deep blue-purple
                c5 = vec3(0.800, 0.100, 0.500);  // Pink-purple
                c6 = vec3(0.200, 0.050, 0.700);  // Dark blue-purple
                c7 = vec3(0.900, 0.200, 0.600);  // Bright magenta-purple
                c8 = vec3(0.600, 0.150, 0.800);  // Rich purple
            } else if (pIdx == 19) {
                // Orange-red to pink gradient
                c1 = vec3(0.765, 0.329, 0.208);  // #c35435 - Deep orange-red
                c2 = vec3(0.867, 0.396, 0.247);  // #dd653f - Burnt orange
                c3 = vec3(0.949, 0.451, 0.294);  // #f2734b - Coral orange
                c4 = vec3(0.984, 0.478, 0.345);  // #fb7a58 - Light coral
                c5 = vec3(1.000, 0.443, 0.427);  // #ff716d - Salmon pink
                c6 = vec3(1.000, 0.322, 0.518);  // #ff5284 - Hot pink
                c7 = vec3(0.992, 0.329, 0.569);  // #fd5491 - Deep pink
                c8 = vec3(0.976, 0.396, 0.608);  // #f9659b - Rose pink
            } else if (pIdx == 20) {
                // Peach and lime gradient
                c1 = vec3(1.000, 0.780, 0.541);  // #ffc78a - Light peach
                c2 = vec3(1.000, 0.792, 0.569);  // #ffca91 - Warm peach
                c3 = vec3(0.780, 0.976, 0.231);  // #c7f93b - Bright lime
                c4 = vec3(0.678, 0.957, 0.604);  // #adf49a - Light lime
                c5 = vec3(1.000, 0.827, 0.639);  // #ffd3a3 - Soft peach
                c6 = vec3(1.000, 0.839, 0.667);  // #ffd6aa - Pale peach
                c7 = vec3(1.000, 0.851, 0.690);  // #ffd9b0 - Cream peach
                c8 = vec3(1.000, 0.863, 0.714);  // #ffdcb6 - Light cream
            } else if (pIdx == 21) {
                // Orange with complementary blue
                c1 = vec3(1.000, 0.500, 0.000);  // Medium orange
                c2 = vec3(0.000, 0.400, 1.000);  // Blue (complement)
                c3 = vec3(1.000, 0.600, 0.200);  // Bright orange
                c4 = vec3(0.200, 0.500, 1.000);  // Light blue (complement)
                c5 = vec3(0.900, 0.400, 0.000);  // Deep orange
                c6 = vec3(0.000, 0.300, 0.900);  // Dark blue (complement)
                c7 = vec3(1.000, 0.700, 0.300);  // Light orange
                c8 = vec3(0.800, 0.300, 0.000);  // Darkest orange
            } else if (pIdx == 22) {
                // Orange with analogous reds and yellows
                c1 = vec3(1.000, 0.500, 0.000);  // Pure orange
                c2 = vec3(1.000, 0.300, 0.000);  // Red-orange
                c3 = vec3(1.000, 0.700, 0.000);  // Yellow-orange
                c4 = vec3(1.000, 0.200, 0.000);  // Bright red-orange
                c5 = vec3(1.000, 0.800, 0.000);  // Bright yellow-orange
                c6 = vec3(0.900, 0.400, 0.000);  // Deep orange-red
                c7 = vec3(1.000, 0.600, 0.200);  // Light orange
                c8 = vec3(0.800, 0.400, 0.000);  // Deep orange
            } else if (pIdx == 23) {
                // Soft monochrome to blue gradient
                c1 = vec3(0.914, 0.863, 0.804);  // #e9dccd - Warm off-white
                c2 = vec3(0.867, 0.835, 0.831);  // #ddd5d4 - Cool light gray
                c3 = vec3(0.820, 0.812, 0.859);  // #d1cfdb - Light lavender gray
                c4 = vec3(0.773, 0.784, 0.882);  // #c5c8e1 - Pale periwinkle
                c5 = vec3(0.725, 0.757, 0.906);  // #b9c1e7 - Light blue-gray
                c6 = vec3(0.682, 0.729, 0.929);  // #aebaed - Soft periwinkle
                c7 = vec3(0.635, 0.702, 0.949);  // #a2b3f2 - Light blue
                c8 = vec3(0.592, 0.671, 0.969);  // #97abf7 - Soft blue
            } else if (pIdx == 24) {
                // Mint green gradient
                c1 = vec3(0.725, 1.000, 0.859);  // #b9ffdb - Pale mint
                c2 = vec3(0.667, 1.000, 0.824);  // #aaffd2 - Light mint
                c3 = vec3(0.608, 1.000, 0.792);  // #9bffca - Fresh mint
                c4 = vec3(0.537, 1.000, 0.757);  // #89ffc1 - Bright mint
                c5 = vec3(0.447, 0.933, 0.675);  // #72eeac - Medium mint
                c6 = vec3(0.337, 0.800, 0.545);  // #56cc8b - Deep mint
                c7 = vec3(0.224, 0.671, 0.416);  // #39ab6a - Forest mint
                c8 = vec3(0.090, 0.549, 0.294);  // #178c4b - Dark mint
            } else if (pIdx == 25) {
                // Complementary monochrome (alternating dark/light)
                c1 = vec3(0.100, 0.100, 0.100);  // Near black
                c2 = vec3(0.900, 0.900, 0.900);  // Near white
                c3 = vec3(0.200, 0.200, 0.200);  // Dark gray
                c4 = vec3(0.800, 0.800, 0.800);  // Light gray
                c5 = vec3(0.300, 0.300, 0.300);  // Medium dark
                c6 = vec3(0.700, 0.700, 0.700);  // Medium light
                c7 = vec3(0.400, 0.400, 0.400);  // Mid gray
                c8 = vec3(0.600, 0.600, 0.600);  // Light mid gray
            } else if (pIdx == 26) {
                // Smooth gradient monochrome
                c1 = vec3(0.000, 0.000, 0.000);  // Black
                c2 = vec3(0.150, 0.150, 0.150);  // Very dark gray
                c3 = vec3(0.300, 0.300, 0.300);  // Dark gray
                c4 = vec3(0.450, 0.450, 0.450);  // Medium dark gray
                c5 = vec3(0.600, 0.600, 0.600);  // Medium light gray
                c6 = vec3(0.750, 0.750, 0.750);  // Light gray
                c7 = vec3(0.900, 0.900, 0.900);  // Very light gray
                c8 = vec3(1.000, 1.000, 1.000);  // White
            } else if (pIdx == 27) {
                // Triadic: Red, Blue, Yellow
                c1 = vec3(1.000, 0.200, 0.200);  // Bright red
                c2 = vec3(0.200, 0.200, 1.000);  // Bright blue
                c3 = vec3(1.000, 1.000, 0.200);  // Bright yellow
                c4 = vec3(0.800, 0.100, 0.100);  // Deep red
                c5 = vec3(0.100, 0.100, 0.800);  // Deep blue
                c6 = vec3(0.800, 0.800, 0.100);  // Deep yellow
                c7 = vec3(1.000, 0.300, 0.300);  // Light red
                c8 = vec3(0.300, 0.300, 1.000);  // Light blue
            } else if (pIdx == 28) {
                // Triadic: Purple, Green, Orange
                c1 = vec3(0.800, 0.200, 1.000);  // Bright purple
                c2 = vec3(0.200, 0.800, 0.200);  // Bright green
                c3 = vec3(1.000, 0.600, 0.000);  // Bright orange
                c4 = vec3(0.600, 0.100, 0.800);  // Deep purple
                c5 = vec3(0.100, 0.600, 0.100);  // Deep green
                c6 = vec3(0.800, 0.400, 0.000);  // Deep orange
                c7 = vec3(1.000, 0.400, 1.000);  // Light purple
                c8 = vec3(0.400, 1.000, 0.400);  // Light green
            } else if (pIdx == 29) {
                // Triadic: Cyan, Magenta, Yellow
                c1 = vec3(0.000, 1.000, 1.000);  // Bright cyan
                c2 = vec3(1.000, 0.000, 1.000);  // Bright magenta
                c3 = vec3(1.000, 1.000, 0.000);  // Bright yellow
                c4 = vec3(0.000, 0.800, 0.800);  // Deep cyan
                c5 = vec3(0.800, 0.000, 0.800);  // Deep magenta
                c6 = vec3(0.800, 0.800, 0.000);  // Deep yellow
                c7 = vec3(0.400, 1.000, 1.000);  // Light cyan
                c8 = vec3(1.000, 0.400, 1.000);  // Light magenta
            } else if (pIdx == 30) {
                // Triadic: Blue-Green, Red-Orange, Purple-Blue
                c1 = vec3(0.000, 0.800, 0.600);  // Blue-green
                c2 = vec3(1.000, 0.400, 0.200);  // Red-orange
                c3 = vec3(0.400, 0.200, 1.000);  // Purple-blue
                c4 = vec3(0.000, 1.000, 0.800);  // Bright blue-green
                c5 = vec3(1.000, 0.600, 0.400);  // Bright red-orange
                c6 = vec3(0.600, 0.400, 1.000);  // Bright purple-blue
                c7 = vec3(0.200, 0.600, 0.400);  // Deep blue-green
                c8 = vec3(0.800, 0.200, 0.000);  // Deep red-orange
            } else if (pIdx == 31) {
                // Triadic: Yellow-Green, Blue-Violet, Red-Orange
                c1 = vec3(0.600, 1.000, 0.000);  // Yellow-green
                c2 = vec3(0.400, 0.000, 1.000);  // Blue-violet
                c3 = vec3(1.000, 0.400, 0.000);  // Red-orange
                c4 = vec3(0.800, 1.000, 0.200);  // Bright yellow-green
                c5 = vec3(0.600, 0.200, 1.000);  // Bright blue-violet
                c6 = vec3(1.000, 0.600, 0.200);  // Bright red-orange
                c7 = vec3(0.400, 0.800, 0.000);  // Deep yellow-green
                c8 = vec3(0.200, 0.000, 0.800);  // Deep blue-violet
            } else if (pIdx == 32) {
                // Triadic: Teal, Violet, Gold
                c1 = vec3(0.000, 0.600, 0.600);  // Teal
                c2 = vec3(0.600, 0.000, 0.800);  // Violet
                c3 = vec3(1.000, 0.800, 0.000);  // Gold
                c4 = vec3(0.200, 0.800, 0.800);  // Bright teal
                c5 = vec3(0.800, 0.200, 1.000);  // Bright violet
                c6 = vec3(1.000, 1.000, 0.200);  // Bright gold
                c7 = vec3(0.000, 0.400, 0.400);  // Deep teal
                c8 = vec3(0.400, 0.000, 0.600);  // Deep violet
            }
            
            vec3 color1, color2;
            if (segment == 0) { color1 = c1; color2 = c2; }
            else if (segment == 1) { color1 = c2; color2 = c3; }
            else if (segment == 2) { color1 = c3; color2 = c4; }
            else if (segment == 3) { color1 = c4; color2 = c5; }
            else if (segment == 4) { color1 = c5; color2 = c6; }
            else if (segment == 5) { color1 = c6; color2 = c7; }
            else { color1 = c7; color2 = c8; }
            
            return mix(color1, color2, smoothstep(0.1, 0.9, frac));
        }

        vec3 enhanceColor(vec3 color, float noiseValue) {
            // Increase boost factor to match previous vibrancy
            float boost = 1.0 + noiseValue * 0.2;  // Changed from 0.1 to 0.2
            // Increase multiplier to match previous intensity
            vec3 enhanced = color * boost * 1.1;   // Changed from 1.85 to 2.2
            
            // Add a bit more color saturation
            enhanced = mix(enhanced, enhanced * enhanced, 1.2);  // Add color saturation
            
            return clamp(enhanced, 0.0, 2.0);
        }

        vec3 blendColors(vec3 a, vec3 b, float factor) {
            // Pre-calculate factor multipliers
            float f1 = factor * 0.8;
            float f2 = factor * 0.3;
            
            // Combine screen and add blend in one operation
            vec3 blended = mix(
                1.0 - (1.0 - a) * (1.0 - b * f1),  // screen blend
                a + b * f2,                         // add blend
                2.5 + (1.0 + sin(u_rotationAngle + u_time * 0.1)) * 0.5  // use pre-calculated sinTime
            );
            
            return blended;
        }

        float stepNoise(float noise, float steps) {
            return floor(noise * steps) / steps;
        }

        void main() {
            // Pre-calculate common trigonometric values at the start
            float baseTime = u_time * 0.1;
            float sinTime = sin(baseTime);
            float cosTime = cos(baseTime);
            float slowSinTime = sin(u_time * 0.05);
            float slowCosTime = cos(u_time * 0.05);
            
            vec2 coord = (vTexCoord * u_resolution - u_resolution * 0.25) * u_scaleFactor + u_translation;
            coord = coord / u_baseScale;
            
            vec2 gridCoord = floor(coord / u_cellSize);
            vec2 cellCenter = gridCoord * u_cellSize + u_cellSize * 0.5;
            
            float timeScale = u_time * 0.1;
            vec2 baseNoiseCoord = gridCoord * 0.1;
            vec2 timeOffset = vec2(timeScale, timeScale + 100.0);
            
            float baseNoiseFBM = fbmSimplexNoise(gridCoord * 0.05, 3);

            vec2 noiseOffset = vec2(
                noise(baseNoiseCoord + timeOffset.xx, u_noiseSeed),
                noise(baseNoiseCoord + timeOffset.yy, u_noiseSeed)
            );
            
            float gridSize = u_cellSize * mix(0.3, 2.5, baseNoiseFBM);
            vec2 localCoord = mod(coord + noiseOffset, gridSize);
            
            float randomAngle = floor(noise(gridCoord + noiseOffset, u_noiseSeed) * 4.0) * (M_PI * 0.5);
            mat2 rotationMatrix = getRotationMatrix(randomAngle);
            vec2 rotatedCoord = rotationMatrix * localCoord;
            
            float smoothedTime = u_time * 0.01 + sin(u_time * 0.005) * 0.005;
            
            vec2 noiseInput1 = rotatedCoord * 0.1 + smoothedTime;
            vec2 noiseInput2 = (rotatedCoord + gridCoord * gridSize) * u_noiseScale;
            
            float flowNoise = fbmSimplexNoise(noiseInput1, 3);
            vec2 animatedCoord = noiseInput2 + vec2(
                cos(flowNoise * 6.28318), 
                sin(flowNoise * 6.28318)
            ) * u_flowSpeed * 0.005;
            
            float curlNoise = fbmSimplexNoise(animatedCoord * 1.5 + vec2(u_noiseSeed), 4);
            animatedCoord += 4.0 * vec2(
                cos(curlNoise * 6.28318),
                sin(curlNoise * 6.28318)
            );
            float baseNoise = fbmSimplexNoise(animatedCoord + noiseOffset, 3);
            
            vec4 color = vec4(0.0);
            const int MAX_LOOP_DEPTH = 8;
            
            float rawCombinedNoise = (baseNoise * 0.5 + baseNoiseFBM * 0.5 + 1.0) * 0.4; 
            float combinedNoise = stepNoise(rawCombinedNoise, 4.0);  

            float clampedNoise = clamp(combinedNoise, 0.0, 1.0);
            int dynamicDepth = int(clamp(
                clampedNoise * float(u_maxDepth),
                1.0,
                min(float(u_maxDepth), float(MAX_LOOP_DEPTH))
            ));
            
            float t = 0.5 + 0.5 * sin(u_time * 2.0 * u_flowSpeed);
            float angleInfluence = sin(u_rotationAngle * 0.1 + baseTime * 2.0) * 0.5 + 0.5;
            float blendFactor = t * t * (3.0 - 2.0 * t) * (1.0 + combinedNoise * 0.6 + angleInfluence);
            
            int paletteIndex1 = int(u_paletteIndex1);
            int paletteIndex2 = int(u_paletteIndex2);
            
            vec3 color1Base = getColorFromPalette(paletteIndex1, 0.5);
            vec3 color2Base = getColorFromPalette(paletteIndex2, 0.5);
            
            for (int depth = 0; depth < MAX_LOOP_DEPTH; depth++) {
                if (depth >= dynamicDepth) break;
                
                float depthNoiseValue = noise(animatedCoord * float(depth + 1), u_noiseSeed);
                
                float threshold = 0.6 + combinedNoise * 0.6;
                if (depthNoiseValue > threshold) {
                    float size = gridSize / max(exp2(float(depth)), 0.0001);
                    vec2 cellCoord = mod(coord, size);
                    
                    float depthFactor = float(depth) / float(MAX_LOOP_DEPTH);
                    float circleSize = mix(0.45, 0.05, depthFactor);  
                    
                    float distToCenter = length(coord - cellCenter);
                    if (distToCenter > u_cellSize * circleSize) {
                        continue;  
                    }
                    
                    if (cellCoord.x < size * 0.5 && cellCoord.y < size * 0.5) {
                        float edge0 = 0.2 + slowSinTime * 0.2;
                        float edge1 = 0.8 + slowCosTime * 0.2;
                        float colorT = smoothstep(edge0, edge1, depthFactor + combinedNoise * 0.6);

                        // Simple lerp between pre-calculated colors instead of full palette lookup
                        vec3 color1 = mix(color1Base, getColorFromPalette(paletteIndex1, colorT), 0.5);
                        vec3 color2 = mix(color2Base, getColorFromPalette(paletteIndex2, 1.0 - colorT), 0.5);

                        float depthBoost = 1.0 + (1.0 - depthFactor) * 0.5;
                        color1 *= depthBoost;
                        color2 *= depthBoost;
                        
                        vec3 enhancedColor1 = enhanceColor(color1, combinedNoise);
                        vec3 enhancedColor2 = enhanceColor(color2, combinedNoise);
                        
                        vec3 blendedColor = blendColors(enhancedColor1, enhancedColor2, blendFactor);
                        
                        color.rgb *= 1.0;
                        color += vec4(blendedColor, 1.0) * (1.0 - depthNoiseValue * 0.5);
                    }
                }
            }
            
            if (color.a == 0.0) {
                color = vec4(0.0, 0.0, 0.0, 1.0);
            }
            
            gl_FragColor = color;
        }
    </script>

    <script>
        const BASE_HEIGHT = 900; 
        let baseScale = 1.0;    
        let theShader;
        let displayMode = 0;
        let cellSize = 120;     
        let noiseScale = 0.0001;
        let maxDepth;
        let noiseSeed;
        let flowSpeed = 0.005;
        let paletteIndex1, paletteIndex2;
        let randomScaleSeed;
        let rotationAngle;
        let noiseOffsetX, noiseOffsetY;
        let scaleFactor = 30;
        let translateX = 0, translateY = 0;
        let initialTranslateX = 0, initialTranslateY = 0;
        let previousMouseX, previousMouseY;
        let amplitudeValues = [0.05, 0.075, 0.1];
        let isPlaying = true;
        let startTime = 0;
        let currentTime = 0;
        let luminosity = 1.5;
        let vibrancy = 5.5;
        let fpsBuffer = [];
        const FPS_BUFFER_LENGTH = 30; 
        let lastLoop = performance.now();
        let showFPS = true;  

        // Add after the existing variables
        const MIN_FPS = 24;
        const DEFAULT_PIXEL_DENSITY = 2;
        const MIN_PIXEL_DENSITY = 0.5;
        const MAX_PIXEL_DENSITY = 2;
        let currentPixelDensity = DEFAULT_PIXEL_DENSITY;
        let fpsCheckCounter = 0;
        const FPS_CHECK_INTERVAL = 10;  // Check every 30 frames

        function adjustPixelDensity(fps) {
            if (fpsCheckCounter++ < FPS_CHECK_INTERVAL) return;
            fpsCheckCounter = 0;
            
            let previousDensity = currentPixelDensity;
            
            if (fps < MIN_FPS && currentPixelDensity > MIN_PIXEL_DENSITY) {
                currentPixelDensity = Math.max(MIN_PIXEL_DENSITY, currentPixelDensity - 0.25);
                pixelDensity(currentPixelDensity);
                console.log(`Reduced pixel density to ${currentPixelDensity} (FPS: ${fps})`);
            } else if (fps > MIN_FPS + 10 && currentPixelDensity < DEFAULT_PIXEL_DENSITY) {
                currentPixelDensity = Math.min(DEFAULT_PIXEL_DENSITY, currentPixelDensity + 0.25);
                pixelDensity(currentPixelDensity);
                console.log(`Increased pixel density to ${currentPixelDensity} (FPS: ${fps})`);
            }
            
            // Update cell size if pixel density changed
            if (previousDensity !== currentPixelDensity) {
                cellSize = calculateCellSize(currentPixelDensity);
                console.log(`Updated cell size to ${cellSize}`);
            }
        }

        function calculateCellSize(pixelDensity) {
            // Base cell size is 100 at pixel density 2
            const BASE_CELL_SIZE = 100;
            const BASE_PIXEL_DENSITY = 2;
            
            // Inverse proportion: as density goes down, size goes up
            return BASE_CELL_SIZE * (BASE_PIXEL_DENSITY / pixelDensity);
        }

        let inscription_id = window.location.pathname.split("/").pop();
        
        // REMOVE AFTER TESTING!!!
            let chars = "0123456789abcdefghijklmnopqrstuvwsyz";
            inscription_id = new URLSearchParams(window.location.search).get("seed") || Array(64).fill(0).map(_=>chars[(Math.random()*chars.length)|0]).join('');
        // REMOVE AFTER TESTING!!!

        // BUGGY SEEDS - for you to test :)

        // kftyk5iyj23pt7y3g3wib9vc4ebqs3pmsszbz1ehibedey2lgfe0pqu0m1078re5
        // q6vlo1umitq2d5ugtlvc1h0j78gvqwr1yp689jzbq3i6h1cl4y6iigfqdh7skt3i
        // 9d7fq3qtqgpuvsdo384maqs8q2ydai2nrg8ik8sdtw5ypa7selz3y3y1q2no2gio
        // d22y74bs6dlq3o23d4zl2cjkge8rqsewu2nh393b7ds87ts5wvla50hrhln99lbf
        // wraa45m0mfd2to4l1gfer4h2nawueqsf4ynjyoby8hdya62zamvbhzsir45hstot

        // Class to use inscription ID hash as a PRNG (PseudoRandom Number Generator).
        // Helpful with vanilla JS.
        // Can be replaced or removed if you use another PRNG.
        class Rnd{
            constructor(seed) {
                const i=Math.imul,h=t=>{let e,l=0;for(e=1779033703^t.length;l<t.length;l++){let h=e^t.charCodeAt(l);e=i(h,3432918353),e=e<<13|e>>>19}return()=>(e=i(e^e>>>16,2246822507),e=i(e^e>>>13,3266489909),(e^=e>>>16)>>>0)},a=(e,r,t,a)=>()=>{let l=((e|=0)+(r|=0)|0)+(a|=0)|0;return a=a+1|0,e=r^r>>>9,r=(t|=0)+(t<<3)|0,t=(t=t<<21|t>>>11)+l|0,(l>>>0)/4294967296},X=h(seed);this.R=a(X(),X());
            }
            D=_=>this.R();                  // returns a random value in range <0, 1)
            N=(r,t)=>r+(t-r)*this.D();      // returns a random number in range <r, t)
            I=(r,t)=>0|this.N(r,t+1);       // returns a random integer in range <r, t>
            B=r=>this.D()<r                 // returns true if lower than r
        };
        let R = new Rnd(inscription_id)

        console.log('Inscription ID:', inscription_id)

        function updateTranslationForCenter() {
            let visibleWidth = width / scaleFactor;
            let visibleHeight = height / scaleFactor;
            
            translateX = -width/2 + (visibleWidth * scaleFactor/2);
            translateY = -height/2 + (visibleHeight * scaleFactor/2);
        }

        function preload() {
            let vertexShader = document.getElementById('vertex-shader').textContent;
            let fragmentShader = document.getElementById('fragment-shader').textContent;
            theShader = createShader(vertexShader, fragmentShader);
            console.log("Shader created:", theShader);
        }

        function setup() {
            console.log("Starting setup...");
            
            console.log("inscription_id:", inscription_id);
            
            if (!inscription_id) {
                console.error("Could not retrieve inscription ID");
                return;
            }
            
            createCanvas(windowWidth, windowHeight, WEBGL);
            noStroke();
            shader(theShader);
            pixelDensity(2);
            
            updateCanvasSize();
            
            noiseOffsetX = R.I(0,2000)
            noiseOffsetY = R.I(0,2000)

            let shiftX = -width/2;
            let shiftY = -height/2;
            initialTranslateX = shiftX;
            initialTranslateY = shiftY;
            translateX = shiftX;
            translateY = shiftY;

            noiseSeed = R.I(0,1000)

            let u_maxDepth = 100 + R.I(0,101)

            paletteIndex1 = R.I(0,32)
            paletteIndex2 = R.I(0,32)

            randomScaleSeed = R.I(0,1000)

            rotationAngle = R.I(0, 360)
            
            let tempRand = R.I(0, amplitudeValues.length - 1);
            let randomAmplitude = amplitudeValues[ tempRand];

            let initialFreqOptions = [0.00005, 0.0005, 0.005];
            let selectedFreq = initialFreqOptions[ R.I(0,2) ];

            theShader.setUniform('u_paletteIndex1', paletteIndex1);
            theShader.setUniform('u_paletteIndex2', paletteIndex2);
            theShader.setUniform('u_noiseSeed', noiseSeed);
            theShader.setUniform('u_randomScaleSeed', randomScaleSeed);
            theShader.setUniform('u_rotationAngle', radians(rotationAngle));
            theShader.setUniform('u_noiseOffset', [noiseOffsetX, noiseOffsetY]);
            theShader.setUniform('u_amplitude', randomAmplitude);
            theShader.setUniform('u_maxDepth', u_maxDepth);
            theShader.setUniform('u_backgroundColor', [0.0, 0.0, 0.0, 1.0]);
            theShader.setUniform('u_luminosity', luminosity);
            theShader.setUniform('u_vibrancy', vibrancy);
            theShader.setUniform('u_initialFreq', selectedFreq);

            scaleFactor = 30;
            updateTranslationForCenter();

            document.addEventListener('keydown', (e) => {
                if (e.key === 'a' || e.key === 'A') {
                    displayMode = (displayMode + 1) % 3;
                    updateCanvasSize();
                    console.log('Display mode:', ['fullscreen', '16:9', '9:16'][displayMode]);
                }
                if (e.key === 'r' || e.key === 'R') { 
                    updateTranslationForCenter();
                    scaleFactor = 30;
                    console.log('Position reset');
                }
                if (e.key === 's' || e.key === 'S') {
                    isPlaying = !isPlaying;
                    if (isPlaying) {
                        startTime = millis() - currentTime * 1000;
                    } else {
                        currentTime = (millis() - startTime) / 1000.0;
                    }
                    console.log('Animation ' + (isPlaying ? 'playing' : 'paused'));
                }
                if (e.key === '1') {
                    let currentDensity = pixelDensity();
                    
                    pixelDensity(4);
                    
                    draw();
                    
                    let timestamp = year() + nf(month(), 2) + nf(day(), 2) + '_' + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);
                    saveCanvas('shader_' + timestamp, 'png');
                    
                    pixelDensity(currentDensity);
                    
                    draw();
                    
                    console.log('Canvas saved as shader_' + timestamp + '.png');
                }
                if (e.key === '2') {
                    let currentDensity = pixelDensity();
                    
                    pixelDensity(5);
                    
                    draw();
                    
                    let timestamp = year() + nf(month(), 2) + nf(day(), 2) + '_' + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);
                    saveCanvas('shader_hires_' + timestamp, 'png');
                    
                    pixelDensity(currentDensity);
                    
                    draw();
                    
                    console.log('High-res canvas saved as shader_hires_' + timestamp + '.png');
                }
                if (e.key === '3') {
                    let currentDensity = pixelDensity();
                    
                    pixelDensity(5.5);
                    
                    draw();
                    
                    let timestamp = year() + nf(month(), 2) + nf(day(), 2) + '_' + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);
                    saveCanvas('shader_hires_' + timestamp, 'png');
                    
                    pixelDensity(currentDensity);
                    
                    draw();
                    
                    console.log('Very high-res canvas saved as shader_hires_' + timestamp + '.png');
                }
                if (e.key === 'd' || e.key === 'D') {
                    if (scaleFactor === 30) scaleFactor = 10;
                    else scaleFactor = 30;
                    updateTranslationForCenter();
                    console.log('Scale factor:', scaleFactor);
                }
                if (e.key === 'f' || e.key === 'F') {
                    showFPS = !showFPS;
                    if (!showFPS) {
                        let fpsDisplay = document.getElementById('fpsDisplay');
                        if (fpsDisplay) {
                            fpsDisplay.remove();
                        }
                    }
                }
            });
            startTime = millis();
            currentPixelDensity = DEFAULT_PIXEL_DENSITY;
            pixelDensity(currentPixelDensity);
        }

        function calculateFPS() {
            let thisLoop = performance.now();
            let fps = 1000 / (thisLoop - lastLoop);
            lastLoop = thisLoop;
            
            fpsBuffer.push(fps);
            if (fpsBuffer.length > FPS_BUFFER_LENGTH) {
                fpsBuffer.shift();
            }
            
            let avgFPS = fpsBuffer.reduce((a, b) => a + b) / fpsBuffer.length;
            return Math.round(avgFPS);
        }

        function draw() {
            clear();
            background(0);
            
            if (isPlaying) {
                currentTime = (millis() - startTime) / 1000.0;
            }

            if (mouseIsPressed && mouseButton === LEFT) {
                if (previousMouseX !== undefined && previousMouseY !== undefined) {
                    let deltaX = mouseX - previousMouseX;
                    let deltaY = mouseY - previousMouseY;
                    translateX -= deltaX;
                    translateY += deltaY;
                }
                previousMouseX = mouseX;
                previousMouseY = mouseY;
            } else {
                previousMouseX = undefined;
                previousMouseY = undefined;
            }

            let scaledTime = currentTime;

            theShader.setUniform('u_baseScale', baseScale);
            theShader.setUniform('u_scaleFactor', scaleFactor);
            theShader.setUniform('u_translation', [translateX, translateY]);
            theShader.setUniform('u_resolution', [width, height]);
            theShader.setUniform('u_time', scaledTime);
            theShader.setUniform('u_cellSize', cellSize * baseScale);
            theShader.setUniform('u_noiseScale', noiseScale);
            theShader.setUniform('u_flowSpeed', flowSpeed);
            theShader.setUniform('u_backgroundColor', [0.0, 0.0, 0.0, 1.0]);
            theShader.setUniform('u_luminosity', luminosity);
            theShader.setUniform('u_vibrancy', vibrancy);

            beginShape();
            vertex(0, 0, 0, 0, 0);
            vertex(2, 0, 0, 1, 0);
            vertex(2, 2, 0, 1, 1);
            vertex(0, 2, 0, 0, 1);
            endShape(CLOSE);

            if (showFPS) {
                let fps = calculateFPS();
                adjustPixelDensity(fps);
                
                let fpsDisplay = document.getElementById('fpsDisplay');
                if (!fpsDisplay) {
                    fpsDisplay = document.createElement('div');
                    fpsDisplay.id = 'fpsDisplay';
                    fpsDisplay.style.position = 'fixed';
                    fpsDisplay.style.top = '10px';
                    fpsDisplay.style.left = '10px';
                    fpsDisplay.style.color = 'white';
                    fpsDisplay.style.fontFamily = 'monospace';
                    fpsDisplay.style.fontSize = '16px';
                    fpsDisplay.style.zIndex = '1000';
                    document.body.appendChild(fpsDisplay);
                }
                fpsDisplay.textContent = `FPS: ${fps} (PD: ${currentPixelDensity.toFixed(2)})`;
            }
        }

        function updateBaseScale() {
            let rawScale = height / BASE_HEIGHT;
            // Dampen scale changes when canvas is smaller than base height
            if (rawScale < 1) {
                // Make scaling even less aggressive by using 0.5 instead of 0.7
                baseScale = 1 - ((1 - rawScale) * 0.5);  // Changed from 0.7 to 0.5
            } else {
                baseScale = rawScale;
            }
            return baseScale;
        }

        function getScaledValue(baseValue) {
            return baseValue * baseScale;
        }

        function updateCanvasSize() {
            let newWidth, newHeight;
            
            switch(displayMode) {
                case 0:
                    resizeCanvas(windowWidth, windowHeight);
                    break;
                
                case 1:
                    if (windowWidth < windowHeight) {
                        newWidth = windowWidth;
                        newHeight = windowWidth;
                    } else {
                        newHeight = windowHeight;
                        newWidth = windowHeight;
                    }
                    resizeCanvas(newWidth, newHeight);
                    break;
                
                case 2:
                    if (windowWidth / windowHeight > 2/3) {
                        newHeight = windowHeight;
                        newWidth = (windowHeight * 2) / 3;
                    } else {
                        newWidth = windowWidth;
                        newHeight = (windowWidth * 3) / 2;
                    }
                    resizeCanvas(newWidth, newHeight);
                    break;
            }
            
            updateBaseScale();
            updateTranslationForCenter();
            
            let canvas = document.querySelector('canvas');
            canvas.style.position = 'absolute';
            canvas.style.left = '50%';
            canvas.style.top = '50%';
            canvas.style.transform = 'translate(-50%, -50%)';
        }

        function windowResized() {
            updateCanvasSize();
        }
    </script>
  </body>
</html>
