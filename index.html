<!DOCTYPE html>
<html>
  <head>
    <title>Shader Art</title>
    <script src="https://ordinals.com/content/7e37766541506810ba6399c4b2735121f508bd9209df43dd200bf2316b014594i0"></script>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000;
        }
        canvas {
            width: 100% !important;
            height: 100% !important;
            object-fit: contain !important;
            max-width: 100vw;
            max-height: 100vh;
        }
        main {
            display: flex;
            justify-content: center;
            width: 100%;
            align-items: center;
            height: 100%;
        }
    </style>
  </head>
  <body>
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec3 aPosition;
        attribute vec2 aTexCoord;
        varying vec2 vTexCoord;

        void main() {
            vTexCoord = aTexCoord;
            vec4 positionVec4 = vec4(aPosition, 1.0);
            positionVec4.xy = positionVec4.xy * 2.0 - 1.0;
            gl_Position = positionVec4;
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        precision lowp int;  // Integer precision can be low for most operations
        #endif

        #define M_PI 3.14159265358979323846

        varying vec2 vTexCoord;
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float u_cellSize;
        uniform float u_noiseScale;
        uniform float u_maxDepth;
        uniform float u_flowSpeed;
        uniform float u_nS;
        uniform float u_rSS;
        uniform float u_roA;
        uniform vec2 u_nOS;
        uniform float u_amplitude;
        uniform float u_scaleFactor;
        uniform vec2 u_translation;
        uniform float u_luminosity;
        uniform float u_vibrancy;
        uniform float u_initialFreq;
        uniform float u_bS;
        uniform float u_sortStrength;
        uniform float u_sortFrequency;
        uniform float u_sortAnimSpeed;
        uniform int u_currentPattern;
        uniform float u_baseModulation;
        uniform vec4 u_baseColor;
        uniform vec3 u_randomColor1;  // Add uniforms for random colors
        uniform vec3 u_randomColor2;
        uniform vec3 u_randomColor3;
        
        // Add new toggle uniforms
        uniform bool u_enableDomainWarp;    // Toggle domain warping
        uniform bool u_enableLayeredNoise;  // Toggle layered noise
        uniform bool u_enableFlowFields;    // Toggle flow field distortion
        uniform bool u_enableGlyphNoise;    // Toggle glyph pattern noise
        uniform bool u_enableGridDistort;   // Toggle grid distortion
        uniform bool u_enableGlyphNoiseDetail;    // Toggle detail noise within glyphs

        // Add the isLightBackground uniform to the shader
        uniform bool u_isLightBackground;   // Whether we're using a light background

        // Add this uniform after the other uniforms in the fragment shader
        uniform float u_caScaleVariation;  // Controls how much the CA scale varies

        lowp float random(vec2 st, float seed) {
            // Hash function only needs low precision output
            vec2 p = st + seed;
            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }

        mediump float noise(vec2 st, float seed) {
            // Integer and fractional parts
            vec2 i = floor(st);
            vec2 f = fract(st);
            
            // Optimized smoothstep with lowp precision
            lowp vec2 u = f * f * (3.0 - 2.0 * f);
            
            // Gather corners with low precision
            lowp float a = random(i, seed);
            lowp float b = random(i + vec2(1.0, 0.0), seed);
            lowp float c = random(i + vec2(0.0, 1.0), seed);
            lowp float d = random(i + vec2(1.0, 1.0), seed);
            
            // Mix can use low precision
            return mix(
                a + (b - a) * u.x,
                c + (d - c) * u.x,
                u.y);
        }

        lowp vec3 mod289(vec3 x) { 
            return x - floor(x / 289.0) * 289.0; 
        }

        lowp vec2 mod289(vec2 x) { 
            return x - floor(x / 289.0) * 289.0; 
        }

        lowp vec3 permute(vec3 x) { 
            return mod289((x * 34.0 + 1.0) * x); 
        }
///////////////////////////////////////////////////////////////////////////
      
//////////////////////////////////////////////////////////////////////////

mediump float simplexNoise(mediump vec2 v, float time) {
    // Parameters
    mediump vec2 p = v * 0.0015;
    //mediump vec2 p = v * 0.005;

    // Keep time scale extremely slow
    float t = time * 0.0005;
    
    // Quantum parameters
    float hbar = 1.0; // Planck constant (scaled)
    float mass = 1.0 + 0.1 * sin(t * 0.2);
    float k0 = 5.0; // Wave number
    //float k0 = 0.05; // Wave number

    // Create multiple wave packets with different phases
    vec2 psi = vec2(0.0); // Real and imaginary parts
    
    // Wave packet 1
    float x1 = length(p - vec2(cos(t * 0.1), sin(t * 0.1)) * 0.5);
    float phase1 = k0 * x1 - (hbar * k0 * k0 / (2.0 * mass)) * t * 0.5;
    float gauss1 = exp(-x1 * x1 / (2.0 * (0.5 + 0.1 * sin(t * 0.3))));
    psi.x += gauss1 * cos(phase1);
    psi.y += gauss1 * sin(phase1);
    
    // Wave packet 2
    float x2 = length(p - vec2(cos(t * 0.12 + 3.14), sin(t * 0.12 + 3.14)) * 0.5);
    float phase2 = k0 * x2 - (hbar * k0 * k0 / (2.0 * mass)) * t * 0.5 + 3.14 * sin(t * 0.05);
    float gauss2 = exp(-x2 * x2 / (2.0 * (0.5 + 0.1 * cos(t * 0.25))));
    psi.x += gauss2 * cos(phase2);
    psi.y += gauss2 * sin(phase2);
    
// Add a third wave packet
float x3 = length(p - vec2(cos(t * 0.15 + 1.57), sin(t * 0.15 + 1.57)) * 0.5);
float phase3 = k0 * x3 - (hbar * k0 * k0 / (2.0 * mass)) * t * 0.5;
float gauss3 = exp(-x3 * x3 / (2.0 * (0.5 + 0.1 * sin(t * 0.35))));
psi.x += gauss3 * cos(phase3);
psi.y += gauss3 * sin(phase3);


    // Potential barrier effect
    float barrier = smoothstep(0.1, 0.15, abs(p.x));
    float tunnelProb = exp(-barrier * 5.0);
    psi *= mix(tunnelProb, 1.0, 0.7);
    
    // Calculate probability density
    float probability = dot(psi, psi);
    
    // Add quantum measurement effect
    float measurementIntensity = 0.3 * (0.5 + 0.5 * sin(t * 0.07));
    vec2 measurePos = vec2(sin(t * 0.03), cos(t * 0.04)) * 0.8;
    float measureDist = length(p - measurePos);
    float measurement = exp(-measureDist * measureDist / 0.1) * measurementIntensity;
    
    // Apply collapse effect
    probability = mix(probability, measurement, smoothstep(0.0, 0.2, measurement));
    
    // Add edge enhancement
    vec2 grad;
    float epsilon = 0.01;
    grad.x = probability - dot(vec2(psi.x + epsilon, psi.y) * vec2(psi.x + epsilon, psi.y), 
                               vec2(psi.x + epsilon, psi.y) * vec2(psi.x + epsilon, psi.y));
    grad.y = probability - dot(vec2(psi.x, psi.y + epsilon) * vec2(psi.x, psi.y + epsilon), 
                               vec2(psi.x, psi.y + epsilon) * vec2(psi.x, psi.y + epsilon));
    float edgeValue = length(grad) * 10.0 * (0.5 + 0.5 * sin(t * 0.08));
    
    // Final combination
    return clamp(probability * 0.7 + edgeValue * 0.3, -1.0, 1.0) * 0.8;
}
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
        lowp float fastSin(float x) {
            // Wrap to -PI to PI range
            x = mod(x + M_PI, 2.0 * M_PI) - M_PI;
            
            // Fast sine approximation
            // Error < 0.002
            float x2 = x * x;
            return x * (1.0 - x2 / (3.0 * 2.0) + x2 * x2 / (5.0 * 4.0 * 3.0 * 2.0));
        }

        lowp float fastCos(float x) {
            return fastSin(x + M_PI * 0.5);
        }

        vec2 domainWarp(vec2 p, float time) {
            float slowTime = time * 0.0001;
            
            float flow = simplexNoise(p * 0.05 * (u_resolution.y / u_cellSize) + slowTime, slowTime);
            float detail = simplexNoise(p * 0.1 * (u_resolution.y / u_cellSize) + slowTime * 1.5, slowTime * 2.0) * 0.3;
            
            // Use fast approximations
            float angle = slowTime * 0.1;
            float rotX = fastCos(angle) * flow;
            float rotY = fastSin(angle) * flow;
            
            return p + vec2(
                rotX * 1.5 + detail,
                rotY * 1.5 + detail
            );
        }

        float layeredNoise(vec2 p, float time) {
            // Simplified to single layer with detail
            float mainLayer = simplexNoise(p, time);
            float detail = simplexNoise(p * 2.0, time * 0.3) * 0.3;
            return mainLayer * 0.7 + detail * 0.3;
        }

        float fbmSimplexNoise(vec2 v, int octaves) {
            if (octaves <= 0) return 0.0;
            
            const float PERSISTENCE = 0.001;
            const float LACUNARITY = 0.0009;
            const int MAX_OCTAVES = 2;
            
            float total = 0.0;
            float amplitude = u_amplitude;
            float frequency = u_initialFreq;
            
            // Apply initial offsets
            v += u_nOS + vec2(u_nS);
            
            // Calculate base pattern with simplified domain warping
            vec2 warpedCoord = domainWarp(v, u_time * 0.1);
            float basePattern = layeredNoise(warpedCoord, u_time);
            total = amplitude * basePattern;
            
            // Simplified time influence - single noise sample
            float timeInfluence = simplexNoise(vec2(u_time * 0.05, 0.0), u_nS) * 0.5;
            
            // Only two octaves with simplified rotation
            float timeRotation = u_time * 0.05;
            // Precalculate sin/cos using fast approximations
            float sinRot = fastSin(timeRotation);
            float cosRot = fastCos(timeRotation);
            mat2 rot = mat2(cosRot, -sinRot, sinRot, cosRot);
            
            // First octave
            amplitude *= PERSISTENCE * 3.2;
            frequency *= LACUNARITY * (1.0 + timeInfluence * 0.2);
            total += amplitude * layeredNoise(rot * warpedCoord * frequency, u_time * 0.9);
            
            // Second octave (if needed)
            if (octaves > 1) {
                amplitude *= PERSISTENCE * 2.0;
                frequency *= LACUNARITY * (1.0 + timeInfluence * 0.2);
                total += amplitude * layeredNoise(rot * warpedCoord * frequency, u_time * 0.9);
            }
            
            // Apply final modulation
            return total * (timeInfluence * 0.9 + u_baseModulation);
        }


        lowp vec3 getColorFromPalette(float t) {
            t = clamp(t, 0.0, 4.0) * 7.0;
            int segment = int(t);
            float frac = t - float(segment);
            float phase = float(segment) / 7.0;
            
            vec3 color1, color2;
            
            // Use the random colors passed from JavaScript
                    color1 = mix(
                mix(u_randomColor1, u_randomColor2, sin(phase * 6.28318) * 0.5 + 0.5),
                u_randomColor3,
                        cos(phase * 9.42477) * 0.5 + 0.5
                    );
                    color2 = mix(
                mix(u_randomColor2, u_randomColor3, cos(phase * 12.56636) * 0.5 + 0.5),
                u_randomColor1,
                        sin(phase * 15.70796) * 0.5 + 0.5
                    );
            
            return mix(color1, color2, smoothstep(0.1, 0.9, frac));
        }

        lowp vec3 enhanceColor(vec3 color, float noiseValue) {
            const vec3 LUM_WEIGHTS = vec3(0.333, 0.333, 0.334);
            float luminance = dot(color, LUM_WEIGHTS);
            
            // Adjust boost based on background
            //float noiseInfluence = 1.0 + noiseValue * (u_isLightBackground ? 0.05 : 0.1);  //0.05 : 01
            float noiseInfluence = 1.0 + noiseValue * (u_isLightBackground ? 0.02 : 0.04); // lower influence
            vec3 boosted = color * (1.0 + (1.0 - luminance) * noiseInfluence);
            
            // Adjust saturation based on background
            //float saturationStrength = u_isLightBackground ? 1.5 : 2.0;  //1.1 : 1.2
            float saturationStrength = u_isLightBackground ? 1.1 : 1.2; // lower influence
            vec3 saturated = mix(
                vec3(luminance),
                boosted,
                vec3(saturationStrength)
            );
            
            // Adjust contrast based on background
            //float contrastPower = u_isLightBackground ? 0.9 : 0.85;  //0.9 : 0.85
            float contrastPower = u_isLightBackground ? 0.95 : 0.92; // lower influence
            vec3 contrasted = pow(saturated, vec3(contrastPower));
            
            //float highlightThreshold = u_isLightBackground ? 0.9 : 0.85;  //0.9 : 0.85
            float highlightThreshold = u_isLightBackground ? 0.95 : 0.92; // lower influence
            vec3 highlights = smoothstep(highlightThreshold, 1.0, contrasted);
            //contrasted = mix(contrasted, highlights * 0.8, 0.2); // 0.8, 0.2
            //contrasted = mix(contrasted, highlights * 0.9, 0.1); // lower influence
            contrasted = mix(contrasted, highlights * 0.9, 0.6); // higer influence

            // Final multiplier based on background
            //float finalMultiplier = u_isLightBackground ? 0.9 : 1.1;  //0.9 : 1.1
            float finalMultiplier = u_isLightBackground ? 0.95 : 1.05; // lower influence
            return contrasted * finalMultiplier;
        }
        //VAR WITHOUT ENHANCEMENT////////////////////////////////
        //lowp vec3 enhanceColor(vec3 color, float noiseValue) {
            // Return the original color with no enhancement
            //return color;
        //}
        //////////////////////////////////////////////////////////////

        lowp vec3 blendColors(lowp vec3 a, lowp vec3 b, lowp float factor) {
            // Screen blend can use low precision
            lowp vec3 screen = 1.0 - (1.0 - a) * (1.0 - b * factor * 0.8);
            
            // Addition blend can use low precision
            lowp vec3 add = a + b * factor * 0.3;
            
            // Rotation influence calculation
            lowp float rotationInfluence = (1.0 + sin(u_roA + u_time * 0.1)) * 0.5;
            
            return mix(screen, add, 2.5 + rotationInfluence);
        }

        lowp vec2 getFlowDirection(mediump vec2 position, float time) {
            lowp float slowTime = time * u_sortAnimSpeed * 0.05;
            
            // Create fluid simulation parameters
            float scale = 0.01;
            vec2 p = position * scale;
            
            // Generate animated pressure field with multiple frequencies
            float pressure = simplexNoise(p * 0.5 + vec2(slowTime * 0.05), slowTime) +
                            0.5 * simplexNoise(p * 1.0 + vec2(slowTime * 0.08), slowTime);
            
            // Calculate pressure gradient (force)
            float px = simplexNoise(p * 0.5 + vec2(0.1, 0.0) + vec2(slowTime * 0.05), slowTime) - pressure;
            float py = simplexNoise(p * 0.5 + vec2(0.0, 0.1) + vec2(slowTime * 0.05), slowTime) - pressure;
            vec2 pressureGradient = vec2(px, py) * 10.0;
            
            // Generate velocity field
            vec2 velocity = vec2(
                simplexNoise(p * 0.7 + vec2(slowTime * 0.1, 0.0), slowTime),
                simplexNoise(p * 0.7 + vec2(0.0, slowTime * 0.1), slowTime)
            );
            
            // Add boundary effects
            float boundaryDist = min(min(
                abs(p.x - 50.0 * scale),
                abs(p.x + 50.0 * scale)),
                min(
                    abs(p.y - 50.0 * scale),
                    abs(p.y + 50.0 * scale)
                )
            );
            vec2 boundaryFlow = normalize(p) * smoothstep(0.0, 5.0 * scale, boundaryDist);
            
            // Add vorticity confinement
            float vorticity = velocity.y - velocity.x;
            float animatedVortexStrength = 0.3 + 0.2 * sin(slowTime * 0.3);
            vec2 vorticityForce = vec2(vorticity, -vorticity) * animatedVortexStrength;
            
            // Add time-varying external forces (like gravity or stirring)
            vec2 externalForce = vec2(
                sin(slowTime * 0.3 + position.x * 0.01) * 0.5,
                cos(slowTime * 0.2 + position.y * 0.01) * 0.5
            );
            
            // Add rotating force field
            float angle = slowTime * 0.2;
            vec2 rotatingForce = vec2(
                cos(angle) * sin(p.y * 2.0 + slowTime),
                sin(angle) * sin(p.x * 2.0 + slowTime)
            ) * 0.3;
            
            // Add spiral force
            float spiralAngle = atan(p.y, p.x) + slowTime * 0.1;
            float spiralRadius = length(p);
            vec2 spiralForce = vec2(
                cos(spiralAngle + spiralRadius),
                sin(spiralAngle + spiralRadius)
            ) * 0.4 * exp(-spiralRadius * 2.0);
            
            // Combine all forces with appropriate weights
            return normalize(
                velocity * 1.0 - 
                pressureGradient * 0.7 + 
                boundaryFlow * 0.5 + 
                vorticityForce * 0.3 + 
                externalForce * 0.4 +
                rotatingForce +
                spiralForce
            );
        }

        // Add this function before getGlyphPattern
        lowp vec4 getCASettings(float seed, float iter) {
            // Use seed and iteration to select pattern type
            float patternSeed = fract(seed * 12345.6789 + iter * 789.123);
            
            // Select one of four patterns based on the seed
            int patternType = int(mod(patternSeed * 4.0, 4.0));
            
            // Return vec4(dirBiasStrength, surviveThreshold, birthThreshold, edgeThreshold)
            if (patternType == 0) {
                // Organic, flowing patterns
                return vec4(
                    0.4,    // dirBias strength
                    1.3,    // surviveThreshold base
                    2.3,    // birthThreshold base
                    0.35    // edgeThreshold base
                );
            } else if (patternType == 1) {
                // Geometric, crystalline patterns
                return vec4(
                    0.15,   // dirBias strength
                    1.6,    // surviveThreshold base
                    2.7,    // birthThreshold base
                    0.5     // edgeThreshold base
                );
            } else if (patternType == 2) {
                // Chaotic, detailed patterns
                return vec4(
                    0.3,    // dirBias strength
                    1.7,    // surviveThreshold base
                    2.2,    // birthThreshold base
                    0.45    // edgeThreshold base
                );
            } else {
                // Symmetric patterns
                return vec4(
                    0.25,   // dirBias strength
                    1.5,    // surviveThreshold base
                    2.5,    // birthThreshold base
                    0.4     // edgeThreshold base
                );
            }
        }

        // Then modify getGlyphPattern to use these settings
        lowp float getGlyphPattern(vec2 cell, float depth, float seed, vec2 normalizedPos) {
            // Use cellular grid position for scaling with smooth transitions
            vec2 gridPos = mod(cell, 4.0) - 2.0;
            float gridValue = max(abs(gridPos.x), abs(gridPos.y));
            
            // Add smooth falloff
            float smoothGrid = smoothstep(0.0, 2.0, gridValue);
            
            // Add time-stable noise to break up grid pattern
            float stabilityNoise = noise(floor(cell / 4.0), seed) * 0.5 + 0.5;
            
            // Combine smooth grid with stability noise
            float scaleVariation = 1.0 + (smoothGrid * 0.7 + stabilityNoise * 0.3) * u_caScaleVariation;
            vec2 scaledCell = cell * scaleVariation;
            
            // Use a smaller neighborhood for efficiency
            vec2 id = floor(scaledCell * 2.0);
            
            // Generate stable base pattern from coordinates and seed
            float basePattern = noise(id * 0.5, seed + depth * 0.1);
            
            // Number of CA iterations to perform
            const int ITERATIONS = 2;
            
            // Enhanced starting state - mix multiple patterns
            float state = step(0.5, basePattern);
            
            // Get angle and radius for geometric variations
            float angle = atan(scaledCell.y, scaledCell.x);
            float radius = length(scaledCell) * 2.0;
            
            // Add directional bias based on depth
            float dirBias = sin(angle * (depth + 1.0)) * 0.2;
            
            // Perform CA iterations
            for(int iter = 0; iter < ITERATIONS; iter++) {
                float offset = float(iter) * 0.1 + depth * 0.05;
                
                // Get settings for this iteration
                vec4 settings = getCASettings(seed, float(iter));
                float dirBiasStrength = settings.x;
                float surviveBase = settings.y;
                float birthBase = settings.z;
                float edgeBase = settings.w;
                
                // Modify directional bias using the new strength
                float dirBias = sin(angle * (depth + 1.0)) * dirBiasStrength;
                
                // Sample neighbors with directional weighting
                float n1 = noise(id + vec2(1.0, 0.0) + offset, seed);
                float n2 = noise(id + vec2(0.0, 1.0) + offset, seed);
                float n3 = noise(id + vec2(-1.0, 0.0) + offset, seed);
                float n4 = noise(id + vec2(0.0, -1.0) + offset, seed);
                
                float neighbors = step(0.4 + dirBias, n1) + 
                                 step(0.4 - dirBias, n2) + 
                                 step(0.4 + sin(angle), n3) + 
                                 step(0.4 + cos(angle), n4);
                
                float depthRule = mod(depth + float(iter), 4.0);
                
                if(depthRule < 1.0) {
                    // Enhanced Conway-like rule with modified thresholds
                    float surviveThreshold = surviveBase + sin(radius) * 0.3;
                    float birthThreshold = birthBase + cos(angle) * 0.2;
                    state = max(
                        state * step(surviveThreshold, neighbors) * step(neighbors, 3.5),
                        (1.0 - state) * step(birthThreshold, neighbors) * step(neighbors, 3.5)
                    );
                } else if(depthRule < 2.0) {
                    // Pattern formation rule with modified threshold
                    float edgeThreshold = edgeBase + sin(angle * 2.0) * 0.1;
                    state = step(edgeThreshold, abs(neighbors - 2.0 + sin(radius) * 0.5));
                } else if(depthRule < 3.0) {
                    // Growth rule with modified threshold
                    float growthThreshold = birthBase + sin(angle * 3.0 + radius) * 0.3;
                    state = max(state, step(growthThreshold, neighbors + sin(angle) * 0.5));
                } else {
                    // Dynamic rule with modified influence
                    float angleInfluence = edgeBase + 0.5 * sin(angle * 4.0 + float(iter) * 0.5);
                    float radiusInfluence = surviveBase - 1.2 + 0.2 * cos(radius * 2.0);
                    state = step(radiusInfluence + angleInfluence * 0.2, 
                                (neighbors / 4.0) + basePattern * 0.5);
                }
            }
            
            // Add geometric patterns with depth influence
            float geoPattern = smoothstep(0.4, 0.6, 
                sin(radius * (3.0 + depth * 0.5) +    // Try 2.0 to 5.0
                    angle * (4.0 + depth * 0.3) +     // Try 3.0 to 6.0
                    depth + seed) * 0.5 + 0.5
            );
            
            // Blend CA result with geometric pattern based on depth
            float blendFactor = 0.3 + 0.2 * sin(depth * 1.5);  // Try different base values 0.2 to 0.6
            float finalPattern = mix(state, geoPattern, blendFactor);
            
            // Add detail noise if enabled
            if (u_enableGlyphNoiseDetail) {
                float detail = noise(scaledCell * (depth + 1.0) * 3.0, seed + depth);
                return mix(finalPattern, detail, 0.15);
            }
            
            return finalPattern;
        }

        void main() {
            // Constants can use low precision
            const lowp int MAX_LOOP_DEPTH = 6;
            
            // Coordinate calculations need medium precision
            mediump vec2 coord = (vTexCoord * u_resolution - u_resolution * 0.25) * u_scaleFactor + u_translation;
            coord = coord / u_bS;
            
            // Grid distortion calculation can use medium precision
            mediump float gridDistortTime = u_time * u_sortAnimSpeed * 0.1;
            mediump vec2 gridDistortCoord = coord * u_sortFrequency;
            
            // Most pattern calculations can use low precision
            lowp float distortNoise1 = fbmSimplexNoise(gridDistortCoord + vec2(gridDistortTime * 0.1), 2);
            lowp float distortNoise2 = fbmSimplexNoise(gridDistortCoord + vec2(gridDistortTime * -0.15), 2);
            
            // Pattern vectors can use low precision since normalized
            lowp vec2 expPattern, stepPattern, circularPattern, squarePattern, flowPattern, smoothFlowPattern;
            
            // Pattern 1: Exponential waves
            expPattern = vec2(
                exp(-abs(mod(distortNoise1 + gridDistortTime, 2.0) - 1.0)) - 0.5,
                exp(-abs(mod(distortNoise2 + gridDistortTime, 2.0) - 1.0)) - 0.5
            );
            
            // Pattern 2: Stepped/quantized movement
            stepPattern = vec2(
                floor(distortNoise1 * 4.0) / 4.0,
                floor(distortNoise2 * 4.0) / 4.0
            );
            
            // Pattern 3: Circular/spiral movement
            float angle = distortNoise1 * 6.28318;
            circularPattern = vec2(
                cos(angle) * distortNoise2,
                sin(angle) * distortNoise2
            );
            
            // Pattern 4: Square/diamond pattern
            squarePattern = vec2(
                sign(fract(distortNoise1 * 2.0) - 0.5) * abs(fract(distortNoise2 * 2.0) - 0.5),
                sign(fract(distortNoise2 * 2.0) - 0.5) * abs(fract(distortNoise1 * 2.0) - 0.5)
            );
            
            // Pattern 5: Smooth directional flow with rotation
            flowPattern = vec2(
                distortNoise1 * cos(gridDistortTime * 0.2) - distortNoise2 * sin(gridDistortTime * 0.15),
                distortNoise1 * sin(gridDistortTime * 0.2) + distortNoise2 * cos(gridDistortTime * 0.15)
            );
            
            // Add subtle vorticity
            float vortexStrength = 0.8;  // Increased from 0.3 for stronger effect
            float vortexAngle = atan(coord.y, coord.x) + gridDistortTime * 0.1;
            vec2 vortexOffset = vec2(
                cos(vortexAngle) * length(flowPattern) * vortexStrength,
                sin(vortexAngle) * length(flowPattern) * vortexStrength
            );
            
            // Combine flow and vortex with smooth transition
            smoothFlowPattern = flowPattern + vortexOffset;
            
            // Add progressive movement (modified for more organic flow)
            float flowTime = gridDistortTime * 0.05;
            smoothFlowPattern += vec2(
                simplexNoise(vec2(flowTime * 0.7, 0.0), u_nS) * 10.0,
                simplexNoise(vec2(flowTime * 0.8, 1.0), u_nS) * 10.0
            );
            
            // Select pattern based on uniform
            vec2 finalPattern;
            if (u_currentPattern == 15) {
                // Quantum Interference Pattern
                float qTime = u_time * 0.1;
                vec2 qPos = coord * 0.01;
                float wave1 = sin(dot(qPos, vec2(cos(qTime), sin(qTime))) * 10.0);
                float wave2 = sin(dot(qPos, vec2(-sin(qTime), cos(qTime))) * 10.0);
                float interference = (wave1 + wave2) * 0.5;
                float probability = interference * interference;
                finalPattern = vec2(cos(probability * M_PI), sin(probability * M_PI)) * probability;
            }
            else if (u_currentPattern == 14) {
                // Neural Network Pattern
                float nTime = u_time * 0.05;
                vec2 nodePos = floor(coord / 50.0);
                float activation = simplexNoise(nodePos + vec2(nTime), 0.0);
                float pulse = sin(activation * 10.0 + nTime) * 0.5 + 0.5;
                vec2 direction = normalize(vec2(
                    simplexNoise(nodePos + vec2(0.0, nTime), 1.0),
                    simplexNoise(nodePos + vec2(nTime, 0.0), 1.0)
                ));
                finalPattern = direction * pulse;
            }
            else if (u_currentPattern == 13) {
                // DNA Helix Flow Pattern
                float hTime = u_time * 0.1;
                vec2 hPos = coord * 0.02;
                float twist = sin(hPos.x + hTime) * cos(hPos.y + hTime);
                float helix1 = sin(hPos.x * 2.0 + hTime + twist);
                float helix2 = sin(hPos.x * 2.0 + hTime + M_PI + twist);
                finalPattern = vec2(helix1, helix2) * 0.5;
            }
            else if (u_currentPattern == 12) {
                // Wave Function Collapse Pattern
                vec2 gridPos = floor(coord / 40.0);
                float state = simplexNoise(gridPos, u_time * 0.1);
                float collapsed = step(0.5, state);
                vec2 offset = vec2(
                    simplexNoise(gridPos + vec2(0.0, u_time * 0.1), 0.0),
                    simplexNoise(gridPos + vec2(u_time * 0.1, 0.0), 0.0)
                );
                finalPattern = offset * collapsed;
            }
            else if (u_currentPattern == 11) {
                // Wave Function Collapse Pattern
                vec2 wfcCell = floor(coord / 40.0);
                float state = simplexNoise(wfcCell, u_time * 0.1);
                float collapsed = step(0.5, state);
                vec2 offset = vec2(
                    simplexNoise(wfcCell + vec2(0.0, u_time * 0.1), 0.0),
                    simplexNoise(wfcCell + vec2(u_time * 0.1, 0.0), 0.0)
                );
                finalPattern = offset * collapsed;
            }
            else if (u_currentPattern == 10) {
                // Neural Network Pattern
                float nTime = u_time * 0.02; // Reduced from 0.05
                vec2 nodePos = floor(coord / 50.0);
                float activation = simplexNoise(nodePos + vec2(nTime), 0.0);
                float pulse = smoothstep(0.0, 1.0, sin(activation * 5.0 + nTime) * 0.5 + 0.5); // Added smoothstep and reduced frequency
                vec2 direction = normalize(vec2(
                    simplexNoise(nodePos + vec2(0.0, nTime * 0.5), 1.0), // Slowed down time
                    simplexNoise(nodePos + vec2(nTime * 0.5, 0.0), 1.0)
                ));
                finalPattern = direction * pulse;
            }
            else if (u_currentPattern == 9) {
                // DNA Helix Flow Pattern
                float hTime = u_time * 0.1;
                vec2 hPos = coord * 0.02;
                float twist = sin(hPos.x + hTime) * cos(hPos.y + hTime);
                float helix1 = sin(hPos.x * 2.0 + hTime + twist);
                float helix2 = sin(hPos.x * 2.0 + hTime + M_PI + twist);
                finalPattern = vec2(helix1, helix2) * 0.5;
            }
            else if (u_currentPattern == 8) {
                // Cellular Automata Flow Pattern with reduced flickering
                vec2 cell = floor(coord / 100.0);
                float state = simplexNoise(cell, floor(u_time * 0.2)); // Reduced from 0.8
                float nextState = simplexNoise(cell, floor(u_time * 0.2) + 1.0);
                float transition = smoothstep(0.0, 1.0, fract(u_time * 0.2)); // Added smoothstep
                float flow = mix(state, nextState, transition);
                finalPattern = vec2(
                    sin(flow * M_PI * 2.0), // Reduced from 4.0
                    cos(flow * M_PI * 2.0)
                ) * flow;
            }
            else if (u_currentPattern == 7) {
                // Cellular Automata Flow Pattern with smoother transitions
                vec2 caCell = floor(coord / 100.0);
                float state = simplexNoise(caCell + u_time * 0.05, u_nS); // Reduced from 0.2
                float nextState = simplexNoise(caCell + u_time * 0.05 + 1.0, u_nS);
                float transition = smoothstep(0.0, 1.0, fract(u_time * 0.2)); // Added smoothstep
                float flow = mix(state, nextState, transition);
                finalPattern = vec2(cos(flow * 6.28318), sin(flow * 6.28318));
            }
            else if (u_currentPattern == 6) {
                // Crystalline Growth Pattern
                vec2 crystalCell = floor(coord / 80.0);  // Changed from 160.0 to 80.0 for larger base crystals
                float growth = simplexNoise(crystalCell, 0.0);
                float angle = (floor(growth * 8.0) / 8.0) * M_PI * 2.0;
                float size = fract(growth * 8.0);
                size = smoothstep(0.2, 0.8, size) * 0.8 + 0.2;
                vec2 direction = vec2(cos(angle), sin(angle));
                float crystal = smoothstep(0.0, 0.1, 
                    abs(dot(normalize(fract(coord / 80.0) - 0.5), direction)) +
                    abs(dot(normalize(fract(coord / 80.0) - 0.5), vec2(-direction.y, direction.x)))
                );
                finalPattern = direction * crystal * size;
            }
            else if (u_currentPattern == 5) {
                finalPattern = smoothFlowPattern;
            } else if (u_currentPattern == 0) {
                // Mixed patterns with smooth transitions
                float patternMix = fract(gridDistortTime * 0.1);
                finalPattern = mix(
                    mix(expPattern, stepPattern, smoothstep(0.0, 0.33, patternMix)),
                    mix(circularPattern, squarePattern, smoothstep(0.66, 1.0, patternMix)),
                    smoothstep(0.33, 0.66, patternMix)
                );
            } else if (u_currentPattern == 1) {
                finalPattern = expPattern;
            } else if (u_currentPattern == 2) {
                finalPattern = stepPattern;
            } else if (u_currentPattern == 3) {
                finalPattern = circularPattern;
            } else {
                finalPattern = squarePattern;
            }
            
            // Apply grid distortion only if enabled
            mediump vec2 gridOffset = vec2(0.0);
            if (u_enableGridDistort) {
                gridOffset = finalPattern * u_sortStrength * u_cellSize;
                // Apply distortion to coordinates before grid calculation
                coord += gridOffset * (1.0 + sin(gridDistortTime) * 0.3);
            }
            
            vec2 gridCoord = floor(coord / u_cellSize);
            vec2 cellCenter = (gridCoord + 0.5) * u_cellSize;
            vec2 localPos = coord - cellCenter;

        // Cell boundary check can use lower precision
        lowp float cellBoundary = u_cellSize * 0.485;
        lowp float edgeFade = 0.005;
        bool isWithinCell = all(lessThanEqual(abs(localPos), vec2(cellBoundary)));
        if (!isWithinCell) {
            // Smooth edge transition
            vec2 edgeDistance = abs(localPos) - vec2(cellBoundary);
            float fadeAlpha = 1.0 - smoothstep(0.0, edgeFade, max(edgeDistance.x, edgeDistance.y));
            if (fadeAlpha <= 0.0) discard;
        }

            // Pre-calculate values needed for the depth loop
            float distToCenter = length(coord - cellCenter);
            float timeScale = u_time * 0.1;
            vec2 baseNoiseCoord = gridCoord * 0.1;
            vec2 timeOffset = vec2(timeScale, timeScale + 100.0);
            
            // Calculate distortion influence once
            float distortionInfluence = length(gridOffset) / (u_cellSize * 2.0);
            float baseNoiseFBM = fbmSimplexNoise(gridCoord * (u_cellSize / u_resolution.y) * 0.05, 4) + distortionInfluence * 0.2;
            
            vec2 noiseOffset = vec2(
                noise(baseNoiseCoord + timeOffset.xx, u_nS),
                noise(baseNoiseCoord + timeOffset.yy, u_nS)
            );
            
            // Pre-calculate common values for the loop
            float gridSize = u_cellSize * mix(0.3, 2.5, baseNoiseFBM + distortionInfluence * 0.2);
            vec2 localCoord = mod(coord + noiseOffset, gridSize);
            
            float randomAngle = floor(noise(gridCoord + noiseOffset, u_nS) * 4.0) * (M_PI * 0.5);
            float sinA = fastSin(randomAngle);
            float cosA = fastCos(randomAngle);
            vec2 rotatedCoord = vec2(
                localCoord.x * cosA - localCoord.y * sinA,
                localCoord.x * sinA + localCoord.y * cosA
            );
            
            float smoothedTime = u_time * 0.01 + simplexNoise(vec2(u_time * 0.3, 50.0), u_nS) * 0.005;
            
            vec2 noiseInput1 = rotatedCoord * ((u_cellSize / u_resolution.y) * 1.0) + smoothedTime;
            vec2 noiseInput2 = (rotatedCoord + gridCoord * gridSize) * ((u_cellSize / u_resolution.y) * 1.0) * u_noiseScale;
            
            float flowNoise = fbmSimplexNoise(noiseInput1, 6);
            vec2 animatedCoord = noiseInput2 + vec2(
                simplexNoise(vec2(flowNoise, u_time * 0.05), u_nS),
                simplexNoise(vec2(flowNoise, u_time * 0.05 + 100.0), u_nS)
            ) * u_flowSpeed * 0.005;
            
            float curlNoise = fbmSimplexNoise(animatedCoord * (u_cellSize / u_resolution.y) * 20.0 + vec2(u_nS), 8);
            animatedCoord += 4.0 * vec2(
                cos(curlNoise * 6.28318),
                sin(curlNoise * 6.28318)
            );
            
            // Color blending can use low precision
            lowp vec4 color = vec4(0.0);
            
            // Main loop variables
            mediump float depthNoiseValue, depthFactor, colorT;
            lowp vec3 color1, color2, enhancedColor1, enhancedColor2, blendedColor;
            
            // Calculate base noise values that won't change in the loop
            float baseNoise = fbmSimplexNoise(animatedCoord * (u_cellSize / u_resolution.y) * 0.15 + noiseOffset, 4);
            float combinedNoise = (baseNoise * 0.3 + baseNoiseFBM * 0.7 + 3.0) * 0.3;
            
            // Calculate depth once
            float clampedNoise = clamp(combinedNoise, 0.0, 1.0);
            int dynamicDepth = int(clamp(
                clampedNoise * float(u_maxDepth),
                1.0,
                min(float(u_maxDepth), float(MAX_LOOP_DEPTH))
            ));
            
            // Pre-calculate threshold and blend factor outside loop
            float threshold = 0.55 - (0.15 * pow(1.0 - u_bS, 2.0));
            
            float t = simplexNoise(vec2(u_time * 0.01), 0.0) * 0.5 + 0.5;
            float angleInfluence = simplexNoise(vec2(u_time * 0.005), 0.0) * 0.5 + 0.5;
            float blendFactor = t * t * (3.0 - 2.0 * t) * (1.0 + combinedNoise * 0.8 + angleInfluence * 1.2);
            
            // Get flow direction for current cell
            vec2 flowDir = getFlowDirection(cellCenter, u_time);
            float flowAngle = atan(flowDir.y, flowDir.x);
            float flowStrength = length(flowDir);
            
            // Process each depth level with minimal branching
            for (int depth = 0; depth < MAX_LOOP_DEPTH; depth++) {
                // Break condition at the top to avoid unnecessary loop iterations
                if (depth >= dynamicDepth) break;
                
                // Add temporal stability to noise value
                float timeStability = smoothstep(0.0, 1.0, sin(u_time * 0.1 + float(depth)) * 0.5 + 0.5);
                depthNoiseValue = mix(
                    depthNoiseValue,
                    noise(animatedCoord * float(depth + 1), u_nS),
                    timeStability
                );
                depthFactor = float(depth) / float(MAX_LOOP_DEPTH);
                
                // Smooth threshold check with hysteresis
                float smoothThreshold = threshold + 0.05 * sin(u_time * 0.05 + float(depth));
                if (depthNoiseValue <= smoothThreshold - 0.1) {
                    continue;
                }
                
                // Get glyph parameters with temporal stability
                float currentSize = mix(0.3, 0.99, depthFactor) * u_cellSize;
                
                // Pattern-specific modifications
                vec2 patternOffset = vec2(0.0);
                float patternRotation = 0.0;
                float patternScale = 1.0;

                // Apply pattern-specific behavior
                if (u_currentPattern == 0) {
                    // Mixed pattern with randomized center
                    float angle = simplexNoise(vec2(111.111, u_nS), 0.0) * M_PI * 2.0;
                    float distance = mix(10000.0, 20000.0, simplexNoise(vec2(222.222, u_nS), 0.0));
                    vec2 randomCenter = vec2(cos(angle), sin(angle)) * distance;
                    vec2 centeredPos = coord - randomCenter;
                    float t = fract(u_time * 0.1);
                    patternOffset = vec2(
                        sin(u_time * 0.2 + centeredPos.x * 0.01),
                        cos(u_time * 0.2 + centeredPos.y * 0.01)
                    ) * flowStrength;
                    patternRotation = sin(u_time * 0.1) * 3.14159;
                    patternScale = 1.0 + 0.5 * sin(u_time * 0.15);
                }
                else if (u_currentPattern == 1) {
                    // Exponential waves with randomized center
                    float angle = simplexNoise(vec2(333.333, u_nS), 0.0) * M_PI * 2.0;
                    float distance = mix(10000.0, 20000.0, simplexNoise(vec2(444.444, u_nS), 0.0));
                    vec2 randomCenter = vec2(cos(angle), sin(angle)) * distance;
                    vec2 centeredPos = coord - randomCenter;
                    float wave = exp(-length(centeredPos) * 0.01);
                    patternOffset = normalize(centeredPos) * wave * 2.0;
                    patternRotation = atan(centeredPos.y, centeredPos.x) * 2.0;
                    patternScale = 1.0 + wave * 0.5;
                }
                else if (u_currentPattern == 2) {
                    // Stepped pattern with randomized center
                    float angle = simplexNoise(vec2(555.555, u_nS), 0.0) * M_PI * 2.0;
                    float distance = mix(10000.0, 20000.0, simplexNoise(vec2(666.666, u_nS), 0.0));
                    vec2 randomCenter = vec2(cos(angle), sin(angle)) * distance;
                    vec2 centeredPos = coord - randomCenter;
                    float gridScale = 4.0;
                    vec2 smoothFlow = normalize(centeredPos) * gridScale;
                    float timeScale = u_time * 0.1;
                    vec2 temporalOffset = vec2(
                        simplexNoise(vec2(timeScale * 0.7, 0.0), 0.0),
                        simplexNoise(vec2(timeScale * 0.8, 1.0), 0.0)
                    ) * 0.1;
                    vec2 stepped = floor(smoothFlow + 0.5 + temporalOffset) / gridScale;
                    float smoothFactor = 0.2;
                    vec2 smoothStepped = mix(
                        stepped,
                        smoothFlow / gridScale,
                        smoothFactor + 0.1 * sin(timeScale)
                    );
                    float baseRotation = atan(centeredPos.y, centeredPos.x) * 4.0;
                    float smoothRotation = floor(baseRotation / M_PI + 0.5) * M_PI / 4.0;
                    patternRotation = mix(smoothRotation, baseRotation, smoothFactor);
                    patternOffset = smoothStepped * 2.0;
                    patternScale = 1.0 + smoothstep(0.0, 1.0, length(smoothFlow)) * 2.0;
                }
                else if (u_currentPattern == 3) {
                    // Circular pattern with randomized center
                    float angle = simplexNoise(vec2(123.456, u_nS), 0.0) * M_PI * 2.0;
                    float distance = mix(10000.0, 20000.0, simplexNoise(vec2(789.012, u_nS), 0.0));
                    vec2 randomCenter = vec2(cos(angle), sin(angle)) * distance;
                    vec2 centeredPos = coord - randomCenter;
                    float patternAngle = atan(centeredPos.y, centeredPos.x);
                    float dist = length(centeredPos);
                    patternOffset = vec2(cos(patternAngle + u_time), sin(patternAngle + u_time)) * dist * 0.01;
                    patternRotation = patternAngle + u_time;
                    patternScale = 1.0 + 0.5 * sin(dist * 0.01);
                }
                else if (u_currentPattern == 4) {
                    // Square/Diamond pattern with randomized center
                    float angle = simplexNoise(vec2(345.678, u_nS), 0.0) * M_PI * 2.0;
                    float distance = mix(10000.0, 20000.0, simplexNoise(vec2(901.234, u_nS), 0.0));
                    vec2 randomCenter = vec2(cos(angle), sin(angle)) * distance;
                    vec2 centeredPos = coord - randomCenter;
                    vec2 gridPos = floor(centeredPos / 100.0 + 0.5) * 100.0;
                    float gridAngle = atan(gridPos.y, gridPos.x);
                    patternOffset = normalize(gridPos) * length(gridPos) * 0.002;
                    patternRotation = gridAngle + u_time * 0.5;
                    patternScale = 1.0 + 0.3 * sin(length(gridPos) * 0.001 + u_time);
                }
                else if (u_currentPattern == 5) {
                    // Smooth Flow pattern with randomized center
                    float angle = simplexNoise(vec2(567.890, u_nS), 0.0) * M_PI * 2.0;
                    float distance = mix(10000.0, 20000.0, simplexNoise(vec2(123.456, u_nS), 0.0));
                    vec2 randomCenter = vec2(cos(angle), sin(angle)) * distance;
                    vec2 centeredPos = coord - randomCenter;
                    vec2 flowDir = normalize(centeredPos);
                    float flowTime = u_time * 0.2;
                    vec2 flowOffset = vec2(
                        simplexNoise(vec2(flowTime * 0.7, 0.0), 0.0),
                        simplexNoise(vec2(flowTime * 0.8, 1.0), 0.0)
                    );
                    patternOffset = flowDir * length(centeredPos) * 0.002 + flowOffset * 2.0;
                    patternRotation = atan(flowDir.y, flowDir.x) + flowTime;
                    patternScale = 1.0 + 0.3 * sin(length(centeredPos) * 0.001);
                }
                else if (u_currentPattern == 6) {
                    // Crystalline Growth pattern with randomized center
                    float angle = simplexNoise(vec2(789.012, u_nS), 0.0) * M_PI * 2.0;
                    float distance = mix(10000.0, 20000.0, simplexNoise(vec2(345.678, u_nS), 0.0));
                    vec2 randomCenter = vec2(cos(angle), sin(angle)) * distance;
                    vec2 centeredPos = coord - randomCenter;
                    float crystalAngle = atan(centeredPos.y, centeredPos.x);
                    float crystalPattern = floor(crystalAngle * 6.0) / 6.0 * 2.0 * M_PI;
                    vec2 crystalDir = vec2(cos(crystalPattern), sin(crystalPattern));
                    patternOffset = crystalDir * length(centeredPos) * 0.002;
                    patternRotation = crystalPattern + u_time * 0.1;
                    patternScale = 1.0 + 0.4 * step(0.8, fract(length(centeredPos) * 0.001));
                }
                else if (u_currentPattern == 7) {
                    // Cellular Automata Flow pattern with randomized center
                    float angle = simplexNoise(vec2(901.234, u_nS), 0.0) * M_PI * 2.0;
                    float distance = mix(10000.0, 20000.0, simplexNoise(vec2(567.890, u_nS), 0.0));
                    vec2 randomCenter = vec2(cos(angle), sin(angle)) * distance;
                    vec2 centeredPos = coord - randomCenter;
                    vec2 cellPos = floor(centeredPos / 50.0) * 50.0;
                    float cellNoise = simplexNoise(cellPos * 0.01 + u_time * 0.1, 0.0);
                    patternOffset = normalize(cellPos) * length(cellPos) * 0.002 * cellNoise;
                    patternRotation = atan(cellPos.y, cellPos.x) + cellNoise * M_PI;
                    patternScale = 1.0 + 0.3 * step(0.5, cellNoise);
                }
                else if (u_currentPattern == 8) {
                    // DNA Helix Flow pattern with randomized center
                    float angle = simplexNoise(vec2(123.456, u_nS), 0.0) * M_PI * 2.0;
                    float distance = mix(10000.0, 20000.0, simplexNoise(vec2(789.012, u_nS), 0.0));
                    vec2 randomCenter = vec2(cos(angle), sin(angle)) * distance;
                    vec2 centeredPos = coord - randomCenter;
                    float dist = length(centeredPos);
                    float helixAngle = atan(centeredPos.y, centeredPos.x);
                    float helix = sin(helixAngle * 2.0 + u_time + dist * 0.01);
                    patternOffset = vec2(cos(helixAngle), sin(helixAngle)) * dist * 0.002 * (1.0 + helix * 0.5);
                    patternRotation = helixAngle + helix * M_PI * 0.25;
                    patternScale = 1.0 + 0.3 * helix;
                }
                else if (u_currentPattern == 9) {
                    // Neural Network pattern with randomized center
                    float angle = simplexNoise(vec2(345.678, u_nS), 0.0) * M_PI * 2.0;
                    float distance = mix(10000.0, 20000.0, simplexNoise(vec2(901.234, u_nS), 0.0));
                    vec2 randomCenter = vec2(cos(angle), sin(angle)) * distance;
                    vec2 centeredPos = coord - randomCenter;
                    vec2 nodePos = floor(centeredPos / 100.0 + 0.5) * 100.0;
                    float nodeTime = u_time * 0.2 + length(nodePos) * 0.01;
                    float activation = sin(nodeTime) * 0.5 + 0.5;
                    patternOffset = normalize(nodePos) * length(nodePos) * 0.002 * activation;
                    patternRotation = atan(nodePos.y, nodePos.x) + activation * M_PI;
                    patternScale = 1.0 + 0.3 * activation;
                }
                else if (u_currentPattern == 10) {
                    // Wave Function Collapse pattern with randomized center
                    float angle = simplexNoise(vec2(567.890, u_nS), 0.0) * M_PI * 2.0;
                    float distance = mix(10000.0, 20000.0, simplexNoise(vec2(123.456, u_nS), 0.0));
                    vec2 randomCenter = vec2(cos(angle), sin(angle)) * distance;
                    vec2 centeredPos = coord - randomCenter;
                    vec2 wavePos = floor(centeredPos / 75.0) * 75.0;
                    float waveState = simplexNoise(wavePos * 0.01, u_time * 0.1);
                    vec2 waveDir = normalize(wavePos);
                    patternOffset = waveDir * length(wavePos) * 0.002 * waveState;
                    patternRotation = atan(waveDir.y, waveDir.x) + waveState * M_PI * 2.0;
                    patternScale = 1.0 + 0.4 * step(0.7, waveState);
                }
                else {
                    // Smooth flow
                    patternOffset = flowDir * 2.0;
                    patternRotation = flowAngle;
                    patternScale = 1.0 + flowStrength * 0.5;
                }

                // Apply pattern modifications to rotatedP calculation
                vec2 rotatedP = vec2(
                    localPos.x * cos(-flowAngle - patternRotation) - localPos.y * sin(-flowAngle - patternRotation),
                    localPos.x * sin(-flowAngle - patternRotation) + localPos.y * cos(-flowAngle - patternRotation)
                );
                rotatedP = rotatedP * patternScale + patternOffset;

                // Calculate glyph cell with pattern influence
                float mappedOffset = mix(0.5, 1.2, flowStrength);
                vec2 glyphCell = floor(rotatedP / currentSize + mappedOffset);
                vec2 localGlyphPos = rotatedP - glyphCell * currentSize;
                
                // Get glyph pattern
                float glyphNoise = getGlyphPattern(glyphCell, float(depth), u_nS, vTexCoord);
                
                // Simplified glyph checks
                bool centerActive = abs(glyphCell.x) < 0.5 && abs(glyphCell.y) < 0.5;
                bool noiseActive = length(glyphCell) < 1.5 && glyphNoise > 0.5;
                bool lineActive = abs(localGlyphPos.x) < currentSize * 0.15 || abs(localGlyphPos.y) < currentSize * 0.15;
                
                bool insideGlyph = centerActive || noiseActive || lineActive;
                
                // Skip if not inside glyph
                if (!insideGlyph) {
                    continue;
                }
                
                // Color calculation with temporal smoothing
                float edge0 = 0.2 + sin(u_time * 0.0001) * 0.3; // Slower time scale
                float edge1 = 0.8 + cos(u_time * 0.0001) * 0.5; // Slower time scale
                colorT = smoothstep(edge0, edge1, depthFactor + combinedNoise * 0.9);
                
                color1 = getColorFromPalette(colorT);
                color2 = getColorFromPalette(1.0 - colorT);
                
                // Apply depth boost with temporal smoothing
                float depthBoost = 1.2 + (1.0 - depthFactor) * 0.8 * (0.9 + 0.1 * sin(u_time * 0.1));
                color1 *= depthBoost;
                color2 *= depthBoost;
                
                enhancedColor1 = enhanceColor(color1, combinedNoise);
                enhancedColor2 = enhanceColor(color2, combinedNoise);
                
                blendedColor = blendColors(enhancedColor1, enhancedColor2, blendFactor);
                
                // Smoother color blending with temporal stability
                float blendStability = smoothstep(0.3, 0.7, depthNoiseValue);
                color += vec4(blendedColor, 1.0) * (blendStability * (0.8 + 0.2 * sin(u_time * 0.05 + float(depth))));
            }
            
            // Final color check
            if (color.a == 0.0) {
                color = u_baseColor;
            }
            
            gl_FragColor = color;
        }
    </script>

    <script>
        let bS = 1.0;     
        const cV = 6;  
        let tS;
        let dM = 0;
        let cS;      
        let bN = 0.002;  
        let nS;
    let fS = 0.01;     // Increased from 0.005
        let rSS;
        let roA;
        let nOX, nOY;
        let scF = 30;
        let tX = 0, tY = 0;
        let iTX = 0, iTY = 0;
        let pMX, pMY;
        let amV = [0.1, 0.075, 0.05]; 
        let isP = true;
        let stT = 0;
        let cuT = 0;
        let lum = 1.5;
        let vib = 2.5;
    let soS = 0.2;     // Increased from 0.1
        let soF = 0.1;   
    let soA = 0.3;     // Increased from 0.15
        let cuP;                  
    let isPanLocked = false;  // Add pan lock state variable
        
        let tog = {
            layN: true,
            flF: true,
            glN: true,
            glND: true,
            glD: true
        };

        let inscription_id = window.location.pathname.split("/").pop();
        
        // REMOVE AFTER TESTING!!!
            let chars = "0123456789abcdefghijklmnopqrstuvwsyz";
            inscription_id = new URLSearchParams(window.location.search).get("seed") || Array(64).fill(0).map(_=>chars[(Math.random()*chars.length)|0]).join('');
        // REMOVE AFTER TESTING!!!



        class Rnd{
            constructor(seed) {
                const i=Math.imul,h=t=>{let e,l=0;for(e=1779033703^t.length;l<t.length;l++){let h=e^t.charCodeAt(l);e=i(h,3432918353),e=e<<13|e>>>19}return()=>(e=i(e^e>>>16,2246822507),e=i(e^e>>>13,3266489909),(e^=e>>>16)>>>0)},a=(e,r,t,a)=>()=>{let l=((e|=0)+(r|=0)|0)+(a|=0)|0;return a=a+1|0,e=r^r>>>9,r=(t|=0)+(t<<3)|0,t=(t=t<<21|t>>>11)+l|0,(l>>>0)/4294967296},X=h(seed);this.R=a(X(),X());
            }
            D=_=>this.R();                  
            N=(r,t)=>r+(t-r)*this.D();     
            I=(r,t)=>0|this.N(r,t+1);      
            B=r=>this.D()<r               
        };
        let R = new Rnd(inscription_id)

        console.log('Inscription ID:', inscription_id)


        function upTC() {
            // Store current center position relative to the current view
            let currentCenterX = tX + width/2;
            let currentCenterY = tY + height/2;
            
            let viW = width / scF;
            let viH = height / scF;
            
            // Calculate new translation to maintain the same center position
            tX = currentCenterX - width/2;
            tY = currentCenterY - height/2;
        }

        function preload() {
            let vertexShader = document.getElementById('vertex-shader').textContent;
            let fragmentShader = document.getElementById('fragment-shader').textContent;
            tS = createShader(vertexShader, fragmentShader);
        }

        function suEH() {
            const canvas = document.querySelector('canvas');
            const keyState = new Set();
            
            document.addEventListener('keydown', (e) => {
                if (keyState.has(e.key)) return;
                keyState.add(e.key);
                
                switch(e.key.toLowerCase()) {
                    case 'a':
                        dM = (dM + 1) % 4;  // Changed from % 3 to % 4 to handle four modes
                        console.log('Display mode:', 
                            dM === 0 ? 'Full Screen' :
                            dM === 1 ? '2:3 Aspect Ratio' :
                            dM === 2 ? '1:1 Square' :
                            '3:2 Aspect Ratio'
                        );
                        upCS();
                        break;
                        
                    case 'r':
                    // Modified reset to respect lock
                    if (!isPanLocked) {
                        tX = iTX;
                        tY = iTY;
                        scF = 30;
                        upTC();
                    } else {
                        console.log('Cannot reset while pan is locked');
                    }
                    break;
                    
                case 'l':
                    // Toggle pan lock
                    isPanLocked = !isPanLocked;
                    console.log('Pan position ' + (isPanLocked ? 'locked' : 'unlocked'));
                        break;
                        
                    case 's':
                        isP = !isP;
                        if (isP) {
                            stT = millis() * 0.1;
                        } else {
                            cuT = (millis() - stT) / 1000.0;
                        }
                        break;
                        
                    case '1':
                    case '2':
                    case '3':
                        {  
                            const cuD = pixelDensity();
                            const nwD = e.key === '1' ? 4 : (e.key === '2' ? 5 : 5.5);
                            
                            
                            pixelDensity(nwD);
                            draw();
                            
                           
                            const tiS = geT();
                            const prefix = e.key === '1' ? 'shader_' : 'shader_hires_';
                            saveCanvas(prefix + tiS, 'png');
                            
                            
                            pixelDensity(cuD);
                            draw();
                            break;  
                        }
                        
                    case 'd':
                        
                        if (scF === 30) {
                            scF = 10;
                        } else {
                            scF = 30;
                        }
                        upTC();
                        break;
                        
                    
                    case 'k':
                        if (!isR) {
                            stRe();
                        } else {
                            noRe();
                        }
                        break;
                
                case 'p':
                    // Cycle through patterns
                    cuP = (cuP + 1) % 11;  // Updated from 16 to 11 patterns
                    console.log('Pattern:', 
                        cuP === 0 ? 'Mixed' :
                        cuP === 1 ? 'Exponential Waves' :
                        cuP === 2 ? 'Stepped' :
                        cuP === 3 ? 'Circular' :
                        cuP === 4 ? 'Square/Diamond' :
                        cuP === 5 ? 'Smooth Flow' :
                        cuP === 6 ? 'Crystalline Growth' :
                        cuP === 7 ? 'Cellular Automata Flow' :
                        cuP === 8 ? 'DNA Helix Flow' :
                        cuP === 9 ? 'Neural Network' :
                        'Wave Function Collapse'
                    );
                    tS.setUniform('u_currentPattern', cuP);
                        break;
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keyState.delete(e.key);
            });
        }

        
        function geT() {
            const d = new Date();
            const pad = n => n.toString().padStart(2, '0');
            return `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
        }

        function setup() {
            
            let canvas = createCanvas(windowWidth, windowHeight, WEBGL);
            
            
            let gl = canvas.GL;
            gl.disable(gl.DEPTH_TEST);  
            gl.disable(gl.CULL_FACE);   
            gl.disable(gl.DITHER);      
            gl.disable(gl.STENCIL_TEST);
            
            
            pixelDensity(2);
            
            
            noStroke();
            shader(tS);
            
            
            
            if (!inscription_id) {
                return;
            }
            
            
        cuP = R.I(0, 10);  // Random integer between 0 and 10 (11 patterns total)
        console.log('Pattern:', 
            cuP === 0 ? 'Mixed' :
            cuP === 1 ? 'Exponential Waves' :
            cuP === 2 ? 'Stepped' :
            cuP === 3 ? 'Circular' :
            cuP === 4 ? 'Square/Diamond' :
            cuP === 5 ? 'Smooth Flow' :
            cuP === 6 ? 'Crystalline Growth' :
            cuP === 7 ? 'Cellular Automata Flow' :
            cuP === 8 ? 'DNA Helix Flow' :
            cuP === 9 ? 'Neural Network' :
            'Wave Function Collapse'
        );
            
            
            tS = createShader(
                document.getElementById('vertex-shader').textContent,
                document.getElementById('fragment-shader').textContent
            );
            shader(tS);
            tS.setUniform('u_currentPattern', cuP);
            
            upCS();
            
            nOX = R.I(0,2000)
            nOY = R.I(0,2000)

            let shiftX = -width/2;
            let shiftY = -height/2;
            iTX = shiftX;
            iTY = shiftY;
            tX = shiftX;
            tY = shiftY;

            nS = R.I(0,1000)

            rSS = R.I(0,1000)

            roA = R.I(0, 360)
            
            let teR = R.I(0, amV.length - 1);
            let raA = amV[teR];

            
            let inF = [0.0005, 0.0001, 0.005];
            let seF = inF[R.I(0,2)];

            
            cS = windowHeight / cV;

            
            let noSO = [0.001, 0.0008, 0.0012];
            bN = noSO[R.I(0, 2)];  

            let baM = R.N(0.5, 2.0);  

            
            function caCD(color1, color2) {
                
                const dr = color1[0] - color2[0];
                const dg = color1[1] - color2[1];
                const db = color1[2] - color2[2];
                return Math.sqrt(dr * dr + dg * dg + db * db);
            }

            function geRC(brightnessType = 'light', baseHue = null, existingColors = []) {
                const miCD = 0.3;
                let at = 0;
                const maA = 10;

                while (at < maA) {
                    
                    let h;
                    if (brightnessType === 'mid' && baseHue !== null) {
                        
                        h = (baseHue + 0.5) % 1.0;
} else {
                        h = R.D();  
                    }

                    let s = R.N(0.8, 1.0);  
                    let v;
                    
                    
                    switch(brightnessType) {
                        case 'dark':
                            v = R.N(0.15, 0.3);  
                            break;
                        case 'mid':
                            v = R.N(0.5, 0.65);  
                            break;
                        case 'light':
                            v = R.N(0.85, 1.0);  
                            break;
                    }

                    
                    let i = Math.floor(h * 6);
                    let f = h * 6 - i;
                    let p = v * (1 - s);
                    let q = v * (1 - f * s);
                    let t = v * (1 - (1 - f) * s);

                    let r, g, b;
                    switch (i % 6) {
                        case 0: r = v, g = t, b = p; break;
                        case 1: r = q, g = v, b = p; break;
                        case 2: r = p, g = v, b = t; break;
                        case 3: r = p, g = q, b = v; break;
                        case 4: r = t, g = p, b = v; break;
                        case 5: r = v, g = p, b = q; break;
                    }

                    const newColor = [r, g, b];

                   
                    let diC = true;
                    for (const existingColor of existingColors) {
                        if (caCD(newColor, existingColor) < miCD) {
                            diC = false;
                            break;
                        }
                    }

                    if (diC || at === maA - 1) {
                        return { color: newColor, hue: h };
                    }

                    at++;
                }
            }

            
            let liR = geRC('light', null, []);
            let rC1 = liR.color;  
            
            let miR = geRC('mid', liR.hue, [rC1]);
            let rC2 = miR.color;  
            
            let rC3 = geRC('dark', null, [rC1, rC2]).color;  

            
            let baC = [
                [0.05, 0.05, 0.05, 1.0],  
                [0.90, 0.87, 0.82, 1.0]    
            ];

            
            let sBaC = baC[R.D() < 0.6 ? 0 : 1];
            let liBc = sBaC[0] > 0.5;

            tS.setUniform('u_nS', nS);
            tS.setUniform('u_rSS', rSS);
            tS.setUniform('u_roA', radians(roA));
            tS.setUniform('u_nOS', [nOX, nOY]);
            tS.setUniform('u_amplitude', raA);
            tS.setUniform('u_maxDepth', 6);
            tS.setUniform('u_luminosity', lum);
            tS.setUniform('u_vibrancy', vib);
            tS.setUniform('u_initialFreq', seF);
            tS.setUniform('u_sortStrength', soS);
            tS.setUniform('u_sortFrequency', soF);
            tS.setUniform('u_sortAnimSpeed', soA);
            tS.setUniform('u_baseModulation', baM);
            tS.setUniform('u_baseColor', sBaC);
            tS.setUniform('u_isLightBackground', liBc);
            tS.setUniform('u_randomColor1', rC1);
            tS.setUniform('u_randomColor2', rC2);
            tS.setUniform('u_randomColor3', rC3);

            scF = 30;
            upTC();

            suEH();

            stT = millis();  

            
            let cASV = R.N(1.5, 3.0);  
            tS.setUniform('u_caScaleVariation', cASV);
        }

        function draw() {
            clear();
            background(0);  
            
            if (isP) {
            // Smooth time update with lerping
            let targetTime = (millis() - stT) / 1000.0;
            cuT = cuT * 0.9 + targetTime * 0.1; // Smooth lerp
            }

        if (mouseIsPressed && mouseButton === LEFT && !isPanLocked) {
                if (pMX !== undefined && pMY !== undefined) {
                    let deltaX = mouseX - pMX;
                    let deltaY = mouseY - pMY;
                    
                    tX -= deltaX * (scF / 5);
                    tY += deltaY * (scF / 5);
                }
                pMX = mouseX;
                pMY = mouseY;
            } else {
                pMX = undefined;
                pMY = undefined;
            }

        // Smooth the time value for shader
            let scT = cuT; 

        // Add time smoothing for animation
        let smoothTimeScale = 0.00001; // Reduce the base time scale
        scT *= smoothTimeScale;
            
        // Update uniforms with smoothed time
            tS.setUniform('u_bS', bS);
            tS.setUniform('u_scaleFactor', scF);
            tS.setUniform('u_translation', [tX, tY]);
            tS.setUniform('u_resolution', [width, height]);
        tS.setUniform('u_time', scT * 10000.0); // Scale back up for shader
            tS.setUniform('u_cellSize', (height / cV) * bS);
            tS.setUniform('u_flowSpeed', fS);
            tS.setUniform('u_luminosity', lum);
            tS.setUniform('u_vibrancy', vib);
            tS.setUniform('u_sortStrength', soS);
            tS.setUniform('u_sortFrequency', soF);
            tS.setUniform('u_sortAnimSpeed', soA);
            tS.setUniform('u_currentPattern', cuP);

            
            let cSP = height / cV;
            let dySN = bN * (100.0 / floor(cSP)); 
            tS.setUniform('u_noiseScale', dySN);

            
            tS.setUniform('u_caScaleVariation', 0.5);  

            beginShape();
            vertex(0, 0, 0, 0, 0);
            vertex(2, 0, 0, 1, 0);
            vertex(2, 2, 0, 1, 1);
            vertex(0, 2, 0, 0, 1);
            endShape(CLOSE);

            
            if (isR && (millis() - reST > reDu)) {
                noRe();
            }
        }

        

        function upCS() {
            // Store current center position relative to the current view
            let currentCenterX = tX + width/2;
            let currentCenterY = tY + height/2;
            
            const wiR = windowWidth / windowHeight;
            let neW, neH;
            
            switch(dM) {
                case 0: // Full screen
                    neW = windowWidth;
                    neH = windowHeight;
                    break;
                
                case 1: // 2:3 aspect ratio
                    if (wiR > 2/3) {
                        neH = windowHeight;
                        neW = (windowHeight * 2) / 3;
                    } else {
                        neW = windowWidth;
                        neH = (windowWidth * 3) / 2;
                    }
                    break;
                
                case 2: // 1:1 aspect ratio (square)
                    if (wiR > 1) {
                        neH = windowHeight;
                        neW = windowHeight;
                    } else {
                        neW = windowWidth;
                        neH = windowWidth;
                    }
                    break;
                
                case 3: // 3:2 aspect ratio
                    if (wiR > 3/2) {
                        neH = windowHeight;
                        neW = (windowHeight * 3) / 2;
                    } else {
                        neW = windowWidth;
                        neH = (windowWidth * 2) / 3;
                    }
                    break;
            }
           
            if (width !== neW || height !== neH) {
                resizeCanvas(neW, neH);
                
                // Calculate new translation to maintain the same center position
                tX = currentCenterX - neW/2;
                tY = currentCenterY - neH/2;
                
            let canvas = document.querySelector('canvas');
                canvas.style.cssText = 'position:absolute;left:50%;top:50%;transform:translate(-50%,-50%)';
            }
        }

        
        let reTO;
        function windowResized() {
            clearTimeout(reTO);
            reTO = setTimeout(upCS, 100);
        }

        
        let meR;
        let reCN = [];
        let isR = false;
        let reST;
        const reDu = 30000; 

        // Add these new functions
        function stRe() {
            reCN = [];
            const stream = document.querySelector('canvas').captureStream(60); 
            meR = new MediaRecorder(stream, {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 50000000 
            });

            meR.ondataavailable = (e) => {
                if (e.data.size > 0) {
                    reCN.push(e.data);
                }
            };

            meR.onstop = saRe;

            meR.start();
            isR = true;
            reST = millis();
        }

        function noRe() {
            meR.stop();
            isR = false;
        }

        function saRe() {
            const blob = new Blob(reCN, {
                type: 'video/webm'
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const timestamp = geT();
            
            a.style.display = 'none';
            a.href = url;
            a.download = `shader_recording_${timestamp}.webm`;
            
            document.body.appendChild(a);
            a.click();
            
            // Cleanup
            setTimeout(() => {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 100);
        }
    </script>
  </body>
</html>
