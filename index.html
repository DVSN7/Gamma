<!DOCTYPE html>
<html>
  <head>
    <title>Shader Art</title>
    <script src="https://ordinals.com/content/7e37766541506810ba6399c4b2735121f508bd9209df43dd200bf2316b014594i0"></script>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000;
        }
        canvas {
            width: 100% !important;
            height: 100% !important;
            object-fit: contain !important;
            max-width: 100vw;
            max-height: 100vh;
        }
        main {
            display: flex;
            justify-content: center;
            width: 100%;
            align-items: center;
            height: 100%;
        }
    </style>
  </head>
  <body>
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec3 aPosition;
        attribute vec2 aTexCoord;
        varying vec2 vTexCoord;

        void main() {
            vTexCoord = aTexCoord;
            vec4 positionVec4 = vec4(aPosition, 1.0);
            positionVec4.xy = positionVec4.xy * 2.0 - 1.0;
            gl_Position = positionVec4;
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        precision lowp int;  // Integer precision can be low for most operations
        #endif

        #define M_PI 3.14159265358979323846

        varying vec2 vTexCoord;
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float u_cellSize;
        uniform float u_noiseScale;
        uniform float u_maxDepth;
        uniform float u_flowSpeed;
        uniform float u_nS;
        uniform float u_rSS;
        uniform float u_roA;
        uniform vec2 u_nOS;
        uniform float u_amplitude;
        uniform float u_scaleFactor;
        uniform vec2 u_translation;
        uniform float u_luminosity;
        uniform float u_vibrancy;
        uniform float u_initialFreq;
        uniform float u_bS;
        uniform float u_sortStrength;
        uniform float u_sortFrequency;
        uniform float u_sortAnimSpeed;
        uniform int u_currentPattern;
        uniform float u_baseModulation;
        uniform vec4 u_baseColor;
        uniform vec3 u_randomColor1;  // Add uniforms for random colors
        uniform vec3 u_randomColor2;
        uniform vec3 u_randomColor3;
        
        // Add new toggle uniforms
        uniform bool u_enableDomainWarp;    // Toggle domain warping
        uniform bool u_enableLayeredNoise;  // Toggle layered noise
        uniform bool u_enableFlowFields;    // Toggle flow field distortion
        uniform bool u_enableGlyphNoise;    // Toggle glyph pattern noise
        uniform bool u_enableGridDistort;   // Toggle grid distortion
        uniform bool u_enableGlyphNoiseDetail;    // Toggle detail noise within glyphs

        // Add the isLightBackground uniform to the shader
        uniform bool u_isLightBackground;   // Whether we're using a light background

        // Add this uniform after the other uniforms in the fragment shader
        uniform float u_caScaleVariation;  // Controls how much the CA scale varies

        lowp float random(vec2 st, float seed) {
            // Hash function only needs low precision output
            vec2 p = st + seed;
            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }

        mediump float noise(vec2 st, float seed) {
            // Integer and fractional parts
            vec2 i = floor(st);
            vec2 f = fract(st);
            
            // Optimized smoothstep with lowp precision
            lowp vec2 u = f * f * (3.0 - 2.0 * f);
            
            // Gather corners with low precision
            lowp float a = random(i, seed);
            lowp float b = random(i + vec2(1.0, 0.0), seed);
            lowp float c = random(i + vec2(0.0, 1.0), seed);
            lowp float d = random(i + vec2(1.0, 1.0), seed);
            
            // Mix can use low precision
            return mix(
                a + (b - a) * u.x,
                c + (d - c) * u.x,
                u.y);
        }

        lowp vec3 mod289(vec3 x) { 
            return x - floor(x / 289.0) * 289.0; 
        }

        lowp vec2 mod289(vec2 x) { 
            return x - floor(x / 289.0) * 289.0; 
        }

        lowp vec3 permute(vec3 x) { 
            return mod289((x * 34.0 + 1.0) * x); 
        }


//////////////////////////////////////////////////////////////////////


mediump float simplexNoise(mediump vec2 v, float time) {
    const mediump vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
    
    // Combine time addition into a single step
    v += time * 0.03;
    
    // Integer calculations can use low precision
    lowp vec2 i = floor(v + dot(v, C.yy));
    mediump vec2 x0 = v - i + dot(i, C.xx);
    
    // These boolean operations and offsets can use low precision
    lowp vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    
    // Combined calculations to reduce register usage
    mediump vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    
    // Use existing mod289 function
    i = mod289(i);
    lowp vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
    
    // Dot products need medium precision
    mediump vec3 dots = vec3(
        dot(x0, x0),
        dot(vec2(x12.x, x12.y), vec2(x12.x, x12.y)),
        dot(vec2(x12.z, x12.w), vec2(x12.z, x12.w))
    );
    
    // These multiplications can use low precision
    lowp vec3 m = max(0.5 - dots, 0.0);
    m = m * m;
    m = m * m;
    
    // These can use low precision
    lowp vec3 x = 2.0 * fract(p * C.www) - 1.0;
    lowp vec3 h = abs(x) - 0.5;
    lowp vec3 ox = floor(x + 0.5);
    lowp vec3 a0 = x - ox;
    
    // Final calculation
    m *= 1.792842914 - 0.853734913 * (a0 * a0 + h * h);
    
    // Gradient calculation
    lowp vec3 g = vec3(
        a0.x * x0.x + h.x * x0.y,
        a0.y * x12.x + h.y * x12.y,
        a0.z * x12.z + h.z * x12.w
    );
    
    return 130.0 * dot(m, g);
}

        /////////////////////////////////////////////////////////////////
        lowp float fastSin(float x) {
            // Wrap to -PI to PI range
            x = mod(x + M_PI, 2.0 * M_PI) - M_PI;
            
            // Fast sine approximation
            // Error < 0.002
            float x2 = x * x;
            return x * (1.0 - x2 / (3.0 * 2.0) + x2 * x2 / (5.0 * 4.0 * 3.0 * 2.0));
        }

        lowp float fastCos(float x) {
            return fastSin(x + M_PI * 0.5);
        }

        vec2 domainWarp(vec2 p, float time) {
            // DISABLED: Domain warping completely removed for performance optimization
            // Simply return unmodified coordinates
            return p;
            
            // Original implementation below:
            /*
            float slowTime = time * 0.0001;
            
            float flow = simplexNoise(p * 0.05 * (u_resolution.y / u_cellSize) + slowTime, slowTime);
            float detail = simplexNoise(p * 0.1 * (u_resolution.y / u_cellSize) + slowTime * 1.5, slowTime * 2.0) * 0.3;
            
            // Use fast approximations
            float angle = slowTime * 0.1;
            float rotX = fastCos(angle) * flow;
            float rotY = fastSin(angle) * flow;
            
            return p + vec2(
                rotX * 1.5 + detail,
                rotY * 1.5 + detail
            );
            */
        }

        float layeredNoise(vec2 p, float time) {
            // PERFORMANCE OPTIMIZATION: Single-layer noise without detail for better performance
            return simplexNoise(p, time);
            
            /* Original implementation:
            // Simplified to single layer with detail
            float mainLayer = simplexNoise(p, time);
            float detail = simplexNoise(p * 2.0, time * 0.3) * 0.3;
            return mainLayer * 0.7 + detail * 0.3;
            */
        }

        float fbmSimplexNoise(vec2 v, int octaves) {
            // Bail early for 0 octaves
            if (octaves <= 0) return 0.0;
            
            // PERFORMANCE OPTIMIZATION: Hard-coded parameters with minimal math
            // and reduced multiplications
            const float PERSISTENCE = 0.001;
            const float LACUNARITY = 0.0009;
            
            // Apply initial offsets once
            v += u_nOS + vec2(u_nS);
            
            // For extreme performance optimization, skip multi-octave calculation
            // when we only need a rough estimate (like in distort calculations)
            if (octaves <= 2) {
                // Ultra simplified single-octave version for distortion calculations
                return simplexNoise(v, u_time * 0.05) * u_amplitude * u_baseModulation;
            }
            
            float total = 0.0;
            float amplitude = u_amplitude;
            float frequency = u_initialFreq;
            
            // First octave - most prominent
            total = amplitude * simplexNoise(v, u_time);
            
            // Only add a second octave if needed
            if (octaves > 1) {
                // Simplified time influence calculation
                float timeInfluence = sin(u_time * 0.05) * 0.2 + 0.5;
                
                // Simplified rotation using precomputed values
                float timeRotation = u_time * 0.05;
                float sinRot = sin(timeRotation);
                float cosRot = cos(timeRotation);
                mat2 rot = mat2(cosRot, -sinRot, sinRot, cosRot);
                
                // Second octave
                amplitude *= PERSISTENCE * 3.0;
                frequency *= LACUNARITY;
                total += amplitude * simplexNoise(rot * v * frequency, u_time * 0.8);
            }
            
            // Apply final modulation with fewer calculations
            return total * u_baseModulation;
        }

        lowp vec3 getColorFromPalette(float t) {
            // Enhanced palette function with more varied color output
            
            // Constrain input and use improved mapping for more variation
            t = clamp(t, 0.0, 5.0) * 2.0; // Increased range
            
            // Create more varied color patterns based on position in the sequence
            float patternMod = floor(mod(t, 3.0)); // Split into 3 pattern regions
            
            // Use non-linear interpolation factors for more interesting gradients
            float f1 = pow(fract(t), 1.2);
            float f2 = pow(fract(t + 0.33), 1.5);
            float f3 = smoothstep(0.0, 1.0, fract(t * 1.5));
            
            // Create a secondary color variation factor for more diversity
            float altFactor = fract(t * 2.31); // Irrational multiplier for less repetition
            
            // More diverse color mixing with conditional patterns based on the pattern region
            vec3 color1, color2;
            
            if (patternMod < 1.0) {
                // First pattern: primary colors with secondary influence
                color1 = mix(u_randomColor1, u_randomColor2, f1) * 0.7 + 
                         u_randomColor3 * 0.5 * f2;
                         
                color2 = mix(u_randomColor2, u_randomColor3, f3) * 0.8 + 
                         u_randomColor1 * 0.4 * (1.0-f1);
            } else if (patternMod < 2.0) {
                // Second pattern: complementary color approach
                color1 = mix(u_randomColor2, u_randomColor3, f2) * 0.75 + 
                         u_randomColor1 * 0.4 * f3;
                         
                color2 = mix(u_randomColor3, u_randomColor1, f1) * 0.7 + 
                         u_randomColor2 * 0.5 * (1.0-f3);
            } else {
                // Third pattern: triadic harmony
                color1 = mix(u_randomColor3, u_randomColor1, f3) * 0.65 + 
                         u_randomColor2 * 0.6 * f1;
                         
                color2 = mix(u_randomColor1, u_randomColor2, f2) * 0.7 + 
                         u_randomColor3 * 0.45 * (1.0-f2);
            }
            
            // Apply color enhancement based on position in sequence
            if (altFactor > 0.7) {
                // Occasional color inversion for variety
                color1 = 1.0 - color1 * 0.8;
                color2 = 1.0 - color2 * 0.8;
            } else if (altFactor < 0.3) {
                // Occasional brightness boost
                color1 = color1 * 1.3;
                color2 = color2 * 1.3;
            }
            
            // Boost saturation of the colors by pushing them away from gray
            color1 = mix(color1, pow(color1, vec3(0.85)), 0.4);
            color2 = mix(color2, pow(color2, vec3(0.85)), 0.4);
            
            // Use higher contrast smoothstep for final blend with varied edge values
            return mix(color1, color2, smoothstep(0.15, 0.85, fract(t)));
        }

        lowp vec3 enhanceColor(vec3 color, float noiseValue) {
            // Enhanced color variety with multiple color processing approaches
            
            // Simple luminance calculation
            float luminance = (color.r + color.g + color.b) * 0.333;
            
            // Create varied color enhancement based on the input color's properties
            float colorSum = color.r + color.g + color.b;
            float colorVariation = mod(colorSum * 10.0, 3.0); // Create 3 distinct enhancement methods
            
            vec3 enhancedColor;
            
            if (colorVariation < 1.0) {
                // Method 1: Vibrant saturation boost
                float saturation = u_isLightBackground ? 1.5 : 1.7;
                vec3 saturated = mix(vec3(luminance), color, saturation * u_vibrancy);
                
                // High contrast approach
                float contrast = u_isLightBackground ? 0.9 : 0.85;
                enhancedColor = max(saturated - vec3(contrast * 0.5 - 0.5), 0.0) / (1.0 - contrast * 0.5);
                
                // Add highlights
                enhancedColor += step(0.7, enhancedColor) * 0.3;
                
            } else if (colorVariation < 2.0) {
                // Method 2: Color temperature shift
                // Warm colors (shift toward red/yellow)
                if (color.r > color.b) {
                    enhancedColor = color * vec3(1.2, 1.1, 0.9);
                } 
                // Cool colors (shift toward blue/cyan)
                else {
                    enhancedColor = color * vec3(0.9, 1.1, 1.2);
                }
                
                // Smoothstep contrast
                enhancedColor = smoothstep(0.1, 0.9, enhancedColor);
                
            } else {
                // Method 3: Complementary color accents
                enhancedColor = color * (1.0 + (1.0 - luminance) * 0.9);
                
                // Add subtle complementary color hints
                vec3 complement = vec3(1.0) - color;
                enhancedColor = mix(enhancedColor, complement * luminance, 0.15);
                
                // Normalize to maintain brightness
                enhancedColor = enhancedColor / max(max(enhancedColor.r, enhancedColor.g), max(enhancedColor.b, 1.0));
            }
            
            // Apply common processing for all methods
            
            // Apply noise influence for variation
            enhancedColor *= 1.0 + (noiseValue - 0.5) * 0.2;
            
            // Final vibrancy adjustment
            float finalMultiplier = u_isLightBackground ? 0.95 : 1.15;
            return enhancedColor * finalMultiplier * (1.0 + (u_vibrancy - 1.0) * 0.3);
        }

        lowp vec3 blendColors(lowp vec3 a, lowp vec3 b, lowp float factor) {
            // Multi-mode color blending for greater color variety
            
            // Use the color properties to select different blending modes
            float colorKey = a.r + a.g + a.b + b.r + b.g + b.b;
            float blendMode = mod(colorKey * 8.0, 4.0); // Create 4 distinct blending approaches
            
            // Core blending modes
            lowp vec3 screen = 1.0 - (1.0 - a) * (1.0 - b * factor);
            lowp vec3 add = min(a + b * factor * 0.5, 1.0);
            lowp vec3 dodge = a / max(1.0 - b * factor * 0.8, 0.01);
            
            // Additional blend modes for more variety
            lowp vec3 multiply = a * b * factor * 1.5; // Darker blend
            lowp vec3 overlay = mix(
                2.0 * a * b,
                1.0 - 2.0 * (1.0 - a) * (1.0 - b),
                step(0.5, a)
            ) * factor;
            
            // Color temperature shift blend
            lowp vec3 tempShift;
            if (length(a) > length(b)) {
                tempShift = mix(a, vec3(a.r * 1.2, a.g * 0.9, a.b * 0.8), factor * 0.5);
            } else {
                tempShift = mix(a, vec3(a.r * 0.8, a.g * 0.9, a.b * 1.2), factor * 0.5);
            }
            
            // Select blend mode based on color properties
            lowp vec3 result;
            
            if (blendMode < 1.0) {
                // Mode 1: Vibrant screen-add blend
                result = mix(screen, add, 0.4);
                result = mix(result, dodge, 0.3);
            } 
            else if (blendMode < 2.0) {
                // Mode 2: Rich overlay blend
                result = mix(overlay, screen, 0.5);
                result = mix(result, tempShift, 0.3);
            }
            else if (blendMode < 3.0) {
                // Mode 3: Dramatic contrast blend
                result = mix(dodge, multiply, 0.5);
                result = mix(result, a, 0.3); // Maintain some original color
            }
            else {
                // Mode 4: Harmonious color shift
                result = mix(a, tempShift, 0.7);
                result = mix(result, screen, 0.4);
            }
            
            // Apply vibrancy control
            return mix(a, result, u_vibrancy * 0.4 + 0.6);
        }

        lowp vec2 getFlowDirection(mediump vec2 position, float time) {
            // PERFORMANCE OPTIMIZATION: Ultra-simplified flow direction with minimal noise samples
            
            // Scale position and use slower time for more stable flow
            lowp float slowTime = time * 0.01;
            vec2 p = position * 0.005;
            
            // Single octave noise for x and y direction
            float noiseX1 = simplexNoise(p + vec2(slowTime, 0.0), 0.0);
            float noiseY1 = simplexNoise(p + vec2(0.0, slowTime * 1.1), 0.0);
            
            // Create a simple flow direction
            vec2 flow = vec2(noiseX1 - 0.5, noiseY1 - 0.5);
            
            // Add some static variation
            flow += 0.3 * vec2(
                simplexNoise(p * 2.0, 123.0),
                simplexNoise(p * 2.0, 456.0)
            );
            
            // RANDOMIZE FLOW: Add rotation to vary the direction
            // Use a stable seed value based on position and seed
            float rotSeed = simplexNoise(p * 0.1, u_nS + 789.0);
            float rotAngle = rotSeed * 6.28318; // Random angle 0-2π
            
            // Apply rotation matrix to flow vector
            float sinRot = sin(rotAngle);
            float cosRot = cos(rotAngle);
            flow = vec2(
                flow.x * cosRot - flow.y * sinRot,
                flow.x * sinRot + flow.y * cosRot
            );
            
            // Add global directional variation using time
            float globalDirAngle = sin(time * 0.0001) * 3.14159; // Slowly changes global flow direction
            flow += 0.2 * vec2(cos(globalDirAngle), sin(globalDirAngle));
            
            // Normalize without expensive operations
            float len = max(length(flow), 0.0001);
            return flow / len;
        }

        // Add this function before getGlyphPattern
        lowp vec4 getCASettings(float seed, float iter) {
            // Use seed and iteration to select pattern type
            float patternSeed = fract(seed * 12345.6789 + iter * 789.123);
            
            // Select one of four patterns based on the seed
            int patternType = int(mod(patternSeed * 4.0, 4.0));
            
            // Return vec4(dirBiasStrength, surviveThreshold, birthThreshold, edgeThreshold)
            if (patternType == 0) {
                // Organic, flowing patterns
                return vec4(
                    0.4,    // dirBias strength
                    1.3,    // surviveThreshold base
                    2.3,    // birthThreshold base
                    0.35    // edgeThreshold base
                );
            } else if (patternType == 1) {
                // Geometric, crystalline patterns
                return vec4(
                    0.15,   // dirBias strength
                    1.6,    // surviveThreshold base
                    2.7,    // birthThreshold base
                    0.5     // edgeThreshold base
                );
            } else if (patternType == 2) {
                // Chaotic, detailed patterns
                return vec4(
                    0.3,    // dirBias strength
                    1.7,    // surviveThreshold base
                    2.2,    // birthThreshold base
                    0.45    // edgeThreshold base
                );
            } else {
                // Symmetric patterns
                return vec4(
                    0.25,   // dirBias strength
                    1.5,    // surviveThreshold base
                    2.5,    // birthThreshold base
                    0.4     // edgeThreshold base
                );
            }
        }

        // Then modify getGlyphPattern to use these settings
        lowp float getGlyphPattern(vec2 cell, float depth, float seed, vec2 normalizedPos) {
            // PERFORMANCE OPTIMIZATION: Use distance from center to skip distant calculations completely
            float distFromCenter = length(cell);
            if (distFromCenter > 10.0) {
                return step(0.7, noise(floor(cell * 0.2) * 5.0, seed));
            }
            
            // Simplify grid position calculation - fewer operations
            vec2 gridPos = floor(cell * 0.25) * 4.0;
            float gridValue = max(abs(gridPos.x), abs(gridPos.y)) * 0.25;
            float smoothGrid = smoothstep(0.0, 4.0, gridValue) * 0.5;
            
            // Reduce noise calculation complexity
            float stabilityNoise = noise(floor(cell * 0.125) * 8.0, seed) * 0.2;
            float scaleVariation = 1.0 + smoothGrid * 0.2 * u_caScaleVariation;
            
            // Simplify cell scaling - fewer multiplications
            vec2 scaledCell = floor(cell * scaleVariation) * 0.5;
            vec2 id = floor(scaledCell);
            
            // Generate base pattern with minimal calculations
            float basePattern = noise(floor(id * 0.5), seed + floor(depth));
            float state = step(0.6, basePattern);
            
            // Simplified geometric properties
            float angle = atan(scaledCell.y, scaledCell.x);
            float radius = length(scaledCell);
            
            // Enhanced pattern variation based on depth and position - creates more visual complexity
            float patternVariant = mod(floor(radius) + floor(angle * 2.0) + depth, 8.0); // Increased from 4 to 8 pattern variants
            
            // Reduced neighbor calculations - only compute if really needed
            if (length(id) < 8.0) {
                // Simplified neighbor calculation with enhanced pattern logic
                float neighbors = 0.0;
                
                // Only calculate 4 immediate neighbors instead of 8
                vec2 neighbor;
                float neighborState;
                
                // Add unique offset to each neighbor calculation based on pattern variant
                // This creates different cellular patterns without adding performance cost
                
                // Right neighbor
                neighbor = floor(id + vec2(1.0, 0.0) + mod(patternVariant, 2.0) * 0.2);
                neighborState = step(0.5, noise(neighbor * 0.5, seed));
                neighbors += neighborState;
                
                // Left neighbor
                neighbor = floor(id + vec2(-1.0, 0.0) + mod(patternVariant + 1.0, 2.0) * 0.2);
                neighborState = step(0.5, noise(neighbor * 0.5, seed));
                neighbors += neighborState;
                
                // Top neighbor
                neighbor = floor(id + vec2(0.0, 1.0) + mod(patternVariant + 2.0, 2.0) * 0.2);
                neighborState = step(0.5, noise(neighbor * 0.5, seed));
                neighbors += neighborState;
                
                // Bottom neighbor
                neighbor = floor(id + vec2(0.0, -1.0) + mod(patternVariant + 3.0, 2.0) * 0.2);
                neighborState = step(0.5, noise(neighbor * 0.5, seed));
                neighbors += neighborState;
                
                // Enhanced rule application - 8 different pattern types with same computation cost
                float depthRule = floor(mod(depth + patternVariant, 8.0));
                
                if (depthRule < 1.0) {
                    // Survival-like rule (Conway's Game of Life inspired)
                    float surviveThreshold = 1.5 + sin(angle) * 0.1;
                    state = step(surviveThreshold - 0.1, neighbors) * 
                            step(neighbors, surviveThreshold + 1.1) * state + 
                            step(2.0, neighbors) * 
                            step(neighbors, 3.0) * (1.0 - state);
                } else if (depthRule < 2.0) {
                    // Edge detection rule
                    float edgeThreshold = 0.4 + cos(radius) * 0.1;
                    state = step(edgeThreshold, abs(neighbors - 2.0));
                } else if (depthRule < 3.0) {
                    // Fractal-like rule
                    state = step(0.5, fract(neighbors * (1.0 + cos(angle * 4.0) * 0.2)));
                } else if (depthRule < 4.0) {
                    // Symmetric pattern rule
                    state = step(0.5, sin(radius * 3.0 + angle * 4.0) * 0.5 + 0.5);
                } else if (depthRule < 5.0) {
                    // Maze-like pattern rule
                    state = step(0.55, fract(neighbors * radius * 0.2));
                } else if (depthRule < 6.0) {
                    // Concentric rings rule
                    state = step(0.5, sin(radius * 2.0 + neighbors * 0.5) * 0.5 + 0.5);
                } else if (depthRule < 7.0) {
                    // Angular sectors rule
                    state = step(0.5, sin(angle * (3.0 + neighbors) + radius) * 0.5 + 0.5);
                } else {
                    // Quantum CA-inspired rule - produces interesting grid patterns
                    state = step(0.5, fract((sin(radius * 2.0) + cos(angle * 3.0)) * neighbors * 0.3));
                }
            }
            
            // Enhanced geometric pattern with more variation but same computational cost
            float geoPattern;
            
            // Use pattern variant to select between 8 different pattern styles (increased from 4)
            if (patternVariant < 1.0) {
                // Circular/radial pattern
                geoPattern = smoothstep(0.4, 0.6, sin(radius * (3.0 + depth * 0.5) + depth) * 0.5 + 0.5);
            } else if (patternVariant < 2.0) {
                // Angular/star pattern
                geoPattern = smoothstep(0.4, 0.6, sin(angle * (4.0 + depth * 0.5) + depth) * 0.5 + 0.5);
            } else if (patternVariant < 3.0) {
                // Grid/checkboard pattern
                geoPattern = step(0.5, fract(scaledCell.x * 0.5) + fract(scaledCell.y * 0.5));
            } else if (patternVariant < 4.0) {
                // Combined pattern
                geoPattern = smoothstep(0.4, 0.6, sin(radius * angle * (1.0 + depth * 0.3) + depth) * 0.5 + 0.5);
            } else if (patternVariant < 5.0) {
                // Wave interference pattern
                geoPattern = step(0.5, sin(scaledCell.x * 2.0) * sin(scaledCell.y * 2.0) * 0.5 + 0.5);
            } else if (patternVariant < 6.0) {
                // Spiral pattern
                geoPattern = smoothstep(0.4, 0.6, sin(radius * 3.0 + angle * 5.0) * 0.5 + 0.5);
            } else if (patternVariant < 7.0) {
                // Complex grid pattern
                geoPattern = step(0.5, fract(sin(scaledCell.x * 3.0) + cos(scaledCell.y * 3.0)));
            } else {
                // Frequency modulation pattern
                geoPattern = step(0.5, sin(radius * (5.0 + sin(angle * 3.0) * 2.0)) * 0.5 + 0.5);
            }
            
            // Blend with geometric pattern - enhanced to use pattern variant and depth more effectively
            float blendFactor = 0.3 + 0.2 * sin(depth * 1.5 + patternVariant * 0.8);
            return mix(state, geoPattern, blendFactor);
        }

        void main() {
            // Constants can use low precision
            const lowp int MAX_LOOP_DEPTH = 3; // Reduced from 4 to 3 for even better performance
            
            // Coordinate calculations need medium precision
            mediump vec2 coord = (vTexCoord * u_resolution - u_resolution * 0.25) * u_scaleFactor + u_translation;
            coord = coord / u_bS;
            
            // Grid distortion calculation can use medium precision
            mediump float gridDistortTime = u_time * u_sortAnimSpeed * 0.1;
            mediump vec2 gridDistortCoord = coord * u_sortFrequency;
            
            // Most pattern calculations can use low precision
            lowp float distortNoise1 = fbmSimplexNoise(gridDistortCoord + vec2(gridDistortTime * 0.1), 2);
            lowp float distortNoise2 = fbmSimplexNoise(gridDistortCoord + vec2(gridDistortTime * -0.15), 2);
            
            // Pattern vectors can use low precision since normalized
            lowp vec2 expPattern, stepPattern, circularPattern, squarePattern, flowPattern, smoothFlowPattern;
            
            // Pattern 1: Exponential waves
            expPattern = vec2(
                exp(-abs(mod(distortNoise1 + gridDistortTime, 2.0) - 1.0)) - 0.5,
                exp(-abs(mod(distortNoise2 + gridDistortTime, 2.0) - 1.0)) - 0.5
            );
            
            // Pattern 2: Stepped/quantized movement
            stepPattern = vec2(
                floor(distortNoise1 * 4.0) / 4.0,
                floor(distortNoise2 * 4.0) / 4.0
            );
            
            // Pattern 3: Circular/spiral movement
            float angle = distortNoise1 * 6.28318;
            circularPattern = vec2(
                cos(angle) * distortNoise2,
                sin(angle) * distortNoise2
            );
            
            // Pattern 4: Square/diamond pattern
            squarePattern = vec2(
                sign(fract(distortNoise1 * 2.0) - 0.5) * abs(fract(distortNoise2 * 2.0) - 0.5),
                sign(fract(distortNoise2 * 2.0) - 0.5) * abs(fract(distortNoise1 * 2.0) - 0.5)
            );
            
            // Pattern 5: Enhanced smooth directional flow with rotation and fractal structure
            // RANDOMIZE DIRECTION: Add random phase offsets to the directional flow
            float randomPhaseX = simplexNoise(vec2(gridDistortTime * 0.1), u_nS + 321.0) * 6.28318;
            float randomPhaseY = simplexNoise(vec2(gridDistortTime * 0.15), u_nS + 654.0) * 6.28318;
            
            flowPattern = vec2(
                distortNoise1 * cos(gridDistortTime * 0.2 + randomPhaseX) - distortNoise2 * sin(gridDistortTime * 0.15 + randomPhaseY),
                distortNoise1 * sin(gridDistortTime * 0.2 + randomPhaseY) + distortNoise2 * cos(gridDistortTime * 0.15 + randomPhaseX)
            );
            
            // Add interest points for flow to create micro-patterns
            float microPattern = fract(distortNoise1 * 3.0) * fract(distortNoise2 * 3.0);
            flowPattern += flowPattern * microPattern * 0.3;
            
            // Add subtle vorticity with enhanced fractal structure
            float vortexStrength = 0.3 + microPattern * 0.2;
            // Remove radial slices: replace atan-based angle with noise-based angle
            float vortexAngle = gridDistortTime * 0.1 + 
                               distortNoise1 * 3.14 * 2.0;
            
            // Create multiple vortex scales
            vec2 vortexOffset = vec2(0.0);
            for(int i = 0; i < 2; i++) { // Only 2 iterations for performance
                float scale = i == 0 ? 1.0 : 0.5;
                float phase = i == 0 ? 0.0 : 2.0;
                vortexOffset += scale * vec2(
                    cos(vortexAngle * (1.0 + float(i)*0.5) + phase) * length(flowPattern),
                    sin(vortexAngle * (1.0 + float(i)*0.5) + phase) * length(flowPattern)
                ) * vortexStrength;
            }
            
            // Combine flow and enhanced vortex with smooth transition
            smoothFlowPattern = flowPattern + vortexOffset;
            
            // Add progressive movement (modified for more organic flow)
            float flowTime = gridDistortTime * 0.05;
            smoothFlowPattern += vec2(
                simplexNoise(vec2(flowTime * 0.7, 0.0), 0.0) * 0.15,
                simplexNoise(vec2(flowTime * 0.8, 1.0), 0.0) * 0.15
            );
            
            // Add complex fluid-like swirls using simple math (not expensive noise)
            float swirls = 0.0;
            // Use existing distortNoise with slightly different frequency for varied effect
            swirls = sin(distortNoise1 * 6.28318 + gridDistortTime * 0.2) * 0.5 + 0.5;
            
            // Create complex flow patterns with minimal computation
            // These patterns create zones of divergence and convergence similar to fluid dynamics
            float zonePattern = fract((coord.x * 0.01 + coord.y * 0.02) * swirls + gridDistortTime * 0.01);
            
            // Different zone types create different flow behaviors
            if (zonePattern < 0.33) {
                // Divergent zone - flow pushes outward
                smoothFlowPattern += normalize(smoothFlowPattern) * 0.1;
            } else if (zonePattern < 0.66) {
                // Convergent zone - flow pulls inward
                smoothFlowPattern -= normalize(smoothFlowPattern) * 0.1;
            } else {
                // Rotational zone - flow rotates
                vec2 perpFlow = vec2(-smoothFlowPattern.y, smoothFlowPattern.x);
                smoothFlowPattern = mix(smoothFlowPattern, perpFlow, 0.2);
            }
            
            // Add turbulence with minimal computation using time-shifted coordinates
            float turbulence = sin(coord.x * 0.02 + coord.y * 0.03 + gridDistortTime * 0.1) * 
                               cos(coord.y * 0.02 - coord.x * 0.01 + gridDistortTime * 0.15);
            
            // Scale and apply turbulence effect to smooth flow
            smoothFlowPattern += vec2(
                sin(turbulence * 3.14159),
                cos(turbulence * 3.14159)
            ) * 0.1;
            
            // Select pattern based on uniform
            vec2 finalPattern = smoothFlowPattern;
            
            // Apply grid distortion only if enabled
            mediump vec2 gridOffset = finalPattern * u_sortStrength * u_cellSize;
            
            // Simplify the coordinate adjustment (unconditional for performance)
            coord += gridOffset * (1.0 + sin(gridDistortTime) * 0.3);
            
            vec2 gridCoord = floor(coord / u_cellSize);
            vec2 cellCenter = (gridCoord + 0.5) * u_cellSize;
            vec2 localPos = coord - cellCenter;

        // Cell boundary check can use lower precision
        lowp float cellBoundary = u_cellSize * 0.485;
        lowp float edgeFade = 0.005;
        bool isWithinCell = all(lessThanEqual(abs(localPos), vec2(cellBoundary)));
        if (!isWithinCell) {
            // Smooth edge transition
            vec2 edgeDistance = abs(localPos) - vec2(cellBoundary);
            float fadeAlpha = 1.0 - smoothstep(0.0, edgeFade, max(edgeDistance.x, edgeDistance.y));
            if (fadeAlpha <= 0.0) discard;
        }

            // Pre-calculate values needed for the depth loop
            float distToCenter = length(coord - cellCenter);
            float timeScale = u_time * 0.1;
            vec2 baseNoiseCoord = gridCoord * 0.1;
            vec2 timeOffset = vec2(timeScale, timeScale + 100.0);
            
            // Calculate distortion influence once
            float distortionInfluence = length(gridOffset) / (u_cellSize * 2.0);
            float baseNoiseFBM = fbmSimplexNoise(gridCoord * (u_cellSize / u_resolution.y) * 0.05, 4) + distortionInfluence * 0.2;
            
            vec2 noiseOffset = vec2(
                noise(baseNoiseCoord + timeOffset.xx, u_nS),
                noise(baseNoiseCoord + timeOffset.yy, u_nS)
            );
            
            // Pre-calculate common values for the loop
            float gridSize = u_cellSize * mix(0.3, 2.5, baseNoiseFBM + distortionInfluence * 0.2);
            vec2 localCoord = mod(coord + noiseOffset, gridSize);
            
            float randomAngle = floor(noise(gridCoord + noiseOffset, u_nS) * 4.0) * (M_PI * 0.5);
            float sinA = fastSin(randomAngle);
            float cosA = fastCos(randomAngle);
            vec2 rotatedCoord = vec2(
                localCoord.x * cosA - localCoord.y * sinA,
                localCoord.x * sinA + localCoord.y * cosA
            );
            
            float smoothedTime = u_time * 0.01 + simplexNoise(vec2(u_time * 0.3, 50.0), u_nS) * 0.005;
            
            vec2 noiseInput1 = rotatedCoord * ((u_cellSize / u_resolution.y) * 1.0) + smoothedTime;
            vec2 noiseInput2 = (rotatedCoord + gridCoord * gridSize) * ((u_cellSize / u_resolution.y) * 1.0) * u_noiseScale;
            
            float flowNoise = fbmSimplexNoise(noiseInput1, 6);
            vec2 animatedCoord = noiseInput2 + vec2(
                simplexNoise(vec2(flowNoise, u_time * 0.05), u_nS),
                simplexNoise(vec2(flowNoise, u_time * 0.05 + 100.0), u_nS)
            ) * u_flowSpeed * 0.005;
            
            float curlNoise = fbmSimplexNoise(animatedCoord * (u_cellSize / u_resolution.y) * 20.0 + vec2(u_nS), 8);
            animatedCoord += 4.0 * vec2(
                cos(curlNoise * 6.28318),
                sin(curlNoise * 6.28318)
            );
            
            // Color blending can use low precision
            lowp vec4 color = vec4(0.0);
            
            // Main loop variables
            mediump float depthNoiseValue, depthFactor, colorT;
            lowp vec3 color1, color2, enhancedColor1, enhancedColor2, blendedColor;
            
            // Calculate base noise values that won't change in the loop
            float baseNoise = fbmSimplexNoise(animatedCoord * (u_cellSize / u_resolution.y) * 0.15 + noiseOffset, 5);
            float combinedNoise = (baseNoise * 0.3 + baseNoiseFBM * 0.7 + 3.0) * 0.3;
            
            // Calculate depth once
            float clampedNoise = clamp(combinedNoise, 0.0, 1.0);
            int dynamicDepth = int(clamp(
                clampedNoise * float(u_maxDepth),
                1.0,
                min(float(u_maxDepth), float(MAX_LOOP_DEPTH))
            ));
            
            // Pre-calculate threshold and blend factor outside loop with enhanced pattern variation
            float threshold = 0.55 - (0.15 * pow(1.0 - u_bS, 2.0));
            
            // Create more interesting time-based pattern transitions
            float timeRatio = fract(u_time * 0.0005);
            float timePhase = sin(timeRatio * 6.28318) * 0.5 + 0.5;
            
            // Enhanced blend factors with more artistic transitions
            float t = simplexNoise(vec2(u_time * 0.01), 0.0) * 0.5 + 0.5;
            float angleInfluence = simplexNoise(vec2(u_time * 0.005), 0.0) * 0.5 + 0.5;
            
            // Create complex blend pattern using simple math (not expensive noise)
            float complexBlend = t * t * (3.0 - 2.0 * t);
            // REMOVE RADIAL SLICES: Replace angular division with smoother gradient
            complexBlend = mix(
                complexBlend,
                1.0 - complexBlend,
                smoothstep(0.3, 0.7, fract(timePhase)) // Remove atan calculation
            );
            
            // Final blend factor with local variations for more pattern diversity
            float blendFactor = complexBlend * (1.0 + combinedNoise * 0.8 + angleInfluence * 1.2);
            
            // Enhanced edge values for color transitions - more dynamic ranges
            float edgeRange = 0.4 + t * 0.2;
            float edge0 = 0.5 - edgeRange * 0.5 + sin(u_time * 0.0002) * 0.15;
            float edge1 = 0.5 + edgeRange * 0.5 + cos(u_time * 0.0002) * 0.15;
            
            // Get flow direction for current cell
            vec2 flowDir = getFlowDirection(cellCenter, u_time);
            float flowAngle = atan(flowDir.y, flowDir.x);
            
            // Process each depth level with minimal branching
            for (int depth = 0; depth < MAX_LOOP_DEPTH; depth++) {
                // Break conditions at the top
                if (depth >= dynamicDepth || color.a > 0.95) break;
                
                // Calculate depth-based parameters only once per depth level
                depthNoiseValue = noise(animatedCoord * float(depth + 1), u_nS);
                depthFactor = float(depth) / float(MAX_LOOP_DEPTH);
                
                // Early rejection using simplified threshold test
                if (depthNoiseValue < threshold || depthFactor > 0.9) continue;
                
                // Quickly determine glyph size and check if we need to process this area
                float currentSize = (0.3 + depthFactor * 0.9) * u_cellSize;
                float distanceFromCenter = length(localPos);
                
                // Reject distant glyphs early with a simple distance check
                if (distanceFromCenter > currentSize * 2.5) continue;
                
                // Simplified rotation for flow alignment
                vec2 rotatedP;
                if (depth < 2) {
                    // Only apply expensive rotation for the most visible depths
                    rotatedP = vec2(
                        localPos.x * cos(-flowAngle) - localPos.y * sin(-flowAngle),
                        localPos.x * sin(-flowAngle) + localPos.y * cos(-flowAngle)
                    );
                } else {
                    // Use unrotated coordinates for higher depths
                    rotatedP = localPos;
                }
                
                // Simplified glyph calculation
                float mappedOffset = 0.5 + 0.5 * length(flowDir);
                vec2 glyphCell = floor(rotatedP / currentSize + mappedOffset);
                
                // Simple validity check for pattern lookup
                float pattern;
                if (length(glyphCell) > 12.0) {
                    // Use simplest pattern for distant cells
                    pattern = step(0.5, noise(glyphCell, u_nS));
                } else {
                    // Use optimized glyph pattern for closer cells
                    pattern = getGlyphPattern(glyphCell, float(depth), u_nS, vTexCoord);
                }
                
                // Determine if cell is active with simplified checks
                bool insideGlyph = pattern > 0.5 || 
                                   (abs(glyphCell.x) < 0.5 && abs(glyphCell.y) < 0.5);
                
                // Skip empty areas
                if (!insideGlyph) continue;
                
                // Enhanced color selection with more variety
                // Use depth, pattern value, and position to create more diverse color choices
                float colorVariationFactor = fract(pattern * 5.0 + depthFactor * 3.0 + length(glyphCell) * 0.1);
                float colorOffset = 0.0;
                
                // Create 5 different color selection approaches for more variety
                int colorMode = int(mod(colorVariationFactor * 5.0, 5.0));
                
                if (colorMode == 0) {
                    // Standard smooth transition
                    colorT = smoothstep(edge0, edge1, depthFactor + baseNoise * 0.9);
                } 
                else if (colorMode == 1) {
                    // Contrasting colors
                    colorT = 1.0 - smoothstep(edge0, edge1, depthFactor + baseNoise * 0.7);
                    colorOffset = 0.3; // Shift color selection
                }
                else if (colorMode == 2) {
                    // Pattern-driven color
                    colorT = pattern * 2.0 * smoothstep(0.0, 1.0, depthFactor);
                    colorOffset = 0.5; // Different palette region
                }
                else if (colorMode == 3) {
                    // Position-based coloring
                    colorT = fract(length(glyphCell * 0.1) + depthFactor * 0.8);
                    colorOffset = 0.7; // Another palette region
                }
                else {
                    // Angular variation
                    // Remove radial slices: replace angle-based calculation with noise-based one
                    float positionFactor = length(glyphCell) * 0.1 + depthFactor * 0.8;
                    colorT = positionFactor * 1.5 + depthFactor * 0.6;
                    colorOffset = 0.9; // Different palette region
                }
                
                // Get colors with more diverse parameter passing
                color1 = getColorFromPalette(colorT + colorOffset);
                color2 = getColorFromPalette(1.0 - colorT + colorOffset * 0.5);
                
                // Apply original depth boost
                float depthBoost = 1.2 + (1.0 - depthFactor) * 0.8;
                color1 *= depthBoost;
                color2 *= depthBoost;
                
                // Always use the full enhancement for colors
                enhancedColor1 = enhanceColor(color1, baseNoise);
                enhancedColor2 = enhanceColor(color2, baseNoise);
                
                // Use the proper blendColors function for correct visual appearance
                blendedColor = blendColors(enhancedColor1, enhancedColor2, blendFactor);
                
                // Add color complexity with subtle overlays based on depth and pattern
                if (depth > 0) {
                    // Apply subtle color overlays for deeper layers only
                    
                    // Create overlay color based on pattern and position
                    vec3 overlayColor;
                    
                    // Use pattern information to create interesting overlays
                    if (pattern > 0.7) {
                        // High pattern values get warm overlay
                        overlayColor = vec3(1.0, 0.8, 0.6) * depthFactor;
                    } else if (pattern < 0.3) {
                        // Low pattern values get cool overlay
                        overlayColor = vec3(0.6, 0.8, 1.0) * depthFactor;
                    } else {
                        // Mid pattern values get neutral overlay
                        overlayColor = vec3(0.8) * depthFactor;
                    }
                    
                    // Apply overlay with screen blend for subtle effect
                    blendedColor = mix(
                        blendedColor,
                        1.0 - (1.0 - blendedColor) * (1.0 - overlayColor),
                        0.2
                    );
                    
                    // Add subtle color accents based on depth
                    if (depth == 1) {
                        // Second layer gets subtle highlights based on position
                        float highlightIntensity = fract(length(glyphCell) * 0.3) * 0.15;
                        blendedColor += vec3(highlightIntensity, highlightIntensity * 0.8, highlightIntensity * 0.6);
                    } else if (depth == 2) {
                        // Third layer gets subtle color shift
                        // Remove radial slice: replace angular calculation with noise-based one
                        float shiftFactor = fract(length(glyphCell) * 0.2 + depthFactor * 0.5) * 0.15;
                        blendedColor = mix(
                            blendedColor,
                            blendedColor.brg, // Subtle color channel swap
                            shiftFactor
                        );
                    }
                }
                
                // Blend with original alpha factor calculation for correct transparency
                float alphaFactor = 1.0 - depthNoiseValue * 0.7;
                
                // Use original alpha blending
                color.rgb = mix(color.rgb, blendedColor, alphaFactor);
                color.a += alphaFactor * (1.0 - color.a);
            }
            
            // Final color check
            if (color.a == 0.0) {
                color = u_baseColor;
            }
            
            gl_FragColor = color;
        }
    </script>

    <script>
        let bS = 1.0;     
        const cV = 6;  
        let tS;
        let dM = 3;  // Initially set to 3 which is fullscreen aspect ratio
        let cS;      
        let bN = 0.002;  
        let nS;
        let fS = 0.005;
        let rSS;
        let roA;
        let nOX, nOY;
        let scF = 30;
        let tX = 0, tY = 0;
        let iTX = 0, iTY = 0;
        let pMX, pMY;
        let amV = [0.1, 0.075, 0.05]; 
        let isP = true;
        let stT = 0;
        let cuT = 0;
        let lum = 1.5;
        let vib = 3.5; // Increased from 2.5 for more vibrant colors
        let soS = 0.1;     
        let soF = 0.1;   
        let soA = 0.15;     
        let cuP;                  

        // Add performance monitoring system
        const TARGET_FRAMERATE = 60; // Target frame rate (can be lowered for better performance)
        let lastFrameTime = 0;      // For frame rate control
        let currentFPS = 60;        // Track current FPS
        let fpsUpdateTime = 0;      // Time of last FPS update
        const FPS_UPDATE_INTERVAL = 500; // Update FPS every 500ms
        
        // Variables related to canvas and WebGL
        let canvasElement;               // Reference to canvas element
        let glContext;                   // Cached reference to WebGL context
        
        // Memory management variables
        const MEMORY_CLEANUP_INTERVAL = 30000; // Run memory cleanup every 30 seconds
        let lastMemoryCleanup = 0;
        let isMemoryCleanupScheduled = false;
        const recordingChunkPool = [];   // Pool of pre-allocated chunks for recording
        let recordingChunkIndex = 0;     // Current index in the recording chunk pool
        let isTabVisible = true; // Track tab visibility for better performance

        // Handle visibility changes to pause rendering when tab not active
        function handleVisibilityChange() {
            isTabVisible = document.visibilityState === 'visible';
            
            if (isTabVisible) {
                // Reset frame time tracking to avoid jumps
                lastFrameTime = performance.now();
                // Restart animation if animation is enabled
                if (isP) {
                    requestAnimationFrame(draw);
                }
            }
            
            // Take opportunity to clean up memory when tab is hidden
            if (!isTabVisible) {
                performMemoryCleanup();
            }
        }

        // Memory management function that optimizes memory use
        function performMemoryCleanup() {
            isMemoryCleanupScheduled = true;
            
            // Use setTimeout to defer heavy operations until the tab is idle
            setTimeout(() => {
                // Clear any unused recording chunks
                if (Array.isArray(reCN) && reCN.length > 0) {
                    // Keep only chunks that are actually in use
                    if (!isR) {
                        reCN.length = 0;
                    }
                }
                
                // Reset preallocated arrays to reduce memory fragmentation
                recordingChunkIndex = 0;
                
                // Force garbage collection on WebGL if possible
                if (glContext && !isTabVisible) {
                    // Attempt to reduce GL memory usage by reducing texture size temporarily
                    // Only do this when tab isn't visible to avoid affecting visible rendering
                    const tempDensity = pixelDensity();
                    if (tempDensity > 1) {
                        pixelDensity(1);
                        clear();
                        pixelDensity(tempDensity);
                    }
                }
                
                lastMemoryCleanup = performance.now();
                isMemoryCleanupScheduled = false;
                
                // If tab is visible and animation is playing, restart the animation loop
                if (isTabVisible && isP) {
                    requestAnimationFrame(draw);
                }
            }, 100);
        }

        // Cached uniform values to prevent redundant updates
        const cachedUniforms = {
            bS: null,
            scaleFactor: null,
            translation: [null, null],
            resolution: [null, null],
            time: null,
            cellSize: null,
            flowSpeed: null,
            luminosity: null,
            vibrancy: null,
            sortStrength: null,
            sortFrequency: null,
            sortAnimSpeed: null,
            currentPattern: null,
            noiseScale: null,
            caScaleVariation: null
        };

        let inscription_id = window.location.pathname.split("/").pop();
        
        // REMOVE AFTER TESTING!!!
            let chars = "0123456789abcdefghijklmnopqrstuvwsyz";
            inscription_id = new URLSearchParams(window.location.search).get("seed") || Array(64).fill(0).map(_=>chars[(Math.random()*chars.length)|0]).join('');
        // REMOVE AFTER TESTING!!!



        class Rnd{
            constructor(seed) {
                const i=Math.imul,h=t=>{let e,l=0;for(e=1779033703^t.length;l<t.length;l++){let h=e^t.charCodeAt(l);e=i(h,3432918353),e=e<<13|e>>>19}return()=>(e=i(e^e>>>16,2246822507),e=i(e^e>>>13,3266489909),(e^=e>>>16)>>>0)},a=(e,r,t,a)=>()=>{let l=((e|=0)+(r|=0)|0)+(a|=0)|0;return a=a+1|0,e=r^r>>>9,r=(t|=0)+(t<<3)|0,t=(t=t<<21|t>>>11)+l|0,(l>>>0)/4294967296},X=h(seed);this.R=a(X(),X());
            }
            D=_=>this.R();                  
            N=(r,t)=>r+(t-r)*this.D();     
            I=(r,t)=>0|this.N(r,t+1);      
            B=r=>this.D()<r               
        };
        let R = new Rnd(inscription_id)

        console.log('Inscription ID:', inscription_id)


        function upTC() {
            // Keep the current translation coordinates instead of recalculating
            // This maintains the user's current view when changing zoom level
            // Don't override tX and tY here, we want to keep the current position
        }

        function geT() {
            const d = new Date();
            const pad = n => n.toString().padStart(2, '0');
            return `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
        }

        function preload() {
            // Only initialize shader once for better performance
            if (!tS) {
            let vertexShader = document.getElementById('vertex-shader').textContent;
            let fragmentShader = document.getElementById('fragment-shader').textContent;
            tS = createShader(vertexShader, fragmentShader);
            }
        }

        function suEH() {
            // Cache canvas reference
            const canvas = canvasElement;
            
            // Event listener references for proper cleanup
            const eventListeners = {
                keydown: null,
                keyup: null,
                mousedown: null,
                mousemove: null,
                mouseup: null,
                touchstart: null,
                touchmove: null,
                touchend: null,
                visibilitychange: null,
                resize: null
            };
            
            // Throttling variables for mousemove/touchmove
            let lastMoveTime = 0;
            const MOVE_THROTTLE = 16; // ~ 60fps
            
            // Touch event tracking
            let lastTap = 0;
            let lastTapX = 0;
            let lastTapY = 0;
            let tapCount = 0;
            let tapTimeout = null;
            
            // Key state with Set for faster lookups
            const keyState = new Set();
            
            // Mouse/touch state
            let isDragging = false;
            let startX, startY;
            let startTX, startTY;
            
            // Clean up old event listeners if they exist
            function cleanupEventListeners() {
                // Remove existing listeners if they were created before
                for (const [type, handler] of Object.entries(eventListeners)) {
                    if (handler) {
                        if (type === 'resize') {
                            window.removeEventListener(type, handler);
                        } else if (type.startsWith('touch')) {
                            canvas.removeEventListener(type, handler, { passive: false });
                        } else {
                            document.removeEventListener(type, handler);
                        }
                    }
                }
            }
            
            // Optimized key event handler
            function handleKeyDown(e) {
                if (keyState.has(e.key)) return;
                keyState.add(e.key);
                
                console.log('Key pressed:', e.key); // Debug logging
                
                switch(e.key.toLowerCase()) {
                    case 'a':
                        dM = (dM + 1) % 4; // Changed from 3 to 4 modes
                        requestAnimationFrame(upCS);
                        break;
                        
                    case 'r':
                        // Reset position and scale - this should still provide a full reset
                        tX = -width/2;
                        tY = -height/2;
                        scF = 30;
                        break;
                        
                    case 's':
                        isP = !isP;
                        if (isP) {
                            stT = millis() * 0.1;
                            // Ensure draw loop restarts if we're enabling playback
                            requestAnimationFrame(draw);
                        } else {
                            cuT = (millis() - stT) / 1000.0;
                        }
                        break;
                        
                    case '1':
                    case '2':
                    case '3':
                        {  
                            const cuD = pixelDensity();
                            const nwD = e.key === '1' ? 4 : (e.key === '2' ? 5 : 5.5);
                            
                            pixelDensity(nwD);
                            draw();
                           
                            const tiS = geT();
                            const prefix = e.key === '1' ? 'shader_' : 'shader_hires_';
                            saveCanvas(prefix + tiS, 'png');
                            
                            pixelDensity(cuD);
                            draw();
                            break;  
                        }
                        
                    case 'd':
                        if (scF === 30) {
                            scF = 10;
                        } else {
                            scF = 30;
                        }
                        // No need to call upTC here as we want to maintain position
                        break;
                    
                    case 'k':
                        if (!isR) {
                            stRe();
                        } else {
                            noRe();
                        }
                        break;
                }
            }
            
            function handleKeyUp(e) {
                keyState.delete(e.key);
            }
            
            // Optimized mouse event handlers with throttling
            function handleMouseDown(e) {
                if (e.button !== 0) return; // Only handle left mouse button
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startTX = tX;
                startTY = tY;
                
                // Apply cursor style once
                canvas.style.cursor = 'grabbing';
                
                // Prevent text selection while dragging
                e.preventDefault();
            }
            
            function handleMouseMove(e) {
                // Only process if dragging
                if (!isDragging) return;
                
                // Calculate accurate pan distance with proper scaling
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                // Apply translation with a smooth scaling factor based on current zoom
                // This ensures consistent speed regardless of zoom level
                const panScale = scF / 15;
                
                // Apply translation with smooth interpolation for natural feel
                tX = startTX - dx * panScale;
                tY = startTY + dy * panScale;
                
                // Force redraw for smooth motion even when not animating
                if (!isP && rafID === null) {
                    rafID = requestAnimationFrame(draw);
                }
            }
            
            function handleMouseUp(e) {
                if (isDragging) {
                    isDragging = false;
                    canvas.style.cursor = 'grab';
                    
                    // Force final redraw for smoothness
                    if (!isP && rafID === null) {
                        rafID = requestAnimationFrame(draw);
                    }
                }
            }
            
            // Touch event handlers with optimization
            function handleTouchStart(e) {
                if (e.touches.length !== 1) return;
                
                const touch = e.touches[0];
                const currentTime = performance.now();
                
                isDragging = true;
                startX = touch.clientX;
                startY = touch.clientY;
                startTX = tX;
                startTY = tY;
                
                // Double/triple tap detection
                const tapDistance = Math.sqrt(
                    Math.pow(touch.clientX - lastTapX, 2) + 
                    Math.pow(touch.clientY - lastTapY, 2)
                );
                
                // Clear any existing timeout
                if (tapTimeout) {
                    clearTimeout(tapTimeout);
                }
                
                // Check if this is a quick consecutive tap
                if (currentTime - lastTap < 300 && tapDistance < 30) {
                    tapCount++;
                    
                    if (tapCount === 2) {
                        // Double tap - toggle pause
                        isP = !isP;
                        if (isP) {
                            stT = millis() * 0.1;
                            requestAnimationFrame(draw);
                        } else {
                            cuT = (millis() - stT) / 1000.0;
                        }
                        isDragging = false; // Prevent drag after double tap
                    } else if (tapCount === 3) {
                        // Triple tap - cycle aspect ratio
                        dM = (dM + 1) % 4; // Changed from 3 to 4 modes
                        requestAnimationFrame(upCS);
                        tapCount = 0;
                        isDragging = false; // Prevent drag after triple tap
                    }
                } else {
                    // First tap of potential sequence
                    tapCount = 1;
                }
                
                // Update tap tracking
                lastTap = currentTime;
                lastTapX = touch.clientX;
                lastTapY = touch.clientY;
                
                // Set timeout to reset tap counter if no more taps happen
                tapTimeout = setTimeout(() => {
                    tapCount = 0;
                }, 300);
                
                // Prevent default to avoid scrolling
                e.preventDefault();
            }
            
            function handleTouchMove(e) {
                if (!isDragging || e.touches.length !== 1) return;
                
                const touch = e.touches[0];
                
                // Calculate accurate pan distance with proper scaling
                const dx = touch.clientX - startX;
                const dy = touch.clientY - startY;
                
                // Apply translation with a smooth scaling factor based on current zoom
                const panScale = scF / 15;
                
                // Apply translation with smooth interpolation
                tX = startTX - dx * panScale;
                tY = startTY + dy * panScale;
                
                // Force redraw for smooth motion even when not animating
                if (!isP && rafID === null) {
                    rafID = requestAnimationFrame(draw);
                }
                
                // Prevent default to avoid scrolling
                e.preventDefault();
            }
            
            function handleTouchEnd(e) {
                isDragging = false;
                
                // Force final redraw for smoothness
                if (!isP && rafID === null) {
                    rafID = requestAnimationFrame(draw);
                }
                
                // Don't reset tap state here, as we want to track multi-taps
                // But ensure we prevent default for consistency
                e.preventDefault();
            }
            
            // Optimized resize handler using RAF for better performance
            function handleResize() {
                if (reTO) {
                    clearTimeout(reTO);
                    reTO = null;
                }
                
                reTO = setTimeout(() => {
                    requestAnimationFrame(upCS);
                }, 100);
            }
            
            // Clean up existing event listeners
            cleanupEventListeners();
            
            // Set up event listeners with proper options
            eventListeners.keydown = handleKeyDown;
            eventListeners.keyup = handleKeyUp;
            eventListeners.mousedown = handleMouseDown;
            eventListeners.mousemove = handleMouseMove;
            eventListeners.mouseup = handleMouseUp;
            eventListeners.touchstart = handleTouchStart;
            eventListeners.touchmove = handleTouchMove;
            eventListeners.touchend = handleTouchEnd;
            eventListeners.resize = handleResize;
            eventListeners.visibilitychange = handleVisibilityChange;
            
            // Add event listeners with appropriate options
            document.addEventListener('keydown', eventListeners.keydown);
            document.addEventListener('keyup', eventListeners.keyup);
            
            // Mouse events on document to catch cursor movement outside canvas
            document.addEventListener('mousedown', eventListeners.mousedown);
            document.addEventListener('mousemove', eventListeners.mousemove);
            document.addEventListener('mouseup', eventListeners.mouseup);
            
            // Touch events need { passive: false } to prevent scrolling
            canvas.addEventListener('touchstart', eventListeners.touchstart, { passive: false });
            canvas.addEventListener('touchmove', eventListeners.touchmove, { passive: false });
            canvas.addEventListener('touchend', eventListeners.touchend, { passive: false });
            
            // Window events
            window.addEventListener('resize', eventListeners.resize);
            document.addEventListener('visibilitychange', eventListeners.visibilitychange);
            
            // Initialize cursor style
            canvas.style.cursor = 'grab';
            
            // Return cleanup function for proper disposal
            return cleanupEventListeners;
        }

        function setup() {
            let canvas = createCanvas(windowWidth, windowHeight, WEBGL);
            // Store reference to canvas element
            canvasElement = document.querySelector('canvas');
            
            let gl = canvas.GL;
            // Cache GL context for better performance
            glContext = gl;
            
            // Apply WebGL optimizations
            gl.disable(gl.DEPTH_TEST);  
            gl.disable(gl.CULL_FACE);   
            gl.disable(gl.DITHER);      
            gl.disable(gl.STENCIL_TEST);
            
            // Enable optimizations for 2D rendering
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.hint(gl.GENERATE_MIPMAP_HINT, gl.FASTEST);
            
            // Set fixed pixel density
            pixelDensity(2);
            
            // Pre-allocate recording chunk pool if WebM recording is supported
            if (typeof MediaRecorder !== 'undefined') {
                // Initialize memory cleanup timer
                lastMemoryCleanup = performance.now();
                
                // Set up event listeners for visibility changes to optimize memory
                document.addEventListener('visibilitychange', handleVisibilityChange);
            }
            
            noStroke();
            
            // Use existing shader if available, otherwise create it
            if (!tS) {
                tS = createShader(
                    document.getElementById('vertex-shader').textContent,
                    document.getElementById('fragment-shader').textContent
                );
            }
            shader(tS);
            
            // PERFORMANCE OPTIMIZATION: Disable domain warping and other expensive effects
            setShaderUniform('u_enableDomainWarp', false);
            setShaderUniform('u_enableGridDistort', false);
            
            if (!inscription_id) {
                return;
            }
            
            cuP = R.I(0, 5);
            
            // Set current pattern immediately for better state tracking
            setShaderUniform('u_currentPattern', cuP, 'currentPattern');
            
            upCS();
            
            // Setup event handlers with optimized implementation - CALL ONLY ONCE
            suEH();
            
            nOX = R.I(0,2000)
            nOY = R.I(0,2000)

            let shiftX = -width/2;
            let shiftY = -height/2;
            iTX = shiftX;
            iTY = shiftY;
            tX = shiftX;
            tY = shiftY;

            nS = R.I(0,1000)
            rSS = R.I(0,1000)
            roA = R.I(0, 360)
            
            let teR = R.I(0, amV.length - 1);
            let raA = amV[teR];
            
            let inF = [0.0005, 0.0001, 0.005];
            let seF = inF[R.I(0,2)];
            
            cS = windowHeight / cV;
            
            let noSO = [0.005, 0.003, 0.001];
            bN = noSO[R.I(0, 2)];  

            let baM = R.N(0.5, 2.0);  
            
            function caCD(color1, color2) {
                const dr = color1[0] - color2[0];
                const dg = color1[1] - color2[1];
                const db = color1[2] - color2[2];
                return Math.sqrt(dr * dr + dg * dg + db * db);
            }

            function geRC(brightnessType = 'light', baseHue = null, existingColors = []) {
                const miCD = 0.3;
                let at = 0;
                const maA = 10;

                while (at < maA) {
                    let h;
                    if (brightnessType === 'mid' && baseHue !== null) {
                        h = (baseHue + 0.5) % 1.0;
} else {
                        h = R.D();  
                    }

                    let s = R.N(0.8, 1.0);  
                    let v;
                    
                    switch(brightnessType) {
                        case 'dark':
                            v = R.N(0.15, 0.3);  
                            break;
                        case 'mid':
                            v = R.N(0.5, 0.65);  
                            break;
                        case 'light':
                            v = R.N(0.85, 1.0);  
                            break;
                    }
                    
                    let i = Math.floor(h * 6);
                    let f = h * 6 - i;
                    let p = v * (1 - s);
                    let q = v * (1 - f * s);
                    let t = v * (1 - (1 - f) * s);

                    let r, g, b;
                    switch (i % 6) {
                        case 0: r = v, g = t, b = p; break;
                        case 1: r = q, g = v, b = p; break;
                        case 2: r = p, g = v, b = t; break;
                        case 3: r = p, g = q, b = v; break;
                        case 4: r = t, g = p, b = v; break;
                        case 5: r = v, g = p, b = q; break;
                    }

                    const newColor = [r, g, b];
                   
                    let diC = true;
                    for (const existingColor of existingColors) {
                        if (caCD(newColor, existingColor) < miCD) {
                            diC = false;
                            break;
                        }
                    }

                    if (diC || at === maA - 1) {
                        return { color: newColor, hue: h };
                    }

                    at++;
                }
            }
            
            let liR = geRC('light', null, []);
            let rC1 = liR.color;  
            
            let miR = geRC('mid', liR.hue, [rC1]);
            let rC2 = miR.color;  
            
            let rC3 = geRC('dark', null, [rC1, rC2]).color;  
            
            let baC = [
                [0.05, 0.05, 0.05, 1.0],  
                [0.90, 0.87, 0.82, 1.0]    
            ];
            
            let sBaC = baC[R.D() < 0.7 ? 0 : 1];
            let liBc = sBaC[0] > 0.5;

            // Efficiently set all uniform values using our cached function
            // Set static uniforms that rarely/never change
            setShaderUniform('u_nS', nS);
            setShaderUniform('u_rSS', rSS);
            setShaderUniform('u_roA', radians(roA));
            setShaderUniform('u_nOS', [nOX, nOY]);
            setShaderUniform('u_amplitude', raA);
            setShaderUniform('u_maxDepth', 6);
            setShaderUniform('u_initialFreq', seF);
            setShaderUniform('u_baseModulation', baM);
            setShaderUniform('u_baseColor', sBaC);
            setShaderUniform('u_isLightBackground', liBc);
            
            // Set color values
            setShaderUniform('u_randomColor1', rC1);
            setShaderUniform('u_randomColor2', rC2);
            setShaderUniform('u_randomColor3', rC3);
            
            // Set dynamic uniforms
            setShaderUniform('u_luminosity', lum);
            setShaderUniform('u_vibrancy', vib);
            setShaderUniform('u_sortStrength', soS);
            setShaderUniform('u_sortFrequency', soF);
            setShaderUniform('u_sortAnimSpeed', soA);
            
            // Original code didn't set these flags explicitly, so we'll remove them
            // to maintain the original visual output

            scF = 30;
            upTC();

            // Remove duplicate call to suEH() here

            stT = millis();  
            
            let cASV = R.N(1.5, 3.0);  
            setShaderUniform('u_caScaleVariation', cASV);
            
            // Start the animation loop
            requestAnimationFrame(draw);
        }

        // Add these variables near the top of the script
        let rafID = null;
        let lastRenderTime = 0;
        const MIN_RENDER_INTERVAL = 16.667; // ~60fps

        function draw() {
            // Skip rendering when tab is not visible
            if (!isTabVisible) {
                return;
            }
            
            // Cancel any pending animation frame to avoid duplicates
            if (rafID !== null) {
                cancelAnimationFrame(rafID);
                rafID = null;
            }
            
            // Request next frame early for better performance
            if (isP || isDragging) {
                rafID = requestAnimationFrame(draw);
            }
            
            // Frame rate control for consistent animation
            const now = performance.now();
            const elapsed = now - lastFrameTime;
            
            // Apply time-based throttling for smoother rendering
            if (now - lastRenderTime < MIN_RENDER_INTERVAL) {
                return;
            }
            
            lastRenderTime = now;
            
            // FPS Calculation (keep this for monitoring only)
            if (now - fpsUpdateTime > FPS_UPDATE_INTERVAL) {
                currentFPS = 1000 / (elapsed || 1);
                fpsUpdateTime = now;
                // Log FPS to console for monitoring
                console.log('Current FPS:', currentFPS.toFixed(1));
            }
            
            // Periodic memory cleanup
            if (now - lastMemoryCleanup >= MEMORY_CLEANUP_INTERVAL) {
                performMemoryCleanup();
            }
            
            // Update last frame time with adjustment to maintain consistent frame timing
            lastFrameTime = now;
            
            // Clear buffer with minimal overhead
            clear();
            background(0);  
            
            // Synchronized time handling
            if (isP) {
                cuT = ((millis() - stT) / 1000.0);
            }

            let scT = cuT; 

            // Update uniform values efficiently with caching
            setShaderUniform('u_bS', bS);
            setShaderUniform('u_scaleFactor', scF);
            setShaderUniform('u_translation', [tX, tY]);
            setShaderUniform('u_resolution', [width, height]);
            setShaderUniform('u_time', scT);
            
            // Calculate cellSize only once
            const cellSize = (height / cV) * bS;
            setShaderUniform('u_cellSize', cellSize);
            
            setShaderUniform('u_flowSpeed', fS);
            setShaderUniform('u_luminosity', lum);
            setShaderUniform('u_vibrancy', vib);
            setShaderUniform('u_sortStrength', soS);
            setShaderUniform('u_sortFrequency', soF);
            setShaderUniform('u_sortAnimSpeed', soA);
            
            // Don't need to update pattern if it hasn't changed
            setShaderUniform('u_currentPattern', cuP);
            
            // Calculate noise scale more efficiently
            let cSP = height / cV;
            let dySN = bN * (100.0 / floor(cSP)); 
            setShaderUniform('u_noiseScale', dySN);

            // Only update CA scale variation when needed
            setShaderUniform('u_caScaleVariation', 0.5);
            
            // Revert to original quad drawing method to maintain exact visual output
            beginShape();
            vertex(0, 0, 0, 0, 0);
            vertex(2, 0, 0, 1, 0);
            vertex(2, 2, 0, 1, 1);
            vertex(0, 2, 0, 0, 1);
            endShape(CLOSE);
            
            if (isR && (millis() - reST > reDu)) {
                noRe();
            }
        }

        

        function upCS() {
            const wiR = windowWidth / windowHeight;
            let neW, neH;
            
            // Save current position before resize
            const currentTX = tX;
            const currentTY = tY;
            const currentScaleFactor = scF;
            
            switch(dM) {
                case 0: // 3:4 aspect ratio
                    if (wiR > 0.75) {
                        // Width is relatively larger, constrain by height
                    neH = windowHeight;
                        neW = windowHeight * 0.75; // 3:4 ratio (width:height)
                    } else {
                        // Height is relatively larger, constrain by width
                        neW = windowWidth;
                        neH = windowWidth * (4/3); // 4:3 ratio (height:width)
                    }
                    break;
                
                case 1: // 1:1 square aspect ratio
                    if (wiR > 1) {
                        neH = windowHeight;
                        neW = windowHeight;
                    } else {
                        neW = windowWidth;
                        neH = windowWidth;
                    }
                    break;
                
                case 2: // 4:3 aspect ratio
                    if (wiR > (4/3)) {
                        // Width is relatively larger, constrain by height
                        neH = windowHeight;
                        neW = windowHeight * (4/3); // 4:3 ratio (width:height)
                    } else {
                        // Height is relatively larger, constrain by width
                        neW = windowWidth;
                        neH = windowWidth * 0.75; // 3:4 ratio (height:width)
                    }
                    break;
                
                case 3: // Fullscreen (use entire window)
                    neW = windowWidth;
                    neH = windowHeight;
                    break;
            }
           
            if (width !== neW || height !== neH) {
                // Calculate relative position for scaling
                const relXPercent = (currentTX + width/2) / width;
                const relYPercent = (currentTY + height/2) / height;
                
                resizeCanvas(neW, neH);
                
                // Maintain relative position after resize
                tX = (relXPercent * neW) - neW/2;
                tY = (relYPercent * neH) - neH/2;
                
                // Use cached canvas reference instead of querying the DOM again
                if (canvasElement) {
                    canvasElement.style.cssText = 'position:absolute;left:50%;top:50%;transform:translate(-50%,-50%)';
                }
                
                // Force a redraw to update the canvas
                requestAnimationFrame(draw);
            }
        }

        
        let reTO;
        function windowResized() {
            // Cancel previous timeout to avoid memory leaks
            if (reTO) {
            clearTimeout(reTO);
                reTO = null;
            }
            
            // Use requestAnimationFrame for smoother updates and less performance impact
            // Debounce with setTimeout as a backup for consistent timing
            reTO = setTimeout(() => {
                // Use requestAnimationFrame to align with browser's render cycle
                requestAnimationFrame(upCS);
            }, 100);
        }

        
        let meR;
        let reCN = [];
        let isR = false;
        let reST;
        const reDu = 30000; 

        // Add these new functions
        function stRe() {
            // Clear previous chunks but keep the array to reduce allocations
            reCN.length = 0;
            recordingChunkIndex = 0;
            
            // Use cached canvas element reference
            const stream = canvasElement.captureStream(60); 
            meR = new MediaRecorder(stream, {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 50000000 
            });

            meR.ondataavailable = (e) => {
                if (e.data && e.data.size > 0) {
                    // Store only non-empty chunks
                    reCN.push(e.data);
                }
            };

            meR.onstop = saRe;

            // Schedule regular data chunks to avoid memory spikes
            meR.start(1000); // Request data in 1-second chunks
            isR = true;
            reST = millis();
        }

        function noRe() {
            if (meR && meR.state !== 'inactive') {
            meR.stop();
            isR = false;
            }
        }

        function saRe() {
            if (reCN.length === 0) {
                console.log('No recording data available.');
                return;
            }
            
            // Create blob using a single operation
            const blob = new Blob(reCN, {type: 'video/webm'});
            
            // Generate timestamp for filename
            const timestamp = geT();
            
            // Create download link
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `recording_${timestamp}.webm`;
            a.style.display = 'none';
            
            // Add to DOM, click, and remove to trigger download
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
                // Clear chunks array
                reCN.length = 0;
            }, 100);
        }

        // Function to set uniform values to shader with caching
        function setShaderUniform(name, value, cachedName = null) {
            // Use provided cachedName or derive from uniform name
            const cacheKey = cachedName || name.replace('u_', '');
            
            // Handle array values
            if (Array.isArray(value)) {
                // Check each element in array
                if (
                    !cachedUniforms[cacheKey] || 
                    value.some((v, i) => v !== cachedUniforms[cacheKey][i])
                ) {
                    // Update cache with defensive copy
                    cachedUniforms[cacheKey] = [...value];
                    
                    // Set the actual WebGL uniform
                    tS.setUniform(name, value);
                }
            } else {
                // For primitive values, simple comparison
                if (cachedUniforms[cacheKey] !== value) {
                    // Update cache
                    cachedUniforms[cacheKey] = value;
                    
                    // Set the actual WebGL uniform
                    tS.setUniform(name, value);
                }
            }
        }

        function optimizeGLRendering() {
            // Ensure WebGL context is valid
            if (!glContext) return;
            
            // Optimize WebGL state for this specific renderer
            
            // Disable features we don't need (already done in setup, but ensure they stay disabled)
            glContext.disable(glContext.DEPTH_TEST);
            glContext.disable(glContext.CULL_FACE);
            glContext.disable(glContext.DITHER);
            glContext.disable(glContext.STENCIL_TEST);
            
            // Enable optimization features
            glContext.enable(glContext.SCISSOR_TEST); // Enable scissor test for clipping
            
            // Set optimal blend mode for our rendering
            glContext.enable(glContext.BLEND);
            glContext.blendFunc(glContext.SRC_ALPHA, glContext.ONE_MINUS_SRC_ALPHA);
            
            // Set hints for WebGL renderer
            glContext.hint(glContext.GENERATE_MIPMAP_HINT, glContext.FASTEST);
            
            // Optimize viewport to match canvas size exactly
            glContext.viewport(0, 0, glContext.drawingBufferWidth, glContext.drawingBufferHeight);
            
            // Create a static vertex buffer for our quad rendering
            createStaticVertexBuffer();
        }
        
        // Create static vertex buffer for efficient rendering
        function createStaticVertexBuffer() {
            if (!glContext) return;
            
            // We'll set up a better vertex buffer in a real implementation
            // For p5.js integration, we'll rely on p5's own buffer management
            // But we can optimize how we use it
        }
    </script>
  </body>
</html>
