<!DOCTYPE html>
<html>
  <head>
    <title>Shader Art</title>
    <script src="https://ordinals.com/content/7e37766541506810ba6399c4b2735121f508bd9209df43dd200bf2316b014594i0"></script>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000;
        }
        canvas {
            width: 100% !important;
            height: 100% !important;
            object-fit: contain !important;
            max-width: 100vw;
            max-height: 100vh;
        }
        main {
            display: flex;
            justify-content: center;
            width: 100%;
            align-items: center;
            height: 100%;
        }
    </style>
  </head>
  <body>
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec3 aPosition;
        attribute vec2 aTexCoord;
        varying vec2 vTexCoord;

        void main() {
            vTexCoord = aTexCoord;
            vec4 positionVec4 = vec4(aPosition, 1.0);
            positionVec4.xy = positionVec4.xy * 2.0 - 1.0;
            gl_Position = positionVec4;
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        precision lowp int;  
        #endif

        #define M_PI 3.14159265358979323846

        varying vec2 vTexCoord;
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float u_cellSize;
        uniform float u_noiseScale;
        uniform float u_maxDepth;
        uniform float u_flowSpeed;
        uniform float u_nS;
        uniform float u_rSS;
        uniform float u_roA;
        uniform vec2 u_nOS;
        uniform float u_amplitude;
        uniform float u_scaleFactor;
        uniform vec2 u_translation;
        uniform float u_luminosity;
        uniform float u_vibrancy;
        uniform float u_initialFreq;
        uniform float u_bS;
        uniform float u_sortStrength;
        uniform float u_sortFrequency;
        uniform float u_sortAnimSpeed;
        uniform int u_currentPattern;
        uniform float u_baseModulation;
        uniform vec4 u_baseColor;
        uniform vec3 u_randomColor1;  
        uniform vec3 u_randomColor2;
        uniform vec3 u_randomColor3;
        
        
        
        uniform bool u_enableGlyphNoiseDetail;    // Toggle detail noise within glyphs

        // Add the isLightBackground uniform to the shader
        uniform bool u_isLightBackground;   // Whether we're using a light background

        // Add uniform for muted colors
        uniform bool u_useMutedColors;     // Whether we're using muted colors
        
        // Add this uniform after the other uniforms in the fragment shader
        uniform float u_caScaleVariation;  // Controls how much the CA scale varies
        
        // Add uniforms for mouse position
        uniform vec2 u_mouse;             // Mouse position in normalized coordinates
        uniform bool u_mouseActive;       // Whether mouse is over the canvas
        uniform float u_mouseInfluenceRadius; // Radius of mouse influence (added)

        // Add trail system uniforms
        uniform vec2 u_trailPositions[20];   // Trail point positions
        uniform float u_trailTimes[20];      // Trail point timestamps
        uniform int u_trailCount;            // Number of active trail points

        lowp float random(vec2 st, float seed) {
            // Hash function only needs low precision output
            vec2 p = st + seed;
            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }

        mediump float noise(vec2 st, float seed) {
            // Integer and fractional parts
            vec2 i = floor(st);
            vec2 f = fract(st);
            
            // Optimized smoothstep with lowp precision
            lowp vec2 u = f * f * (3.0 - 2.0 * f);
            
            // Gather corners with low precision
            lowp float a = random(i, seed);
            lowp float b = random(i + vec2(1.0, 0.0), seed);
            lowp float c = random(i + vec2(0.0, 1.0), seed);
            lowp float d = random(i + vec2(1.0, 1.0), seed);
            
            // Mix can use low precision
            return mix(
                a + (b - a) * u.x,
                c + (d - c) * u.x,
                u.y);
        }

        lowp vec3 mod289(vec3 x) { 
            return x - floor(x / 289.0) * 289.0; 
        }

        lowp vec2 mod289(vec2 x) { 
            return x - floor(x / 289.0) * 289.0; 
        }

        lowp vec3 permute(vec3 x) { 
            return mod289((x * 34.0 + 1.0) * x); 
        }
//////////////////////////////////////////////////////////////////////
        mediump float simplexNoise(mediump vec2 v, float time) {
            // Original simplex noise variables and setup
            mediump vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
            
            // Combine time addition into a single step
            vec2 timeOffset = vec2(u_time * 0.03);
            
            // First, compute standard simplex noise
            mediump vec2 vOrig = v;
            v += timeOffset;
            
            // Integer calculations can use low precision
            lowp vec2 i = floor(v + dot(v, C.yy));
            mediump vec2 x0 = v - i + dot(i, C.xx);
            
            // These boolean operations and offsets can use low precision
            lowp vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
            
            // Combined calculations to reduce register usage
            mediump vec4 x12 = x0.xyxy + C.xxzz;
            x12.xy -= i1;
            
            // Use existing mod289 function
            i = mod289(i);
            lowp vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
            
            // Dot products need medium precision
            mediump vec3 dots = vec3(
                dot(x0, x0),
                dot(vec2(x12.x, x12.y), vec2(x12.x, x12.y)),
                dot(vec2(x12.z, x12.w), vec2(x12.z, x12.w))
            );
           
            // These multiplications can use low precision
            lowp vec3 m = max(0.5 - dots, 0.0);
            m = m * m;
            m = m * m;
            
            // These can use low precision
            lowp vec3 x = 2.0 * fract(p * C.www) - 1.0;
            lowp vec3 h = abs(x) - 0.5;
            lowp vec3 ox = floor(x + 0.5);
            lowp vec3 a0 = x - ox;
            
            // Final calculation
            m *= 1.792842914 - 0.853734913 * (a0 * a0 + h * h);
            
            // Gradient calculation
            lowp vec3 g = vec3(
                a0.x * x0.x + h.x * x0.y,
                a0.y * x12.x + h.y * x12.y,
                a0.z * x12.z + h.z * x12.w
            );
            
            // Base simplex noise value
            float noise = 130.0 * dot(m, g);
            
            // Now apply reaction-diffusion style transformations with smoother transitions
            
            // Use a more consistent time factor that won't cause sudden jumps
            vec2 uv = vOrig * 0.06;
            // Wrap time to prevent large values causing precision issues
            float wrappedTime = mod(u_time, 10000.0);
            float t = wrappedTime * 0.02;
            
            // Use smoothed mod/floor for cell transitions to avoid hard edges
            vec2 cellPos = uv * 8.0;
            vec2 cellFract = fract(cellPos);
            // Apply smoothing at cell boundaries
            vec2 cellWeight = smoothstep(0.0, 0.1, cellFract) * smoothstep(1.0, 0.9, cellFract);
            vec2 cellCoord = floor(cellPos);
            
            // Generate cell pattern with smoother transitions across time
            float cellNoise = fract(sin(dot(cellCoord, vec2(12.9898, 78.233))) * 43758.5453);
            // Use a very slow time factor for stable cell evolution
            float cellTime = t * 0.05;
            float cellPattern = mix(
                cellNoise,
                fract(sin(dot(cellCoord + 1.0, vec2(12.9898, 78.233))) * 43758.5453),
                smoothstep(0.0, 1.0, sin(cellTime) * 0.5 + 0.5)
            );
            
            // Create continuous pattern transition with no hard edges
            float patternMod = cellPattern * 2.0 - 1.0;
            
            // Smooth coordinate wrapping to prevent jumps at boundaries
            vec2 phase = fract(uv * 2.5);
            vec2 wrappedPos = phase - 0.5;
            float dist = length(wrappedPos);
            
            // Create slow organic wave patterns
            float waveSpeed = t * 0.3;
            // Use higher harmonics with lower amplitudes for smoother motion
            float wavePattern = (
                sin(uv.x * 2.0 + waveSpeed) * cos(uv.y * 1.5 + waveSpeed * 0.7) * 0.15 +
                sin(uv.x * 4.0 + waveSpeed * 0.5) * cos(uv.y * 3.0 + waveSpeed * 0.4) * 0.1
            );
            
            // Create smooth cell boundaries with extra filtering
            float rawDist = fract(dist * 3.0);
            // Apply double smoothstep for extra-smooth edges
            float cellEdge = smoothstep(0.3, 0.7, rawDist) * (1.0 - smoothstep(0.7, 0.9, rawDist)) * 0.25;
            
            // Ensure thresholds change very gradually
            float thresholdTime = t * 0.1;
            float threshold = 0.4 + 0.1 * sin(thresholdTime);
            // Wide transition band and extra smoothing for threshold effects
            float reactionEffect = smoothstep(threshold - 0.3, threshold + 0.3, abs(noise)) * 0.2;
            
            // Create continuous rotational flow without angle discontinuities
            float flowTime = t * 0.08;
            // Avoid using raw atan which can create discontinuities at angle wrap points
            // Instead use separate sin/cos patterns that continuously wrap
            float flowX = sin(wrappedPos.x * 3.0 + flowTime) * 0.15;
            float flowY = cos(wrappedPos.y * 3.0 + flowTime * 1.1) * 0.15;
            float flow = (flowX + flowY) * patternMod * 0.5;
            
            // Smooth activator-inhibitor interaction
            float activator = noise * 0.5 + 0.5;
            float inhibitor = 1.0 - activator;
            float interaction = (activator * inhibitor * 3.0) * 0.15;
            
            // Create patterns that morph without discontinuities
            float morphSpeed = t * 0.15;
            float morphPattern = (
                sin(dist * 5.0 + morphSpeed) * 0.1 +
                cos(dist * 8.0 - morphSpeed * 0.7) * 0.08
            );
            
            // Gradual component blending to avoid spikes
            float rdComponent = wavePattern + cellEdge + reactionEffect + flow + interaction + morphPattern;
            
            // Use consistently smooth blend factor with limited range
            float blendSpeed = t * 0.04;
            float blendFactor = 0.45 + 0.1 * sin(blendSpeed);
            
            // Apply a temporal filter to smooth between frames
            // Store previous frame contribution in the current result
            noise = mix(noise, rdComponent, blendFactor);
            
            // Apply very gentle feedback with limited amplitude
            noise += 0.08 * sin(noise * 2.5);
            
            // Apply a safety clamp with smooth falloff to prevent edge cases
            float safeNoise = noise * 0.85;
            
            return safeNoise;
        }

        /////////////////////////////////////////////////////////////

        lowp float fastSin(float x) {
            // Wrap to -PI to PI range
            x = mod(x + M_PI, 2.0 * M_PI) - M_PI;
            
            // Fast sine approximation
            // Error < 0.002
            float x2 = x * x;
            return x * (1.0 - x2 / (3.0 * 2.0) + x2 * x2 / (5.0 * 4.0 * 3.0 * 2.0));
        }

        lowp float fastCos(float x) {
            return fastSin(x + M_PI * 0.5);
        }

        // Add fast hyperbolic tangent approximation
        lowp float fastTanh(float x) {
            // Fast approximation of tanh
            // Using the formula: tanh(x) â‰ˆ x / (1 + |x|)
            float absX = abs(x);
            float signX = x < 0.0 ? -1.0 : 1.0;
            return signX * absX / (1.0 + absX);
        }



        mediump float simplexNoise2(mediump vec2 v, float time) {
            // Wrap time to prevent precision issues with large values
            float wrappedTime = mod(u_time, 10000.0);
            float t = wrappedTime * 0.01; // Slower time factor for more fluid movement
            
            // Use more organic, continuous movement
            vec2 flowOffset = vec2(
                sin(t * 0.13) * cos(t * 0.07) * 0.15,
                cos(t * 0.11) * sin(t * 0.09) * 0.15
            );
            
            // Add secondary flow components for more organic motion
            flowOffset += vec2(
                sin(t * 0.05 + v.x * 0.1) * 0.1,
                cos(t * 0.04 + v.y * 0.1) * 0.1
            );
            
            // Apply domain warping for more fluid movement
            mediump vec2 p = v * 0.15;
            
            // Add position-dependent flow for more natural distortion
            p += flowOffset;
            
            // Gradually changing scale creates breathing effect
            float scaleVariation = 1.0 + sin(t * 0.03) * 0.15;
            float scale = 1.0 * scaleVariation;
            vec2 tilePos = p * scale;
            
            // Get tile coordinates
            vec2 cell = floor(tilePos);
            vec2 fractPos = fract(tilePos);
            
            // Get deterministic random value for this cell
            float cellId = fract(sin(dot(cell, vec2(12.9898, 78.233))) * 43758.5453);
            
            // Create temporal evolution for each cell
            float cellTime = t * 0.1;
            float cellPhase = sin(cellTime + cellId * 10.0) * 0.5 + 0.5;
            
            // Smooth tile rotation over time (less oscillatory)
            float baseRotation = floor(cellId * 4.0) * 0.5 * 3.14159;
            float rotationOffset = sin(t * 0.02 + cellId * 5.0) * 0.15; // Subtle rotation modulation
            float rotation = baseRotation + rotationOffset;
            
            // Rotate the position within the cell
            vec2 center = fractPos - 0.5;
            float s = sin(rotation);
            float c = cos(rotation);
            vec2 rotatedPos = vec2(
                center.x * c - center.y * s,
                center.x * s + center.y * c
            ) + 0.5;
            
            // Smooth morphing between pattern variations
            float patternMorph = smoothstep(0.0, 1.0, sin(t * 0.01 + cellId * 3.0) * 0.5 + 0.5);
            
            // Arc thickness varies subtly with time for organic pulsing
            float arcWidth = 0.1 + sin(t * 0.04 + cellId * 6.0) * 0.02;
            float arcThick = 0.5 + arcWidth;
            float arcThin = 0.5 - arcWidth;
            
            // Truchet basic pattern is made of quarter circles in opposite corners
            float arcPattern;
            
            // Create smooth transitions between tile types
            float tileTransition = smoothstep(0.45, 0.55, cellId + sin(t * 0.015 + length(cell) * 0.3) * 0.05);
            
            // Bottom-left to top-right with temporal modulation
            float dist1 = length(rotatedPos);
            float dist2 = length(rotatedPos - vec2(1.0, 1.0));
            float arc1 = smoothstep(arcThick, arcThin, dist1);
            float arc2 = smoothstep(arcThick, arcThin, dist2);
            float pattern1 = max(arc1, arc2);
            
            // Top-left to bottom-right with temporal modulation
            float dist3 = length(rotatedPos - vec2(0.0, 1.0));
            float dist4 = length(rotatedPos - vec2(1.0, 0.0));
            float arc3 = smoothstep(arcThick, arcThin, dist3);
            float arc4 = smoothstep(arcThick, arcThin, dist4);
            float pattern2 = max(arc3, arc4);
            
            // Blend between patterns for organic transitions
            arcPattern = mix(pattern1, pattern2, tileTransition);
            
            // Create tile boundaries with temporal variation
            float edgeWidth = 0.05 + sin(t * 0.03 + cellId * 4.0) * 0.01;
            float edge = max(
                smoothstep(edgeWidth, 0.0, min(fractPos.x, 1.0 - fractPos.x)),
                smoothstep(edgeWidth, 0.0, min(fractPos.y, 1.0 - fractPos.y))
            );
            
            // Add flowing detail to arcs - more fluid striped patterns
            float arcDetail = 0.0;
            
            // Calculate continuous angles for smooth animation
            float angle1 = atan(rotatedPos.y, rotatedPos.x);
            float angle2 = atan(rotatedPos.y - 1.0, rotatedPos.x - 1.0);
            float angle3 = atan(rotatedPos.y - 1.0, rotatedPos.x);
            float angle4 = atan(rotatedPos.y, rotatedPos.x - 1.0);
            
            // Evolving stripe frequency and phase
            float stripeFreq = 4.0 + sin(t * 0.02 + cellId * 7.0) * 1.0;
            float stripePhase = t * 0.05;
            
            // Create flowing wave patterns along the arcs
            float stripeFlow1 = sin(angle1 * stripeFreq + stripePhase + cellId * 10.0);
            float stripeFlow2 = sin(angle2 * stripeFreq + stripePhase + cellId * 11.0);
            float stripeFlow3 = sin(angle3 * stripeFreq + stripePhase + cellId * 12.0);
            float stripeFlow4 = sin(angle4 * stripeFreq + stripePhase + cellId * 13.0);
            
            // Smoother transitions for stripes using smoothstep instead of step
            float detail1 = smoothstep(-0.2, 0.2, stripeFlow1) * arc1;
            float detail2 = smoothstep(-0.2, 0.2, stripeFlow2) * arc2;
            float detail3 = smoothstep(-0.2, 0.2, stripeFlow3) * arc3;
            float detail4 = smoothstep(-0.2, 0.2, stripeFlow4) * arc4;
            
            // Blend details based on tile transition
            float details12 = max(detail1, detail2);
            float details34 = max(detail3, detail4);
            arcDetail = mix(details12, details34, tileTransition);
            
            // Add subtle reaction-diffusion effect similar to simplexNoise
            float reactionSpeed = t * 0.07;
            float reactionEffect = smoothstep(0.3, 0.7, 
                sin(length(rotatedPos - 0.5) * 8.0 + reactionSpeed) * 0.5 + 0.5
            ) * 0.15;
            
            // Create organic flow field distortion
            float flowFieldTime = t * 0.06;
            float flowX = sin(rotatedPos.x * 3.0 + flowFieldTime) * 0.1;
            float flowY = cos(rotatedPos.y * 3.0 + flowFieldTime * 1.1) * 0.1;
            float flowEffect = (flowX + flowY) * cellPhase * 0.2;
            
            // Combine patterns with organic blending
            float blendFactor = 0.4 + 0.1 * sin(t * 0.04);
            float basePattern = max(arcPattern * 0.8, arcDetail * 0.5);
            float organicPattern = basePattern + reactionEffect + flowEffect;
            
            // Add edge highlighting with temporal variation
            organicPattern = max(organicPattern, edge * (0.9 + sin(t * 0.05) * 0.1));
            
            // Add feedback influence for more fluid evolution
            float feedback = sin(organicPattern * 3.0 + t * 0.03) * 0.1;
            organicPattern += feedback;
            
            return organicPattern * 2.0 - 1.0;
        }

//////////////////////////////////////////////////



        

        vec2 domainWarp(vec2 p, float time) {
            float slowTime = u_time * 0.0001;
            
            float flow = simplexNoise2(p * 0.05 * (u_resolution.y / u_cellSize) + slowTime, slowTime);
            float detail = simplexNoise2(p * 0.1 * (u_resolution.y / u_cellSize) + slowTime * 1.5, slowTime * 2.0) * 0.3;
            
            // Use fast approximations
            float angle = slowTime * 0.1;
            float rotX = fastCos(angle) * flow;
            float rotY = fastSin(angle) * flow;
            
            return p + vec2(
                rotX * 1.5 + detail,
                rotY * 1.5 + detail
            );
        }

        float layeredNoise(vec2 p, float time) {
            // Simplified to single layer with detail
            float mainLayer = simplexNoise2(p, time);
            float detail = simplexNoise2(p * 2.0, time * 0.3) * 0.3;
            return mainLayer * 0.7 + detail * 0.3;
        }

        float fbmSimplexNoise(vec2 v, int octaves) {
            if (octaves <= 0) return 0.0;
            
            const float PERSISTENCE = 0.001;
            const float LACUNARITY = 0.0009;
            const int MAX_OCTAVES = 2;
            
            float total = 0.0;
            float amplitude = u_amplitude;
            float frequency = u_initialFreq;
            
            // Apply initial offsets
            v += u_nOS + vec2(u_nS);
            
            // Calculate base pattern with simplified domain warping
            vec2 warpedCoord = domainWarp(v, u_time * 0.1);
            float basePattern = layeredNoise(warpedCoord, u_time);
            total = amplitude * basePattern;
            
            // Simplified time influence - single noise sample
            float timeInfluence = simplexNoise(vec2(u_time * 0.05, 0.0), u_nS) * 0.5;
            
            // Only two octaves with simplified rotation
            float timeRotation = u_time * 0.05;
            // Precalculate sin/cos using fast approximations
            float sinRot = fastSin(timeRotation);
            float cosRot = fastCos(timeRotation);
            mat2 rot = mat2(cosRot, -sinRot, sinRot, cosRot);
            
            // First octave
            amplitude *= PERSISTENCE * 3.2;
            frequency *= LACUNARITY * (1.0 + timeInfluence * 0.2);
            total += amplitude * layeredNoise(rot * warpedCoord * frequency, u_time * 0.9);
            
            // Second octave (if needed)
            if (octaves > 1) {
                amplitude *= PERSISTENCE * 2.0;
                frequency *= LACUNARITY * (1.0 + timeInfluence * 0.2);
                total += amplitude * layeredNoise(rot * warpedCoord * frequency, u_time * 0.9);
            }
            
            // Apply final modulation
            return total * (timeInfluence * 0.9 + u_baseModulation);
        }


        lowp vec3 getColorFromPalette(float t) {
            t = clamp(t, 0.0, 4.0) * 7.0;
            int segment = int(t);
            float frac = t - float(segment);
            float phase = float(segment) / 7.0;
            
            vec3 color1, color2;
            
            // Use the random colors passed from JavaScript
                    color1 = mix(
                mix(u_randomColor1, u_randomColor2, sin(phase * 6.28318) * 0.5 + 0.5),
                u_randomColor3,
                        cos(phase * 9.42477) * 0.5 + 0.5
                    );
                    color2 = mix(
                mix(u_randomColor2, u_randomColor3, cos(phase * 12.56636) * 0.5 + 0.5),
                u_randomColor1,
                        sin(phase * 15.70796) * 0.5 + 0.5
                    );
            
            return mix(color1, color2, smoothstep(0.1, 0.9, frac));
        }

        lowp vec3 enhanceColor(vec3 color, float noiseValue) {
            const vec3 LUM_WEIGHTS = vec3(0.333, 0.333, 0.334);
            float luminance = dot(color, LUM_WEIGHTS);
            
            // Check if the color is monochromatic (all channels nearly equal)
            float maxDiff = max(max(abs(color.r - color.g), abs(color.g - color.b)), abs(color.b - color.r));
            bool isMonochrome = maxDiff < 0.05;
            
            if (isMonochrome) {
                // Enhanced monochrome processing
                float monoBoost = 1.0 + noiseValue * (u_isLightBackground ? 0.03 : 0.06);
                vec3 boosted = color * monoBoost;
                
                // Enhance contrast for monochrome
                float contrastPower = u_isLightBackground ? 0.92 : 0.88;
                vec3 contrasted = pow(boosted, vec3(contrastPower));
                
                // Add subtle tonal variation
                float variation = sin(luminance * 6.28318 + u_time * 0.1) * 0.02;
                contrasted += vec3(variation);
                
                // Ensure we maintain monochrome
                float finalLuminance = dot(contrasted, LUM_WEIGHTS);
                return vec3(finalLuminance);
            } else {
                // Adjust enhancement based on muted colors setting
                float noiseInfluence = 1.0 + noiseValue * (u_isLightBackground ? 0.02 : 0.04);
                if (u_useMutedColors) {
                    noiseInfluence *= 0.5; // Reduce noise influence for muted colors
                }
                
                vec3 boosted = color * (1.0 + (1.0 - luminance) * noiseInfluence);
                
                float saturationStrength;
                if (u_useMutedColors) {
                    saturationStrength = u_isLightBackground ? 0.85 : 0.9; // Lower saturation for muted colors
                } else {
                    saturationStrength = u_isLightBackground ? 1.1 : 1.2; // Original saturation for vivid colors
                }
                
                vec3 saturated = mix(vec3(luminance), boosted, vec3(saturationStrength));
                
                float contrastPower;
                if (u_useMutedColors) {
                    contrastPower = u_isLightBackground ? 0.97 : 0.95; // Less contrast for muted colors
                } else {
                    contrastPower = u_isLightBackground ? 0.95 : 0.92; // Original contrast for vivid colors
                }
                
                vec3 contrasted = pow(saturated, vec3(contrastPower));
                
                float highlightThreshold;
                if (u_useMutedColors) {
                    highlightThreshold = u_isLightBackground ? 0.97 : 0.95; // Higher threshold for muted colors
                } else {
                    highlightThreshold = u_isLightBackground ? 0.95 : 0.92; // Original threshold for vivid colors
                }
                
                vec3 highlights = smoothstep(highlightThreshold, 1.0, contrasted);
                contrasted = mix(contrasted, highlights * 0.9, u_useMutedColors ? 0.4 : 0.6);
                
                float finalMultiplier = u_useMutedColors ? 
                    (u_isLightBackground ? 0.9 : 0.95) :  // Lower multiplier for muted colors
                    (u_isLightBackground ? 0.95 : 1.05);  // Original multiplier for vivid colors
                    
                return contrasted * finalMultiplier;
            }
        }
        //VAR WITHOUT ENHANCEMENT////////////////////////////////
        //lowp vec3 enhanceColor(vec3 color, float noiseValue) {
            // Return the original color with no enhancement
            //return color;
        //}
        //////////////////////////////////////////////////////////////

        lowp vec3 blendColors(lowp vec3 a, lowp vec3 b, lowp float factor) {
            // Screen blend can use low precision
            lowp vec3 screen = 1.0 - (1.0 - a) * (1.0 - b * factor * 0.8);
            
            // Addition blend can use low precision
            lowp vec3 add = a + b * factor * 0.3;
            
            // Rotation influence calculation
            lowp float rotationInfluence = (1.0 + sin(u_roA + u_time * 0.1)) * 0.5;
            
            return mix(screen, add, 2.5 + rotationInfluence);
        }

        lowp vec2 getFlowDirection(mediump vec2 position, float time) {
            lowp float slowTime = u_time * u_sortAnimSpeed * 0.05;
            
            // Create cellular grid
            float cellSize = 200.0;
            vec2 cellCoord = floor(position / cellSize);
            
            // Generate stable random state for each cell
            float cellState = fract(sin(dot(cellCoord, vec2(12.9898, 78.233))) * 43758.5453);
            
            // Create state transitions based on neighbors
            float topState = fract(sin(dot(cellCoord + vec2(0.0, 1.0), vec2(12.9898, 78.233))) * 43758.5453);
            float rightState = fract(sin(dot(cellCoord + vec2(1.0, 0.0), vec2(12.9898, 78.233))) * 43758.5453);
            float bottomState = fract(sin(dot(cellCoord + vec2(0.0, -1.0), vec2(12.9898, 78.233))) * 43758.5453);
            float leftState = fract(sin(dot(cellCoord + vec2(-1.0, 0.0), vec2(12.9898, 78.233))) * 43758.5453);
            
            // Create time-varying state
            float timeState = step(0.5, sin(cellState * 10.0 + slowTime));
            
            // Generate flow based on neighbor states and rules
            vec2 flow = vec2(
                (rightState - leftState) * cos(slowTime + cellState * 10.0),
                (topState - bottomState) * sin(slowTime + cellState * 10.0)
            );
            
            // Add local vorticity based on cell state
            vec2 localPos = fract(position / cellSize) - 0.5;
            vec2 vortex = vec2(-localPos.y, localPos.x) * timeState;
            
            // Mouse influence section
            if (u_mouseActive) {
                // Calculate distance to mouse
                float mouseDistance = length(position - u_mouse);
                float mouseInfluenceRadius = u_mouseInfluenceRadius * u_cellSize;
                float mouseFactor = 0.0;
                
                // Calculate influence factor with smooth falloff
                if (mouseDistance < mouseInfluenceRadius) {
                    float normalizedDist = mouseDistance / mouseInfluenceRadius;
                    mouseFactor = (1.0 - normalizedDist * normalizedDist * (3.0 - 2.0 * normalizedDist));
                    
                    // Calculate direction vector for push effect
                    vec2 mouseDirection = normalize(position - u_mouse);
                    
                    // Apply mouse influence to the flow with smooth transition
                    flow = mix(flow, mouseDirection * 1.2, mouseFactor * 0.5 * u_mouseInfluenceRadius / 10.0);
                    
                    // Adjust vorticity near the mouse with smooth transition
                    vortex *= 1.0 + mouseFactor * 1.5 * u_mouseInfluenceRadius / 10.0;
                }
                
                // Trail influence - more efficient processing
                for (int i = 0; i < 20; i++) {
                    if (i >= u_trailCount) break;
                    
                    // Get trail position and calculate distance
                    vec2 trailPos = u_trailPositions[i];
                    float trailAge = u_trailTimes[i];
                    
                    // Skip too old points
                    if (trailAge >= 3.0) continue;
                    
                    // Calculate trail radius with age falloff
                    float trailRadius = mouseInfluenceRadius * 0.7 * (1.0 - trailAge / 3.0);
                    float trailDistance = length(position - trailPos);
                    
                    // Only process points within radius
                    if (trailDistance < trailRadius) {
                        float normalizedDist = trailDistance / trailRadius;
                        float trailFactor = (1.0 - trailAge / 3.0) * 
                                           (1.0 - normalizedDist * normalizedDist * (3.0 - 2.0 * normalizedDist));
                        
                        // Reduce strength with squared falloff and smooth transition
                        trailFactor = trailFactor * trailFactor * 0.3 * u_mouseInfluenceRadius / 10.0;
                        
                        // Skip negligible influences 
                        if (trailFactor > 0.01) {
                            // Direction from position to trail point
                            vec2 trailDirection = normalize(position - trailPos);
                            
                            // Blend influence with current flow
                            flow = mix(flow, trailDirection, trailFactor);
                        }
                    }
                }
            }
            
            // Combine and normalize the final flow direction
            return normalize(flow + vortex);
        }

        // Add this function before getGlyphPattern
        lowp vec4 getCASettings(float seed, float iter) {
            // Use seed and iteration to select pattern type
            float patternSeed = fract(seed * 12345.6789 + iter * 789.123);
            int patternType = int(mod(patternSeed * 4.0, 4.0));
            
            // Return vec4(dirBiasStrength, surviveThreshold, birthThreshold, edgeThreshold)
            if (patternType == 0) {
                // Organic, flowing patterns
                return vec4(0.4, 1.3, 2.3, 0.35);
            } else if (patternType == 1) {
                // Geometric, crystalline patterns
                return vec4(0.15, 1.6, 2.7, 0.5);
            } else if (patternType == 2) {
                // Chaotic, detailed patterns
                return vec4(0.3, 1.7, 2.2, 0.45);
            } else {
                // Symmetric patterns
                return vec4(0.25, 1.5, 2.5, 0.4);
            }
        }

        lowp float getGlyphPattern(vec2 cell, float depth, float seed, vec2 normalizedPos) {
            // Use cellular grid position for scaling with more stable transitions
            vec2 gridPos = floor(cell / 4.0) * 4.0;
            float gridValue = max(abs(gridPos.x), abs(gridPos.y)) * 0.25;
            float smoothGrid = smoothstep(0.0, 4.0, gridValue) * 0.5;
            
            // Use more stable noise calculation
            float stabilityNoise = noise(floor(cell / 8.0) * 8.0, seed) * 0.3;
            float scaleVariation = 1.0 + (smoothGrid * 0.4 + stabilityNoise) * u_caScaleVariation * 0.5;
            
            // Mouse influence calculation
            if (u_mouseActive) {
                vec2 approxWorldPos = cell * u_cellSize * 0.5;
                float mouseDistance = length(approxWorldPos - u_mouse);
                float mouseInfluenceRadius = u_mouseInfluenceRadius * 0.75 * u_cellSize;
                
                if (mouseDistance < mouseInfluenceRadius) {
                    float normalizedDist = mouseDistance / mouseInfluenceRadius;
                    float mouseFactor = (1.0 - normalizedDist * normalizedDist * (3.0 - 2.0 * normalizedDist)) * 0.3;
                    scaleVariation += mouseFactor * 0.2 * u_mouseInfluenceRadius / 10.0;
                }
            }
            
            // Pre-calculate scaled cell position
            vec2 scaledCell = floor(cell * scaleVariation * 2.0) * 0.5;
            vec2 id = floor(scaledCell * 2.0);
            
            // Generate base pattern
            float basePattern = noise(floor(id * 0.5) * 2.0, seed + floor(depth));
            float state = step(0.5, basePattern);
            
            // Geometric properties
            float angle = atan(scaledCell.y, scaledCell.x);
            float radius = length(scaledCell) * 2.0;
            
            // Get CA settings
            vec4 caSettings = getCASettings(seed, floor(depth));
            float dirBias = sin(angle * floor(depth + 1.0)) * caSettings.x;
            
            // CA simulation with fixed neighbors
            float neighbors = 0.0;
            
            // Calculate neighbors using individual offsets
            vec2 neighbor;
            float neighborState;
            
            // Right neighbor
            neighbor = floor(id + vec2(1.0, 0.0));
            neighborState = step(0.5, noise(neighbor * 0.5, seed));
            neighbors += neighborState * (1.0 + dirBias * 0.2);
            
            // Left neighbor
            neighbor = floor(id + vec2(-1.0, 0.0));
            neighborState = step(0.5, noise(neighbor * 0.5, seed));
            neighbors += neighborState * (1.0 + dirBias * 0.2);
            
            // Top neighbor
            neighbor = floor(id + vec2(0.0, 1.0));
            neighborState = step(0.5, noise(neighbor * 0.5, seed));
            neighbors += neighborState * (1.0 + dirBias * 0.2);
            
            // Bottom neighbor
            neighbor = floor(id + vec2(0.0, -1.0));
            neighborState = step(0.5, noise(neighbor * 0.5, seed));
            neighbors += neighborState * (1.0 + dirBias * 0.2);
            
            // Rule application
            float depthRule = floor(mod(depth * 1.618 + seed * 3.14159, 2.0));
            
            if (depthRule < 1.0) {
                float surviveThreshold = caSettings.y + sin(angle * 2.0) * 0.1;
                state = step(surviveThreshold - 0.1, neighbors) * 
                        step(neighbors, surviveThreshold + 1.1) * state + 
                        step(caSettings.z - 0.1, neighbors) * 
                        step(neighbors, caSettings.z + 0.1) * (1.0 - state);
            } else {
                float edgeThreshold = caSettings.w + cos(radius) * 0.1;
                state = step(edgeThreshold, abs(neighbors - 2.0 - dirBias));
            }
            
            // Geometric pattern
            float geoPattern = smoothstep(0.4, 0.6, 
                sin(floor(radius * (2.0 + depth * 0.5)) + 
                    floor(angle * (4.0 + depth * 0.3)) + 
                    floor(depth) + seed) * 0.5 + 0.5
            );
            
            // Pattern blending
            float blendFactor = 0.5 + 0.1 * sin(floor(depth) * 1.5);
            float finalPattern = mix(state, geoPattern, blendFactor);
            
            // Detail noise
            float detail = noise(floor(scaledCell * (depth + 1.0) * 2.0) * 0.5, seed + floor(depth));
            return mix(finalPattern, detail, 0.1);
        }

        // Add HSL conversion functions before main()
        float hue2rgb(float p, float q, float t) {
            if (t < 0.0) t += 1.0;
            if (t > 1.0) t -= 1.0;
            if (t < 1.0/6.0) return p + (q - p) * 6.0 * t;
            if (t < 1.0/2.0) return q;
            if (t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;
            return p;
        }

        vec3 rgb2hsl(vec3 color) {
            float maxColor = max(max(color.r, color.g), color.b);
            float minColor = min(min(color.r, color.g), color.b);
            float delta = maxColor - minColor;
            
            float h = 0.0;
            float s = 0.0;
            float l = (maxColor + minColor) / 2.0;
            
            if (delta > 0.0) {
                s = l < 0.5 ? delta / (maxColor + minColor) : delta / (2.0 - maxColor - minColor);
                
                if (maxColor == color.r) {
                    h = (color.g - color.b) / delta + (color.g < color.b ? 6.0 : 0.0);
                } else if (maxColor == color.g) {
                    h = (color.b - color.r) / delta + 2.0;
                } else {
                    h = (color.r - color.g) / delta + 4.0;
                }
                h /= 6.0;
            }
            
            return vec3(h, s, l);
        }
        
        vec3 hsl2rgb(vec3 hsl) {
            float h = hsl.x;
            float s = hsl.y;
            float l = hsl.z;
            
            float r, g, b;
            
            if (s == 0.0) {
                r = g = b = l; // Achromatic
            } else {
                float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
                float p = 2.0 * l - q;
                r = hue2rgb(p, q, h + 1.0/3.0);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1.0/3.0);
            }
            
            return vec3(r, g, b);
        }

        void main() {
            // Constants can use low precision
            const lowp int MAX_LOOP_DEPTH = 6;
            
            // Coordinate calculations need medium precision
            mediump vec2 coord = (vTexCoord * u_resolution - u_resolution * 0.25) * u_scaleFactor + u_translation;
            coord = coord / u_bS;
            
            // Grid distortion calculation can use medium precision
            mediump float gridDistortTime = u_time * u_sortAnimSpeed * 0.1;
            mediump vec2 gridDistortCoord = coord * u_sortFrequency;
            
            // Most pattern calculations can use low precision
            lowp float distortNoise1 = fbmSimplexNoise(gridDistortCoord + vec2(gridDistortTime * 0.1), 2);
            lowp float distortNoise2 = fbmSimplexNoise(gridDistortCoord + vec2(gridDistortTime * -0.15), 2);
            
            // Pattern vectors can use low precision since normalized
            lowp vec2 expPattern, stepPattern, circularPattern, squarePattern, flowPattern, smoothFlowPattern;
            
            // Pattern 1: Exponential waves
            expPattern = vec2(
                exp(-abs(mod(distortNoise1 + gridDistortTime, 2.0) - 1.0)) - 0.5,
                exp(-abs(mod(distortNoise2 + gridDistortTime, 2.0) - 1.0)) - 0.5
            );
            
            // Pattern 2: Stepped/quantized movement
            stepPattern = vec2(
                floor(distortNoise1 * 4.0) / 4.0,
                floor(distortNoise2 * 4.0) / 4.0
            );
            
            // Pattern 3: Circular/spiral movement
            float angle = distortNoise1 * 6.28318;
            circularPattern = vec2(
                cos(angle) * distortNoise2,
                sin(angle) * distortNoise2
            );
            
            // Pattern 4: Square/diamond pattern
            squarePattern = vec2(
                sign(fract(distortNoise1 * 2.0) - 0.5) * abs(fract(distortNoise2 * 2.0) - 0.5),
                sign(fract(distortNoise2 * 2.0) - 0.5) * abs(fract(distortNoise1 * 2.0) - 0.5)
            );
            
            // Pattern 5: Smooth directional flow with rotation
            flowPattern = vec2(
                distortNoise1 * cos(gridDistortTime * 0.2) - distortNoise2 * sin(gridDistortTime * 0.15),
                distortNoise1 * sin(gridDistortTime * 0.2) + distortNoise2 * cos(gridDistortTime * 0.15)
            );
            
            // Add subtle vorticity
            float vortexStrength = 0.3;
            float vortexAngle = atan(coord.y, coord.x) + gridDistortTime * 0.1;
            vec2 vortexOffset = vec2(
                cos(vortexAngle) * length(flowPattern) * vortexStrength,
                sin(vortexAngle) * length(flowPattern) * vortexStrength
            );
            
            // Combine flow and vortex with smooth transition
            smoothFlowPattern = flowPattern + vortexOffset;
            
            // Add progressive movement (modified for more organic flow)
            float flowTime = gridDistortTime * 0.05;
            smoothFlowPattern += vec2(
                simplexNoise(vec2(flowTime * 0.7, 0.0), 0.0) * 0.15,
                simplexNoise(vec2(flowTime * 0.8, 1.0), 0.0) * 0.15
            );
            
            // Select pattern based on uniform
            vec2 finalPattern;
            if (u_currentPattern == 5) {
                finalPattern = smoothFlowPattern;
            } else if (u_currentPattern == 0) {
                // Mixed patterns with smooth transitions
                float patternMix = fract(gridDistortTime * 0.1);
                finalPattern = mix(
                    mix(expPattern, stepPattern, smoothstep(0.0, 0.33, patternMix)),
                    mix(circularPattern, squarePattern, smoothstep(0.66, 1.0, patternMix)),
                    smoothstep(0.33, 0.66, patternMix)
                );
            } else if (u_currentPattern == 1) {
                finalPattern = expPattern;
            } else if (u_currentPattern == 2) {
                finalPattern = stepPattern;
            } else if (u_currentPattern == 3) {
                finalPattern = circularPattern;
            } else {
                finalPattern = squarePattern;
            }
            
            // Replace the conditional check with random selection for grid distortion
            mediump vec2 gridOffset = vec2(0.0);
            
            // Generate a pseudorandom value for this specific position and time
            float distortionRandom = fract(sin(dot(coord + vec2(gridDistortTime), vec2(12.9898, 78.233))) * 43758.5453);
            
            // Random chance to apply distortion (30% probability)
            if (distortionRandom < 0.3) {
                // Apply different strengths based on randomness
                float randomStrength = 0.5 + distortionRandom * 1.5; // Varies from 0.5 to 2.0
                gridOffset = finalPattern * u_sortStrength * u_cellSize * randomStrength;
                
                // Apply randomized wave effect
                float waveFreq = 0.5 + distortionRandom * 1.0; // Varies from 0.5 to 1.5
                coord += gridOffset * (1.0 + sin(gridDistortTime * waveFreq) * 0.3);
            }
            
            vec2 gridCoord = floor(coord / u_cellSize);
            vec2 cellCenter = (gridCoord + 0.5) * u_cellSize;
            vec2 localPos = coord - cellCenter;

            // Cell boundary check can use lower precision
            lowp float cellBoundary = u_cellSize * 0.485;
            lowp float edgeFade = 0.005;
            
            // Get flow direction and cellular automata state for current cell
            vec2 flowDir = getFlowDirection(cellCenter, u_time);
            float flowAngle = atan(flowDir.y, flowDir.x);
            
            // Use cellular automata state to determine cell shape
            // This uses the same CA logic as in getFlowDirection function
            float cellSize = 100.0;
            vec2 caCoord = floor(cellCenter / cellSize);
            
            // Generate stable CA state for current cell
            float caState = fract(sin(dot(caCoord, vec2(12.9898, 78.233))) * 43758.5453);
            
            // Get neighboring cell states for more context
            float topState = fract(sin(dot(caCoord + vec2(0.0, 1.0), vec2(12.9898, 78.233))) * 43758.5453);
            float rightState = fract(sin(dot(caCoord + vec2(1.0, 0.0), vec2(12.9898, 78.233))) * 43758.5453);
            float bottomState = fract(sin(dot(caCoord + vec2(0.0, -1.0), vec2(12.9898, 78.233))) * 43758.5453);
            float leftState = fract(sin(dot(caCoord + vec2(-1.0, 0.0), vec2(12.9898, 78.233))) * 43758.5453);
            
            // Calculate cellular automata patterns
            float slowTime = u_time * u_sortAnimSpeed * 0.05;
            float timeVaryingState = sin(caState * 10.0 + slowTime);
            
            // Create a CA rule: cells become round when they are "active" in the automata
            // This creates a more interesting pattern than just thresholding the CA state
            float neighborSum = topState + rightState + bottomState + leftState;
            float caRuleValue = (neighborSum > 2.0 && timeVaryingState > 0.0) || timeVaryingState > 0.7 ? 1.0 : 0.0;
            
            // Add some random variation for more organic distribution
            float randomFactor = fract(sin(dot(gridCoord, vec2(43.9898, 38.233))) * 53758.5453);
            bool isRoundCell = (caRuleValue > 0.5) || (randomFactor > 0.95 && timeVaryingState > 0.0);
            
            // Check boundary based on cell shape
            bool isWithinCell;
            if (isRoundCell) {
                // Round cell boundary check
                isWithinCell = length(localPos) <= cellBoundary;
            } else {
                // Square cell boundary check (original)
                isWithinCell = all(lessThanEqual(abs(localPos), vec2(cellBoundary)));
            }
            
            if (!isWithinCell) {
                // Smooth edge transition based on cell shape
                float fadeAlpha;
                if (isRoundCell) {
                    // Round cell edge fade
                    float edgeDistance = length(localPos) - cellBoundary;
                    fadeAlpha = 1.0 - smoothstep(0.0, edgeFade, edgeDistance);
                } else {
                    // Square cell edge fade (original)
                    vec2 edgeDistance = abs(localPos) - vec2(cellBoundary);
                    fadeAlpha = 1.0 - smoothstep(0.0, edgeFade, max(edgeDistance.x, edgeDistance.y));
                }
                if (fadeAlpha <= 0.0) discard;
            }

            // Pre-calculate values needed for the depth loop
            float distToCenter = length(coord - cellCenter);
            float timeScale = u_time * 0.1;
            vec2 baseNoiseCoord = gridCoord * 0.1;
            vec2 timeOffset = vec2(timeScale, timeScale + 100.0);
            
            // Calculate distortion influence once
            float distortionInfluence = length(gridOffset) / (u_cellSize * 2.0);
            float baseNoiseFBM = fbmSimplexNoise(gridCoord * (u_cellSize / u_resolution.y) * 0.05, 4) + distortionInfluence * 0.2;
            
            vec2 noiseOffset = vec2(
                noise(baseNoiseCoord + timeOffset.xx, u_nS),
                noise(baseNoiseCoord + timeOffset.yy, u_nS)
            );
            
            // Pre-calculate common values for the loop
            float gridSize = u_cellSize * mix(0.3, 2.5, baseNoiseFBM + distortionInfluence * 0.2);
            vec2 localCoord = mod(coord + noiseOffset, gridSize);
            
            float randomAngle = floor(noise(gridCoord + noiseOffset, u_nS) * 4.0) * (M_PI * 0.5);
            float sinA = fastSin(randomAngle);
            float cosA = fastCos(randomAngle);
            vec2 rotatedCoord = vec2(
                localCoord.x * cosA - localCoord.y * sinA,
                localCoord.x * sinA + localCoord.y * cosA
            );
            
            float smoothedTime = u_time * 0.01 + simplexNoise2(vec2(u_time * 0.3, 50.0), u_nS) * 0.005;
            
            vec2 noiseInput1 = rotatedCoord * ((u_cellSize / u_resolution.y) * 1.0) + smoothedTime;
            vec2 noiseInput2 = (rotatedCoord + gridCoord * gridSize) * ((u_cellSize / u_resolution.y) * 1.0) * u_noiseScale;
            
            float flowNoise = fbmSimplexNoise(noiseInput1, 6);
            vec2 animatedCoord = noiseInput2 + vec2(
                simplexNoise(vec2(flowNoise, u_time * 0.05), u_nS),
                simplexNoise(vec2(flowNoise, u_time * 0.05 + 100.0), u_nS)
            ) * u_flowSpeed * 0.005;
            
            float curlNoise = fbmSimplexNoise(animatedCoord * (u_cellSize / u_resolution.y) * 20.0 + vec2(u_nS), 8);
            animatedCoord += 4.0 * vec2(
                cos(curlNoise * 6.28318),
                sin(curlNoise * 6.28318)
            );
            
            // Color blending can use low precision
            lowp vec4 color = vec4(0.0);
            
            // Main loop variables
            mediump float depthNoiseValue, depthFactor, colorT;
            lowp vec3 color1, color2, enhancedColor1, enhancedColor2, blendedColor;
            
            // Calculate base noise values that won't change in the loop
            float baseNoise = fbmSimplexNoise(animatedCoord * (u_cellSize / u_resolution.y) * 0.15 + noiseOffset, 5);
            float combinedNoise = (baseNoise * 0.3 + baseNoiseFBM * 0.7 + 3.0) * 0.3;
            
            // Calculate depth once
            float clampedNoise = clamp(combinedNoise, 0.0, 1.0);
            int dynamicDepth = int(clamp(
                clampedNoise * float(u_maxDepth),
                1.0,
                min(float(u_maxDepth), float(MAX_LOOP_DEPTH))
            ));
            
            // Pre-calculate threshold and blend factor outside loop
            float threshold = 0.55 - (0.15 * pow(1.0 - u_bS, 2.0));
            
            float t = simplexNoise2(vec2(u_time * 0.01), 0.0) * 0.5 + 0.5;
            float angleInfluence = simplexNoise2(vec2(u_time * 0.005), 0.0) * 0.5 + 0.5;
            float blendFactor = t * t * (3.0 - 2.0 * t) * (1.0 + combinedNoise * 0.8 + angleInfluence * 1.2);
            
            // Prepare edge values for color transitions
            float edge0 = 0.2 + sin(u_time * 0.0002) * 0.3;
            float edge1 = 0.8 + cos(u_time * 0.0002) * 0.5;
            
            // Process each depth level with minimal branching
            for (int depth = 0; depth < MAX_LOOP_DEPTH; depth++) {
                // Break condition at the top to avoid unnecessary loop iterations
                if (depth >= dynamicDepth) break;
                
                depthNoiseValue = noise(animatedCoord * float(depth + 1), u_nS);
                depthFactor = float(depth) / float(MAX_LOOP_DEPTH);
                
                // Skip early if noise threshold not met
                if (depthNoiseValue <= threshold) {
                    continue;
                }
                
                // Get glyph parameters
                float currentSize = mix(0.3, 1.2, depthFactor) * u_cellSize;
                
                // Rotate point to align with flow
                vec2 rotatedP = vec2(
                    localPos.x * fastCos(-flowAngle) - localPos.y * fastSin(-flowAngle),
                    localPos.x * fastSin(-flowAngle) + localPos.y * fastCos(-flowAngle)
                );
                
                // Glyph grid calculation
                // Map flow influence to offset range
                float flowStrength = length(flowDir);  // Get magnitude of flow vector
                float mappedOffset = mix(0.5, 1.2, flowStrength);  // Map to desired range
                vec2 glyphCell = floor(rotatedP / currentSize + mappedOffset);
                vec2 localGlyphPos = rotatedP - glyphCell * currentSize;
                
                // Get glyph pattern
                float glyphNoise = getGlyphPattern(glyphCell, float(depth), u_nS, vTexCoord);
                
                // Simplified glyph checks
                bool centerActive = abs(glyphCell.x) < 0.5 && abs(glyphCell.y) < 0.5;
                bool noiseActive = length(glyphCell) < 1.5 && glyphNoise > 0.5;
                bool lineActive = abs(localGlyphPos.x) < currentSize * 0.15 || abs(localGlyphPos.y) < currentSize * 0.15;
                
                bool insideGlyph = centerActive || noiseActive || lineActive;
                
                // Skip if not inside glyph
                if (!insideGlyph) {
                    continue;
                }
                
                // Color calculation
                colorT = smoothstep(edge0, edge1, depthFactor + combinedNoise * 0.9);
                
                color1 = getColorFromPalette(colorT);
                color2 = getColorFromPalette(1.0 - colorT);
                
                // Apply depth boost
                float depthBoost = 1.2 + (1.0 - depthFactor) * 0.8;
                color1 *= depthBoost;
                color2 *= depthBoost;
                
                enhancedColor1 = enhanceColor(color1, combinedNoise);
                enhancedColor2 = enhanceColor(color2, combinedNoise);
                
                blendedColor = blendColors(enhancedColor1, enhancedColor2, blendFactor);
                
                // Add to final color with alpha blending
                color.rgb *= 1.0;
                color += vec4(blendedColor, 1.0) * (1.0 - depthNoiseValue * 0.7);
            }
            
            // Final color check
            if (color.a == 0.0) {
                color = u_baseColor;
            }
            
            // Add mouse circle visualization before finalizing the color
            if (u_mouseActive) {
                // Calculate distance from current pixel to mouse position
                float mouseDistance = length(coord - u_mouse);
                
                // Create a larger circle with 10 cell size diameter
                float circleRadius = u_cellSize * 10.0; // Increased to 10 cells
                
                // Note: We're keeping the mouse position active for the flow field and glyph effects
                // but removing the color blending effects for the cursor itself
                
                // Process trail points
                for (int i = 0; i < 20; i++) { // Use constant 20 since GLSL doesn't support variable loop limits well
                    if (i >= u_trailCount) break; // Skip if we've processed all actual trail points
                    
                    // Get trail position - needed for flow field interactions
                    // But we're not applying any color effects
                }
            }
            
            gl_FragColor = color;
        }
    </script>

    <script>
        // Configuration
        const TARGET_FRAMERATE = 60; // Target frame rate (can be lowered for better performance)
        let lastFrameTime = 0;      // For frame rate control
        let currentFPS = 60;        // Track current FPS
        let fpsUpdateTime = 0;      // Time of last FPS update
        const FPS_UPDATE_INTERVAL = 500; // Update FPS every 500ms
        
        let bS = 1.0;     
        const cV = 6;  
        let tS;
        let dM = 0;
        let cS;      
        let bN = 0.002;  
        let nS;
        let fS = 0.005;
        let rSS;
        let roA;
        let nOX, nOY;
        let scF = 40;
        let tX = 0, tY = 0;
        let iTX = 0, iTY = 0;
        let pMX, pMY;
        let amV = [0.1, 0.075, 0.05]; 
        let isP = false; // Start paused
        let stT = 0;
        let cuT = 0;
        let lastPausedTime = 0; // Initialize paused time to 0
        let lum = 1.5;
        let vib = 2.5;
        let soS = 0.1;     
        let soF = 0.1;   
        let soA = 0.15;     
        let cuP;                  
        
        // Add mouse tracking variables
        let mouseX = 0, mouseY = 0;
        let panMouseX = 0, panMouseY = 0; // Add separate variables for panning
        let isMouseOnCanvas = false;
        let mouseInfluenceFactor = 0.0; // Add fade-in factor for mouse influence
        const MOUSE_INFLUENCE_FADE_SPEED = 0.15; // Speed of fade-in/out

        // Add trail system
        const MAX_TRAIL_POINTS = 20; // Maximum number of trail points to store
        const MIN_DISTANCE = 5; // Minimum distance between trail points
        const TRAIL_LIFETIME = 3000; // Time in ms before a trail point disappears
        let trailPoints = []; // Array to store trail points [{x, y, time}]
        
        // Cache canvas element reference
        let canvasElement;
        
        let tog = {
        };

        let inscription_id = window.location.pathname.split("/").pop();
        
        // DEVELOPMENT CODE - REMOVE BEFORE PRODUCTION DEPLOYMENT
        // This code generates a random inscription ID for testing
        // ===================================================
            let chars = "0123456789abcdefghijklmnopqrstuvwsyz";
            inscription_id = new URLSearchParams(window.location.search).get("seed") || Array(64).fill(0).map(_=>chars[(Math.random()*chars.length)|0]).join('');
        // ===================================================

        // Debug logging - uncomment if needed for debugging
        // console.log('Inscription ID:', inscription_id)

        class Rnd{
            constructor(seed) {
                const i=Math.imul,h=t=>{let e,l=0;for(e=1779033703^t.length;l<t.length;l++){let h=e^t.charCodeAt(l);e=i(h,3432918353),e=e<<13|e>>>19}return()=>(e=i(e^e>>>16,2246822507),e=i(e^e>>>13,3266489909),(e^=e>>>16)>>>0)},a=(e,r,t,a)=>()=>{let l=((e|=0)+(r|=0)|0)+(a|=0)|0;return a=a+1|0,e=r^r>>>9,r=(t|=0)+(t<<3)|0,t=(t=t<<21|t>>>11)+l|0,(l>>>0)/4294967296},X=h(seed);this.R=a(X(),X());
            }
            D=_=>this.R();                  
            N=(r,t)=>r+(t-r)*this.D();     
            I=(r,t)=>0|this.N(r,t+1);      
            B=r=>this.D()<r               
        };
        let R = new Rnd(inscription_id)

        console.log('Inscription ID:', inscription_id)


        function upTC() {
            let viW = width / scF;
            let viH = height / scF;
            
            // Calculate the relative position from the center
            let relX = (tX + width/2) / (width/scF);
            let relY = (tY + height/2) / (height/scF);
            
            // Apply the relative position with the new scale
            tX = -width/2 + (relX * width/scF);
            tY = -height/2 + (relY * height/scF);
        }

        function preload() {
            let vertexShader = document.getElementById('vertex-shader').textContent;
            let fragmentShader = document.getElementById('fragment-shader').textContent;
            tS = createShader(vertexShader, fragmentShader);
        }

        function suEH() {
           
            const canvas = document.querySelector('canvas');
            
            // Add mouse event listeners for panning
            let isDragging = false;
            let startX, startY;
            let startTX, startTY;
            
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startTX = tX;
                startTY = tY;
                canvas.style.cursor = 'grabbing';
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    // Apply the translation directly in shader space
                    const dx = -(e.clientX - startX);
                    const dy = (e.clientY - startY);
                    tX = startTX + dx*8;
                    tY = startTY + dy*8;
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
            
            // Set initial cursor style
            canvas.style.cursor = 'grab';
            
            const keyState = new Set();
            
            document.addEventListener('keydown', (e) => {
                
                if (keyState.has(e.key)) return;
                keyState.add(e.key);
                
                switch(e.key.toLowerCase()) {
                    case 'a':
                        dM = (dM + 1) % 4;  // Changed from % 3 to % 4 to include the new case 3
                        upCS();
                        break;
                        
                    case 'r':
                        tX = iTX;
                        tY = iTY;
                        upTC();
                        break;
                        
                    case 's':
                        isP = !isP;
                        if (isP) {
                            // When starting/resuming animation
                            stT = millis() - (lastPausedTime * 1000); // Adjust start time to account for paused time
                        } else {
                            // When pausing animation
                            lastPausedTime = cuT; // Store current time
                        }
                        break;
                        
                    case '1':
                    case '2':
                    case '3':
                        {  
                            const cuD = pixelDensity();
                            const nwD = e.key === '1' ? 4 : (e.key === '2' ? 5 : 5.5);
                            
                            
                            pixelDensity(nwD);
                            draw();
                            
                           
                            const tiS = geT();
                            const prefix = e.key === '1' ? 'shader_' : 'shader_hires_';
                            saveCanvas(prefix + tiS, 'png');
                            
                           
                            pixelDensity(cuD);
                            draw();
                            break;  
                        }
                         
                    case 'd':
                        
                        if (scF === 40) {
                            scF = 15;
                        } else {
                            scF = 40;
                        }
                        upTC();
                        break;
                        
                    
                    case 'k':
                        if (!isR) {
                            stRe();
                        } else {
                            noRe();
                        }
                        break;
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keyState.delete(e.key);
            });
        }

        
        function geT() {
            const d = new Date();
            const pad = n => n.toString().padStart(2, '0');
            return `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
        }

        function setup() {
            let canvas = createCanvas(windowWidth, windowHeight, WEBGL);
            // Store reference to canvas element
            canvasElement = document.querySelector('canvas');
            
            let gl = canvas.GL;
            gl.disable(gl.DEPTH_TEST);  
            gl.disable(gl.CULL_FACE);   
            gl.disable(gl.DITHER);      
            gl.disable(gl.STENCIL_TEST);
            
            pixelDensity(2);
            
            noStroke();
            shader(tS);
            
            if (!inscription_id) {
                return;
            }
            
            // Initialize animation state with proper synchronization
            const currentTime = millis();
            stT = currentTime;
            lastPausedTime = 0;
            cuT = 0;
            isP = false; // Start paused
            
            cuP = R.I(0, 5);
            
            tS = createShader(
                document.getElementById('vertex-shader').textContent,
                document.getElementById('fragment-shader').textContent
            );
            shader(tS);
            tS.setUniform('u_currentPattern', cuP);
            
            upCS();
            
            nOX = R.I(0,2000)
            nOY = R.I(0,2000)

            let shiftX = -width/2;
            let shiftY = -height/2;
            iTX = shiftX;
            iTY = shiftY;
            tX = shiftX;
            tY = shiftY;

            nS = R.I(0,1000)
            rSS = R.I(0,1000)
            roA = R.I(0, 360)
            
            let teR = R.I(0, amV.length - 1);
            let raA = amV[teR];
            let seF = R.N(10.0, 0.000001);  
            cS = windowHeight / cV;
            bN = R.N(0.002, 0.005);
            let baM = R.N(0.5, 2.0);  

            function caCD(color1, color2) {
                const dr = color1[0] - color2[0];
                const dg = color1[1] - color2[1];
                const db = color1[2] - color2[2];
                return Math.sqrt(dr * dr + dg * dg + db * db);
            }

            // Add monochromatic palette definitions
            const MONO_PALETTES = {
                HIGH_CONTRAST: {
                    dark: [0.02, 0.02, 0.02],
                    mid: [0.35, 0.35, 0.35],
                    light: [0.85, 0.85, 0.85]
                },
                LOW_CONTRAST: {
                    dark: [0.15, 0.15, 0.15],
                    mid: [0.35, 0.35, 0.35],
                    light: [0.55, 0.55, 0.55]
                },
                INFRARED: {
                    dark: [0.05, 0.05, 0.05],
                    mid: [0.3, 0.3, 0.3],
                    light: [0.8, 0.8, 0.8]
                },
                SEPIA: {
                    dark: [0.1, 0.08, 0.06],
                    mid: [0.35, 0.3, 0.25],
                    light: [0.7, 0.65, 0.6]
                },
                SPLIT_TONE: {
                    dark: [0.1, 0.1, 0.15],
                    mid: [0.3, 0.3, 0.35],
                    light: [0.6, 0.55, 0.5]
                }
            };

            let isMonochrome = false;
            let currentMonoPalette = null;
            let useMutedColors = R.D() < 0.5;

            function geRC(brightnessType = 'light', baseHue = null, existingColors = []) {
                if (!isMonochrome && R.D() < 0.05) {
                    isMonochrome = true;
                    const paletteKeys = Object.keys(MONO_PALETTES);
                    currentMonoPalette = MONO_PALETTES[paletteKeys[Math.floor(R.D() * paletteKeys.length)]];
                }

                if (isMonochrome) {
                    return {
                        color: currentMonoPalette[brightnessType.toLowerCase()],
                        hue: 0
                    };
                }

                const miCD = 0.3;
                let at = 0;
                const maA = 10;

                while (at < maA) {
                    let h = brightnessType === 'mid' && baseHue !== null ? (baseHue + 0.5) % 1.0 : R.D();
                    let s = useMutedColors ? R.N(0.3, 0.5) : R.N(0.7, 0.75);
                    let v;

                    if (useMutedColors) {
                        switch(brightnessType) {
                            case 'dark': v = R.N(0.2, 0.35); break;
                            case 'mid': v = R.N(0.45, 0.6); break;
                            case 'light': v = R.N(0.7, 0.85); break;
                        }
                    } else {
                        switch(brightnessType) {
                            case 'dark': v = R.N(0.15, 0.3); break;
                            case 'mid': v = R.N(0.5, 0.65); break;
                            case 'light': v = R.N(0.85, 1.0); break;
                        }
                    }

                    let i = Math.floor(h * 6);
                    let f = h * 6 - i;
                    let p = v * (1 - s);
                    let q = v * (1 - f * s);
                    let t = v * (1 - (1 - f) * s);

                    let r, g, b;
                    switch (i % 6) {
                        case 0: r = v, g = t, b = p; break;
                        case 1: r = q, g = v, b = p; break;
                        case 2: r = p, g = v, b = t; break;
                        case 3: r = p, g = q, b = v; break;
                        case 4: r = t, g = p, b = v; break;
                        case 5: r = v, g = p, b = q; break;
                    }

                    const newColor = [r, g, b];
                    let diC = true;
                    for (const existingColor of existingColors) {
                        if (caCD(newColor, existingColor) < miCD) {
                            diC = false;
                            break;
                        }
                    }

                    if (diC || at === maA - 1) {
                        return { color: newColor, hue: h };
                    }
                    at++;
                }
            }

            let liR = geRC('light', null, []);
            let rC1 = liR.color;
            let miR = geRC('mid', liR.hue, [rC1]);
            let rC2 = miR.color;
            let rC3 = geRC('dark', null, [rC1, rC2]).color;

            let baC = [
                [0.05, 0.05, 0.05, 1.0],
                [0.90, 0.87, 0.82, 1.0]
            ];

            let sBaC = baC[R.D() < 0.6 ? 0 : 1];
            let liBc = sBaC[0] > 0.5;

            // Set all uniforms
            tS.setUniform('u_nS', nS);
            tS.setUniform('u_rSS', rSS);
            tS.setUniform('u_roA', radians(roA));
            tS.setUniform('u_nOS', [nOX, nOY]);
            tS.setUniform('u_amplitude', raA);
            tS.setUniform('u_maxDepth', 6);
            tS.setUniform('u_luminosity', lum);
            tS.setUniform('u_vibrancy', vib);
            tS.setUniform('u_initialFreq', seF);
            tS.setUniform('u_sortStrength', soS);
            tS.setUniform('u_sortFrequency', soF);
            tS.setUniform('u_sortAnimSpeed', soA);
            tS.setUniform('u_baseModulation', baM);
            tS.setUniform('u_baseColor', sBaC);
            tS.setUniform('u_isLightBackground', liBc);
            tS.setUniform('u_useMutedColors', useMutedColors);
            tS.setUniform('u_randomColor1', rC1);
            tS.setUniform('u_randomColor2', rC2);
            tS.setUniform('u_randomColor3', rC3);

            // Disable mouse and trail effects
            tS.setUniform('u_mouse', [0.0, 0.0]);
            tS.setUniform('u_mouseActive', false);
            tS.setUniform('u_mouseInfluenceRadius', 0.0);
            tS.setUniform('u_trailPositions', new Array(MAX_TRAIL_POINTS * 2).fill(0));
            tS.setUniform('u_trailTimes', new Array(MAX_TRAIL_POINTS).fill(TRAIL_LIFETIME / 1000.0));
            tS.setUniform('u_trailCount', 0);

            scF = 40;
            upTC();
            suEH();

            stT = millis();
            let cASV = R.N(1.5, 3.0);
            tS.setUniform('u_caScaleVariation', cASV);
        }

        function draw() {
            // Implement frame rate control and FPS calculation
            const now = performance.now();
            const elapsed = now - lastFrameTime;
            const frameInterval = 1000 / TARGET_FRAMERATE;
            
            // Update FPS calculation every FPS_UPDATE_INTERVAL
            if (now - fpsUpdateTime >= FPS_UPDATE_INTERVAL) {
                currentFPS = 1000 / elapsed;
                fpsUpdateTime = now;
            }
            
            // Skip frame if we're rendering too quickly
            if (elapsed < frameInterval) {
                return;
            }
            
            // Update last frame time with adjustment to maintain consistent frame timing
            lastFrameTime = now - (elapsed % frameInterval);
            
            clear();
            background(0);  
            
            // Synchronized time handling
            if (isP) {
                // When playing, calculate time since start, accounting for any paused time
                cuT = ((millis() - stT) / 1000.0);
            } else {
                // When paused, stay exactly at the last paused time
                cuT = lastPausedTime;
            }

            // Calculate shader-space coordinates without scale factor multiplication
            const actualTX = tX;
            const actualTY = tY;

            // Set shader uniforms
            tS.setUniform('u_bS', bS);
            tS.setUniform('u_scaleFactor', scF);
            tS.setUniform('u_translation', [actualTX, actualTY]);
            tS.setUniform('u_resolution', [width, height]);
            tS.setUniform('u_time', cuT);
            tS.setUniform('u_cellSize', (height / cV) * bS);
            tS.setUniform('u_flowSpeed', fS);
            tS.setUniform('u_luminosity', lum);
            tS.setUniform('u_vibrancy', vib);
            tS.setUniform('u_sortStrength', soS);
            tS.setUniform('u_sortFrequency', soF);
            tS.setUniform('u_sortAnimSpeed', soA);
            tS.setUniform('u_currentPattern', cuP);
            
            // Keep mouse influence disabled
            tS.setUniform('u_mouseActive', false);
            tS.setUniform('u_mouse', [0.0, 0.0]);
            tS.setUniform('u_trailCount', 0);
            
            let cSP = height / cV;
            let dySN = bN * (100.0 / floor(cSP)); 
            tS.setUniform('u_noiseScale', dySN);
            tS.setUniform('u_caScaleVariation', 0.5);

            beginShape();
            vertex(0, 0, 0, 0, 0);
            vertex(2, 0, 0, 1, 0);
            vertex(2, 2, 0, 1, 1);
            vertex(0, 2, 0, 0, 1);
            endShape(CLOSE);

            if (isR && (millis() - reST > reDu)) {
                noRe();
            }
        }

        

        function upCS() {
            const wiR = windowWidth / windowHeight;
            let neW, neH;
            
            // Store current relative position before resize
            let relX = (tX + width/2) / width;
            let relY = (tY + height/2) / height;
            
            switch(dM) {
                case 0: 
                    neW = windowWidth;
                    neH = windowHeight;
                    break;
                
                case 1: 
                    if (wiR > 1) {
                        neH = windowHeight;
                        neW = windowHeight;
                    } else {
                        neW = windowWidth;
                        neH = windowWidth;
                    }
                    break;
                
                case 2: 
                    if (wiR > 3/4) {
                        neH = windowHeight;
                        neW = (windowHeight * 3) / 4;
                    } else {
                        neW = windowWidth;
                        neH = (windowWidth * 4) / 3;
                    }
                    break;
                
                case 3: 
                    if (wiR > 4/3) {
                        neH = windowHeight;
                        neW = (windowHeight * 4) / 3;
                    } else {
                        neW = windowWidth;
                        neH = (windowWidth * 3) / 4;
                    }
                    break;
            }
            
            if (width !== neW || height !== neH) {
                resizeCanvas(neW, neH);
                
                // Apply the relative position to the new dimensions
                tX = -neW/2 + (relX * neW);
                tY = -neH/2 + (relY * neH);
                
                canvasElement.style.cssText = 'position:absolute;left:50%;top:50%;transform:translate(-50%,-50%)';
            }
        }

        
        let reTO;
        function windowResized() {
            // Clear previous timeout to implement debouncing
            if (reTO) clearTimeout(reTO);
            
            // Using requestAnimationFrame for smoother updates and less performance impact
            // Debounce with setTimeout as a backup for consistent timing
            reTO = setTimeout(() => {
                // Use requestAnimationFrame to align with browser's render cycle
                requestAnimationFrame(upCS);
            }, 100);
        }

        
        let meR;
        let reCN = [];
        let isR = false;
        let reST;
        const reDu = 30000; 

        // Add these new functions
        function stRe() {
            // Clear any previous recording chunks
            reCN = [];
            
            // Get stream from canvas
            const stream = canvasElement.captureStream(60); 
            
            // Create media recorder with high quality settings
            meR = new MediaRecorder(stream, {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 50000000 
            });

            // Add event handlers
            meR.ondataavailable = (e) => {
                if (e.data.size > 0) {
                    reCN.push(e.data);
                }
            };

            meR.onstop = saRe;

            // Start recording
            meR.start();
            isR = true;
            reST = millis();
        }

        function noRe() {
            if (meR && meR.state !== 'inactive') {
                meR.stop();
            }
            isR = false;
        }

        function saRe() {
            if (!reCN.length) return;
            
            // Create blob from recording chunks
            const blob = new Blob(reCN, {
                type: 'video/webm'
            });
            
            // Create download link
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const timestamp = geT();
            
            a.style.display = 'none';
            a.href = url;
            a.download = `shader_recording_${timestamp}.webm`;
            
            // Trigger download
            document.body.appendChild(a);
            a.click();
            
            // Cleanup
            setTimeout(() => {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                // Clear recording chunks to free memory
                reCN = [];
            }, 100);
        }

    </script>
  </body>
</html>
