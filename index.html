<!DOCTYPE html>
<html>
  <head>
    <title>Shader Art</title>
    <script src="https://ordinals.com/content/7e37766541506810ba6399c4b2735121f508bd9209df43dd200bf2316b014594i0"></script>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000;
        }
        canvas {
            width: 100% !important;
            height: 100% !important;
            object-fit: contain !important;
            max-width: 100vw;
            max-height: 100vh;
        }
        main {
            display: flex;
            justify-content: center;
            width: 100%;
            align-items: center;
            height: 100%;
        }
    </style>
  </head>
  <body>
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec3 aPosition;
        attribute vec2 aTexCoord;
        varying vec2 vTexCoord;

        void main() {
            vTexCoord = aTexCoord;
            vec4 positionVec4 = vec4(aPosition, 1.0);
            positionVec4.xy = positionVec4.xy * 2.0 - 1.0;
            gl_Position = positionVec4;
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        precision lowp int;  // Integer precision can be low for most operations
        #endif

        #define M_PI 3.14159265358979323846

        varying vec2 vTexCoord;
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float u_cellSize;
        uniform float u_noiseScale;
        uniform float u_maxDepth;
        uniform float u_flowSpeed;
        uniform float u_nS;
        uniform float u_rSS;
        uniform float u_roA;
        uniform vec2 u_nOS;
        uniform float u_amplitude;
        uniform float u_scaleFactor;
        uniform vec2 u_translation;
        uniform float u_luminosity;
        uniform float u_vibrancy;
        uniform float u_initialFreq;
        uniform float u_bS;
        uniform float u_sortStrength;
        uniform float u_sortFrequency;
        uniform float u_sortAnimSpeed;
        uniform int u_currentPattern;
        uniform float u_baseModulation;
        uniform vec4 u_baseColor;
        uniform vec3 u_randomColor1;  // Add uniforms for random colors
        uniform vec3 u_randomColor2;
        uniform vec3 u_randomColor3;
        
        // Add new toggle uniforms
        uniform bool u_enableDomainWarp;    // Toggle domain warping
        uniform bool u_enableLayeredNoise;  // Toggle layered noise
        uniform bool u_enableFlowFields;    // Toggle flow field distortion
        uniform bool u_enableGlyphNoise;    // Toggle glyph pattern noise
        uniform bool u_enableGridDistort;   // Toggle grid distortion
        uniform bool u_enableGlyphNoiseDetail;    // Toggle detail noise within glyphs

        // Add the isLightBackground uniform to the shader
        uniform bool u_isLightBackground;   // Whether we're using a light background

        // Add this uniform after the other uniforms in the fragment shader
        uniform float u_caScaleVariation;  // Controls how much the CA scale varies

        lowp float random(vec2 st, float seed) {
            // Hash function only needs low precision output
            vec2 p = st + seed;
            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }

        mediump float noise(vec2 st, float seed) {
            // Integer and fractional parts
            vec2 i = floor(st);
            vec2 f = fract(st);
            
            // Optimized smoothstep with lowp precision
            lowp vec2 u = f * f * (3.0 - 2.0 * f);
            
            // Gather corners with low precision
            lowp float a = random(i, seed);
            lowp float b = random(i + vec2(1.0, 0.0), seed);
            lowp float c = random(i + vec2(0.0, 1.0), seed);
            lowp float d = random(i + vec2(1.0, 1.0), seed);
            
            // Mix can use low precision
            return mix(
                a + (b - a) * u.x,
                c + (d - c) * u.x,
                u.y);
        }

        lowp vec3 mod289(vec3 x) { 
            return x - floor(x / 289.0) * 289.0; 
        }

        lowp vec2 mod289(vec2 x) { 
            return x - floor(x / 289.0) * 289.0; 
        }

        lowp vec3 permute(vec3 x) { 
            return mod289((x * 34.0 + 1.0) * x); 
        }

        mediump float simplexNoise(mediump vec2 v, float time) {
            // Original simplex noise variables and setup
            mediump vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
            
            // Combine time addition into a single step
            v += time * 0.03;
            
            // Integer calculations can use low precision
            lowp vec2 i = floor(v + dot(v, C.yy));
            mediump vec2 x0 = v - i + dot(i, C.xx);
            
            // These boolean operations and offsets can use low precision
            lowp vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
            
            // Combined calculations to reduce register usage
            mediump vec4 x12 = x0.xyxy + C.xxzz;
            x12.xy -= i1;
            
            // Use existing mod289 function
            i = mod289(i);
            lowp vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
            
            // Dot products need medium precision
            mediump vec3 dots = vec3(
                dot(x0, x0),
                dot(vec2(x12.x, x12.y), vec2(x12.x, x12.y)),
                dot(vec2(x12.z, x12.w), vec2(x12.z, x12.w))
            );
            
            // These multiplications can use low precision
            lowp vec3 m = max(0.5 - dots, 0.0);
            m = m * m;
            m = m * m;
            
            // These can use low precision
            lowp vec3 x = 2.0 * fract(p * C.www) - 1.0;
            lowp vec3 h = abs(x) - 0.5;
            lowp vec3 ox = floor(x + 0.5);
            lowp vec3 a0 = x - ox;
            
            // Final calculation
            m *= 1.792842914 - 0.853734913 * (a0 * a0 + h * h);
            
            // Gradient calculation
            lowp vec3 g = vec3(
                a0.x * x0.x + h.x * x0.y,
                a0.y * x12.x + h.y * x12.y,
                a0.z * x12.z + h.z * x12.w
            );
            
            return 130.0 * dot(m, g);
        }

        lowp float fastSin(float x) {
            // Wrap to -PI to PI range
            x = mod(x + M_PI, 2.0 * M_PI) - M_PI;
            
            // Fast sine approximation
            // Error < 0.002
            float x2 = x * x;
            return x * (1.0 - x2 / (3.0 * 2.0) + x2 * x2 / (5.0 * 4.0 * 3.0 * 2.0));
        }

        lowp float fastCos(float x) {
            return fastSin(x + M_PI * 0.5);
        }

        vec2 domainWarp(vec2 p, float time) {
            float slowTime = time * 0.0001;
            
            float flow = simplexNoise(p * 0.05 * (u_resolution.y / u_cellSize) + slowTime, slowTime);
            float detail = simplexNoise(p * 0.1 * (u_resolution.y / u_cellSize) + slowTime * 1.5, slowTime * 2.0) * 0.3;
            
            // Use fast approximations
            float angle = slowTime * 0.1;
            float rotX = fastCos(angle) * flow;
            float rotY = fastSin(angle) * flow;
            
            return p + vec2(
                rotX * 1.5 + detail,
                rotY * 1.5 + detail
            );
        }

        float layeredNoise(vec2 p, float time) {
            // Simplified to single layer with detail
            float mainLayer = simplexNoise(p, time);
            float detail = simplexNoise(p * 2.0, time * 0.3) * 0.3;
            return mainLayer * 0.7 + detail * 0.3;
        }

        float fbmSimplexNoise(vec2 v, int octaves) {
            if (octaves <= 0) return 0.0;
            
            const float PERSISTENCE = 0.001;
            const float LACUNARITY = 0.0009;
            const int MAX_OCTAVES = 2;
            
            float total = 0.0;
            float amplitude = u_amplitude;
            float frequency = u_initialFreq;
            
            // Apply initial offsets
            v += u_nOS + vec2(u_nS);
            
            // Calculate base pattern with simplified domain warping
            vec2 warpedCoord = domainWarp(v, u_time * 0.1);
            float basePattern = layeredNoise(warpedCoord, u_time);
            total = amplitude * basePattern;
            
            // Simplified time influence - single noise sample
            float timeInfluence = simplexNoise(vec2(u_time * 0.05, 0.0), u_nS) * 0.5;
            
            // Only two octaves with simplified rotation
            float timeRotation = u_time * 0.05;
            // Precalculate sin/cos using fast approximations
            float sinRot = fastSin(timeRotation);
            float cosRot = fastCos(timeRotation);
            mat2 rot = mat2(cosRot, -sinRot, sinRot, cosRot);
            
            // First octave
            amplitude *= PERSISTENCE * 3.2;
            frequency *= LACUNARITY * (1.0 + timeInfluence * 0.2);
            total += amplitude * layeredNoise(rot * warpedCoord * frequency, u_time * 0.9);
            
            // Second octave (if needed)
            if (octaves > 1) {
                amplitude *= PERSISTENCE * 2.0;
                frequency *= LACUNARITY * (1.0 + timeInfluence * 0.2);
                total += amplitude * layeredNoise(rot * warpedCoord * frequency, u_time * 0.9);
            }
            
            // Apply final modulation
            return total * (timeInfluence * 0.9 + u_baseModulation);
        }

        lowp vec3 getColorFromPalette(float t) {
            t = clamp(t, 0.0, 4.0) * 7.0;
            int segment = int(t);
            float frac = t - float(segment);
            float phase = float(segment) / 7.0;
            
            vec3 color1, color2;
            
            // Use the random colors passed from JavaScript
                    color1 = mix(
                mix(u_randomColor1, u_randomColor2, sin(phase * 6.28318) * 0.5 + 0.5),
                u_randomColor3,
                        cos(phase * 9.42477) * 0.5 + 0.5
                    );
                    color2 = mix(
                mix(u_randomColor2, u_randomColor3, cos(phase * 12.56636) * 0.5 + 0.5),
                u_randomColor1,
                        sin(phase * 15.70796) * 0.5 + 0.5
                    );
            
            return mix(color1, color2, smoothstep(0.1, 0.9, frac));
        }

        lowp vec3 enhanceColor(vec3 color, float noiseValue) {
            const vec3 LUM_WEIGHTS = vec3(0.333, 0.333, 0.334);
            float luminance = dot(color, LUM_WEIGHTS);
            
            // Adjust enhancement based on background setting
            float noiseInfluence = 1.0 + noiseValue * (u_isLightBackground ? 0.02 : 0.04); // lower influence
            vec3 boosted = color * (1.0 + (1.0 - luminance) * noiseInfluence);
            
            // Adjust saturation based on background
            float saturationStrength = u_isLightBackground ? 1.1 : 1.2; // lower influence
            vec3 saturated = mix(
                vec3(luminance),
                boosted,
                vec3(saturationStrength)
            );
            
            float contrastPower = u_isLightBackground ? 0.95 : 0.92; // lower influence
            vec3 contrasted = pow(saturated, vec3(contrastPower));
            
            float highlightThreshold = u_isLightBackground ? 0.95 : 0.92; // lower influence
            vec3 highlights = smoothstep(highlightThreshold, 1.0, contrasted);
            contrasted = mix(contrasted, highlights * 0.9, 0.6); // higher influence

            // Final multiplier based on background
            float finalMultiplier = u_isLightBackground ? 0.95 : 1.05; // lower influence
            return contrasted * finalMultiplier;
        }

        lowp vec3 blendColors(lowp vec3 a, lowp vec3 b, lowp float factor) {
            // Screen blend can use low precision
            lowp vec3 screen = 1.0 - (1.0 - a) * (1.0 - b * factor * 0.8);
            
            // Addition blend can use low precision
            lowp vec3 add = a + b * factor * 0.3;
            
            // Rotation influence calculation
            lowp float rotationInfluence = (1.0 + sin(u_roA + u_time * 0.1)) * 0.5;
            
            return mix(screen, add, 2.5 + rotationInfluence);
        }

        lowp vec2 getFlowDirection(mediump vec2 position, float time) {
            lowp float slowTime = time * u_sortAnimSpeed * 0.05;
            
            // Create fractal Brownian motion with domain warping
            vec2 p = position * 0.01;
            
            // Initial domain warping
            vec2 warp1 = vec2(
                simplexNoise(p, slowTime),
                simplexNoise(p + vec2(5.2, 1.3), slowTime)
            ) * 2.0;
            
            // Secondary domain warping
            vec2 warp2 = vec2(
                simplexNoise(p + warp1, slowTime + 10.0),
                simplexNoise(p + warp1 + vec2(8.7, 2.3), slowTime + 20.0)
            ) * 1.5;
            
            // Final domain-warped position
            vec2 warped = p + warp1 + warp2;
            
            // Multi-octave flow field
            vec2 flow = vec2(0.0);
            float amplitude = 1.0;
            float frequency = 1.0;
            
            // Add multiple octaves with rotation
            for(int i = 0; i < 4; i++) {
                // Calculate noise gradient for this octave
                float noiseVal = simplexNoise(warped * frequency, slowTime * frequency * 0.2);
                float noiseX = simplexNoise(warped * frequency + vec2(0.01, 0.0), slowTime * frequency * 0.2);
                float noiseY = simplexNoise(warped * frequency + vec2(0.0, 0.01), slowTime * frequency * 0.2);
                
                // Approximate gradient
                vec2 noiseGrad = vec2(noiseX - noiseVal, noiseY - noiseVal) * 100.0;
                
                // Rotate gradient based on octave
                float octaveAngle = float(i) * 0.7 + slowTime * 0.1;
                vec2 rotatedGrad = vec2(
                    noiseGrad.x * cos(octaveAngle) - noiseGrad.y * sin(octaveAngle),
                    noiseGrad.x * sin(octaveAngle) + noiseGrad.y * cos(octaveAngle)
                );
                
                // Add to flow with amplitude scaling
                flow += rotatedGrad * amplitude;
                
                // Update for next octave
                frequency *= 2.0;
                amplitude *= 0.5;
            }
            
            return normalize(flow);
        }

        // Add this function before getGlyphPattern
        lowp vec4 getCASettings(float seed, float iter) {
            // Use seed and iteration to select pattern type
            float patternSeed = fract(seed * 12345.6789 + iter * 789.123);
            
            // Select one of four patterns based on the seed
            int patternType = int(mod(patternSeed * 4.0, 4.0));
            
            // Return vec4(dirBiasStrength, surviveThreshold, birthThreshold, edgeThreshold)
            if (patternType == 0) {
                // Organic, flowing patterns
                return vec4(
                    0.4,    // dirBias strength
                    1.3,    // surviveThreshold base
                    2.3,    // birthThreshold base
                    0.35    // edgeThreshold base
                );
            } else if (patternType == 1) {
                // Geometric, crystalline patterns
                return vec4(
                    0.15,   // dirBias strength
                    1.6,    // surviveThreshold base
                    2.7,    // birthThreshold base
                    0.5     // edgeThreshold base
                );
            } else if (patternType == 2) {
                // Chaotic, detailed patterns
                return vec4(
                    0.3,    // dirBias strength
                    1.7,    // surviveThreshold base
                    2.2,    // birthThreshold base
                    0.45    // edgeThreshold base
                );
            } else {
                // Symmetric patterns
                return vec4(
                    0.25,   // dirBias strength
                    1.5,    // surviveThreshold base
                    2.5,    // birthThreshold base
                    0.4     // edgeThreshold base
                );
            }
        }

        // Then modify getGlyphPattern to use these settings
        lowp float getGlyphPattern(vec2 cell, float depth, float seed, vec2 normalizedPos) {
            // Use cellular grid position for scaling with more stable transitions
            vec2 gridPos = floor(cell / 4.0) * 4.0;
            float gridValue = max(abs(gridPos.x), abs(gridPos.y)) * 0.25;
            float smoothGrid = smoothstep(0.0, 4.0, gridValue) * 0.5;
            
            // More stable noise calculation with reduced variation
            float stabilityNoise = noise(floor(cell / 8.0) * 8.0, seed) * 0.2; // Reduced from 0.3
            float scaleVariation = 1.0 + (smoothGrid * 0.3 + stabilityNoise) * u_caScaleVariation * 0.5;
            
            // Pre-calculate scaled cell position with reduced variation
            vec2 scaledCell = floor(cell * scaleVariation * 1.8) * 0.5; // Reduced from 2.0
            vec2 id = floor(scaledCell * 2.0);
            
            // Generate base pattern with more defined edges
            float basePattern = noise(floor(id * 0.5) * 2.0, seed + floor(depth));
            float state = step(0.6, basePattern); // Increased threshold for more defined edges
            
            // Geometric properties with reduced variation
            float angle = atan(scaledCell.y, scaledCell.x);
            float radius = length(scaledCell) * 1.8; // Reduced from 2.0
            
            // Get CA settings
            vec4 caSettings = getCASettings(seed, floor(depth));
            float dirBias = sin(angle * floor(depth + 1.0)) * caSettings.x;
            
            // CA simulation with fixed neighbors
            float neighbors = 0.0;
            
            // Calculate neighbors using individual offsets with reduced influence
            vec2 neighbor;
            float neighborState;
            
            // Right neighbor
            neighbor = floor(id + vec2(1.0, 0.0));
            neighborState = step(0.5, noise(neighbor * 0.5, seed));
            neighbors += neighborState * (1.0 + dirBias * 0.2);
            
            // Left neighbor
            neighbor = floor(id + vec2(-1.0, 0.0));
            neighborState = step(0.5, noise(neighbor * 0.5, seed));
            neighbors += neighborState * (1.0 + dirBias * 0.2);
            
            // Top neighbor
            neighbor = floor(id + vec2(0.0, 1.0));
            neighborState = step(0.5, noise(neighbor * 0.5, seed));
            neighbors += neighborState * (1.0 + dirBias * 0.2);
            
            // Bottom neighbor
            neighbor = floor(id + vec2(0.0, -1.0));
            neighborState = step(0.5, noise(neighbor * 0.5, seed));
            neighbors += neighborState * (1.0 + dirBias * 0.2);
            
            // Rule application
            float depthRule = floor(mod(depth * 1.618 + seed * 3.14159, 2.0));
            
            if (depthRule < 1.0) {
                float surviveThreshold = caSettings.y + sin(angle * 2.0) * 0.1;
                state = step(surviveThreshold - 0.1, neighbors) * 
                        step(neighbors, surviveThreshold + 1.1) * state + 
                        step(caSettings.z - 0.1, neighbors) * 
                        step(neighbors, caSettings.z + 0.1) * (1.0 - state);
                } else {
                float edgeThreshold = caSettings.w + cos(radius) * 0.1;
                state = step(edgeThreshold, abs(neighbors - 2.0 - dirBias));
            }
            
            // Geometric pattern
            float geoPattern = smoothstep(0.4, 0.6, 
                sin(radius * (3.0 + depth * 0.5) +    // Try 2.0 to 5.0
                    angle * (4.0 + depth * 0.3) +     // Try 3.0 to 6.0
                    depth + seed) * 0.5 + 0.5
            );
            
            // Blend CA result with geometric pattern based on depth
            float blendFactor = 0.3 + 0.2 * sin(depth * 1.5);  // Try different base values 0.2 to 0.6
            float finalPattern = mix(state, geoPattern, blendFactor);
            
            // Add detail noise if enabled
            if (u_enableGlyphNoiseDetail) {
                float detail = noise(scaledCell * (depth + 1.0) * 3.0, seed + depth);
                return mix(finalPattern, detail, 0.15);
            }
            
            return finalPattern;
        }

        void main() {
            // Constants can use low precision
            const lowp int MAX_LOOP_DEPTH = 6;
            
            // Coordinate calculations need medium precision
            mediump vec2 coord = (vTexCoord * u_resolution - u_resolution * 0.25) * u_scaleFactor + u_translation;
            coord = coord / u_bS;
            
            // Grid distortion calculation can use medium precision
            mediump float gridDistortTime = u_time * u_sortAnimSpeed * 0.1;
            mediump vec2 gridDistortCoord = coord * u_sortFrequency;
            
            // Most pattern calculations can use low precision
            lowp float distortNoise1 = fbmSimplexNoise(gridDistortCoord + vec2(gridDistortTime * 0.1), 2);
            lowp float distortNoise2 = fbmSimplexNoise(gridDistortCoord + vec2(gridDistortTime * -0.15), 2);
            
            // Pattern vectors can use low precision since normalized
            lowp vec2 expPattern, stepPattern, circularPattern, squarePattern, flowPattern, smoothFlowPattern;
            
            // Pattern 1: Exponential waves
            expPattern = vec2(
                exp(-abs(mod(distortNoise1 + gridDistortTime, 2.0) - 1.0)) - 0.5,
                exp(-abs(mod(distortNoise2 + gridDistortTime, 2.0) - 1.0)) - 0.5
            );
            
            // Pattern 2: Stepped/quantized movement
            stepPattern = vec2(
                floor(distortNoise1 * 4.0) / 4.0,
                floor(distortNoise2 * 4.0) / 4.0
            );
            
            // Pattern 3: Circular/spiral movement
            float angle = distortNoise1 * 6.28318;
            circularPattern = vec2(
                cos(angle) * distortNoise2,
                sin(angle) * distortNoise2
            );
            
            // Pattern 4: Square/diamond pattern
            squarePattern = vec2(
                sign(fract(distortNoise1 * 2.0) - 0.5) * abs(fract(distortNoise2 * 2.0) - 0.5),
                sign(fract(distortNoise2 * 2.0) - 0.5) * abs(fract(distortNoise1 * 2.0) - 0.5)
            );
            
            // Pattern 5: Smooth directional flow with rotation
            flowPattern = vec2(
                distortNoise1 * cos(gridDistortTime * 0.2) - distortNoise2 * sin(gridDistortTime * 0.15),
                distortNoise1 * sin(gridDistortTime * 0.2) + distortNoise2 * cos(gridDistortTime * 0.15)
            );
            
            // Add subtle vorticity
            float vortexStrength = 0.3;
            float vortexAngle = atan(coord.y, coord.x) + gridDistortTime * 0.1;
            vec2 vortexOffset = vec2(
                cos(vortexAngle) * length(flowPattern) * vortexStrength,
                sin(vortexAngle) * length(flowPattern) * vortexStrength
            );
            
            // Combine flow and vortex with smooth transition
            smoothFlowPattern = flowPattern + vortexOffset;
            
            // Add progressive movement (modified for more organic flow)
            float flowTime = gridDistortTime * 0.05;
            smoothFlowPattern += vec2(
                simplexNoise(vec2(flowTime * 0.7, 0.0), 0.0) * 0.15,
                simplexNoise(vec2(flowTime * 0.8, 1.0), 0.0) * 0.15
            );
            
            // Select pattern based on uniform
            vec2 finalPattern;
            if (u_currentPattern == 5) {
                finalPattern = smoothFlowPattern;
            } else if (u_currentPattern == 0) {
                // Mixed patterns with smooth transitions
                float patternMix = fract(gridDistortTime * 0.1);
                finalPattern = mix(
                    mix(expPattern, stepPattern, smoothstep(0.0, 0.33, patternMix)),
                    mix(circularPattern, squarePattern, smoothstep(0.66, 1.0, patternMix)),
                    smoothstep(0.33, 0.66, patternMix)
                );
            } else if (u_currentPattern == 1) {
                finalPattern = expPattern;
            } else if (u_currentPattern == 2) {
                finalPattern = stepPattern;
            } else if (u_currentPattern == 3) {
                finalPattern = circularPattern;
            } else {
                finalPattern = squarePattern;
            }
            
            // Apply grid distortion only if enabled
            mediump vec2 gridOffset = vec2(0.0);
            if (u_enableGridDistort) {
                gridOffset = finalPattern * u_sortStrength * u_cellSize;
                // Apply distortion to coordinates before grid calculation
                coord += gridOffset * (1.0 + sin(gridDistortTime) * 0.3);
            }
            
            vec2 gridCoord = floor(coord / u_cellSize);
            vec2 cellCenter = (gridCoord + 0.5) * u_cellSize;
            vec2 localPos = coord - cellCenter;

        // Cell boundary check can use lower precision
        lowp float cellBoundary = u_cellSize * 0.485;
        lowp float edgeFade = 0.005;
        bool isWithinCell = all(lessThanEqual(abs(localPos), vec2(cellBoundary)));
        if (!isWithinCell) {
            // Smooth edge transition
            vec2 edgeDistance = abs(localPos) - vec2(cellBoundary);
            float fadeAlpha = 1.0 - smoothstep(0.0, edgeFade, max(edgeDistance.x, edgeDistance.y));
            if (fadeAlpha <= 0.0) discard;
        }

            // Pre-calculate values needed for the depth loop
            float distToCenter = length(coord - cellCenter);
            float timeScale = u_time * 0.1;
            vec2 baseNoiseCoord = gridCoord * 0.1;
            vec2 timeOffset = vec2(timeScale, timeScale + 100.0);
            
            // Calculate distortion influence once
            float distortionInfluence = length(gridOffset) / (u_cellSize * 2.0);
            float baseNoiseFBM = fbmSimplexNoise(gridCoord * (u_cellSize / u_resolution.y) * 0.05, 4) + distortionInfluence * 0.2;
            
            vec2 noiseOffset = vec2(
                noise(baseNoiseCoord + timeOffset.xx, u_nS),
                noise(baseNoiseCoord + timeOffset.yy, u_nS)
            );
            
            // Pre-calculate common values for the loop
            float gridSize = u_cellSize * mix(0.3, 2.5, baseNoiseFBM + distortionInfluence * 0.2);
            vec2 localCoord = mod(coord + noiseOffset, gridSize);
            
            float randomAngle = floor(noise(gridCoord + noiseOffset, u_nS) * 4.0) * (M_PI * 0.5);
            float sinA = fastSin(randomAngle);
            float cosA = fastCos(randomAngle);
            vec2 rotatedCoord = vec2(
                localCoord.x * cosA - localCoord.y * sinA,
                localCoord.x * sinA + localCoord.y * cosA
            );
            
            float smoothedTime = u_time * 0.01 + simplexNoise(vec2(u_time * 0.3, 50.0), u_nS) * 0.005;
            
            vec2 noiseInput1 = rotatedCoord * ((u_cellSize / u_resolution.y) * 1.0) + smoothedTime;
            vec2 noiseInput2 = (rotatedCoord + gridCoord * gridSize) * ((u_cellSize / u_resolution.y) * 1.0) * u_noiseScale;
            
            float flowNoise = fbmSimplexNoise(noiseInput1, 6);
            vec2 animatedCoord = noiseInput2 + vec2(
                simplexNoise(vec2(flowNoise, u_time * 0.05), u_nS),
                simplexNoise(vec2(flowNoise, u_time * 0.05 + 100.0), u_nS)
            ) * u_flowSpeed * 0.005;
            
            float curlNoise = fbmSimplexNoise(animatedCoord * (u_cellSize / u_resolution.y) * 20.0 + vec2(u_nS), 8);
            animatedCoord += 4.0 * vec2(
                cos(curlNoise * 6.28318),
                sin(curlNoise * 6.28318)
            );
            
            // Color blending can use low precision
            lowp vec4 color = vec4(0.0);
            
            // Main loop variables
            mediump float depthNoiseValue, depthFactor, colorT;
            lowp vec3 color1, color2, enhancedColor1, enhancedColor2, blendedColor;
            
            // Calculate base noise values that won't change in the loop
            float baseNoise = fbmSimplexNoise(animatedCoord * (u_cellSize / u_resolution.y) * 0.15 + noiseOffset, 5);
            float combinedNoise = (baseNoise * 0.3 + baseNoiseFBM * 0.7 + 3.0) * 0.3;
            
            // Calculate depth once
            float clampedNoise = clamp(combinedNoise, 0.0, 1.0);
            int dynamicDepth = int(clamp(
                clampedNoise * float(u_maxDepth),
                1.0,
                min(float(u_maxDepth), float(MAX_LOOP_DEPTH))
            ));
            
            // Pre-calculate threshold and blend factor outside loop
            float threshold = 0.55 - (0.15 * pow(1.0 - u_bS, 2.0));
            
            float t = simplexNoise(vec2(u_time * 0.01), 0.0) * 0.5 + 0.5;
            float angleInfluence = simplexNoise(vec2(u_time * 0.005), 0.0) * 0.5 + 0.5;
            float blendFactor = t * t * (3.0 - 2.0 * t) * (1.0 + combinedNoise * 0.8 + angleInfluence * 1.2);
            
            // Prepare edge values for color transitions
            float edge0 = 0.2 + sin(u_time * 0.0002) * 0.3;
            float edge1 = 0.8 + cos(u_time * 0.0002) * 0.5;
            
            // Get flow direction for current cell
            vec2 flowDir = getFlowDirection(cellCenter, u_time);
            float flowAngle = atan(flowDir.y, flowDir.x);
            
            // Process each depth level with minimal branching
            for (int depth = 0; depth < MAX_LOOP_DEPTH; depth++) {
                // Break condition at the top to avoid unnecessary loop iterations
                if (depth >= dynamicDepth) break;
                
                // Early exit if we've achieved sufficient opacity
                if (color.a > 0.98) break;
                
                depthNoiseValue = noise(animatedCoord * float(depth + 1), u_nS);
                depthFactor = float(depth) / float(MAX_LOOP_DEPTH);
                
                // Skip early if noise threshold not met with a wider margin
                if (depthNoiseValue <= threshold - 0.1) continue;
                
                // Skip processing for areas with minimal contribution
                if (depthFactor > 0.9 && depthNoiseValue < threshold + 0.1) continue;
                
                // Get glyph parameters with distance-based detail reduction
                float currentSize = mix(0.3, 1.2, depthFactor) * u_cellSize;
                float distanceFromCenter = length(localPos);
                
                // Skip distant or small glyphs
                if (distanceFromCenter > currentSize * 3.0) continue;
                
                // Rotate point to align with flow
                vec2 rotatedP = vec2(
                    localPos.x * fastCos(-flowAngle) - localPos.y * fastSin(-flowAngle),
                    localPos.x * fastSin(-flowAngle) + localPos.y * fastCos(-flowAngle)
                );
                
                // Glyph grid calculation with optimized flow influence
                float flowStrength = length(flowDir);
                float mappedOffset = mix(0.5, 1.2, flowStrength);
                vec2 glyphCell = floor(rotatedP / currentSize + mappedOffset);
                vec2 localGlyphPos = rotatedP - glyphCell * currentSize;
                
                // Get glyph pattern with distance-based detail reduction
                float glyphNoise;
                if (distanceFromCenter > currentSize * 2.0) {
                    // Use simpler pattern for distant glyphs
                    glyphNoise = step(0.5, noise(floor(glyphCell * 0.5) * 2.0, u_nS));
                } else {
                    glyphNoise = getGlyphPattern(glyphCell, float(depth), u_nS, vTexCoord);
                }
                
                // Simplified glyph checks
                bool centerActive = abs(glyphCell.x) < 0.5 && abs(glyphCell.y) < 0.5;
                bool noiseActive = length(glyphCell) < 1.5 && glyphNoise > 0.5;
                bool lineActive = abs(localGlyphPos.x) < currentSize * 0.15 || abs(localGlyphPos.y) < currentSize * 0.15;
                
                bool insideGlyph = centerActive || noiseActive || lineActive;
                
                // Skip if not inside glyph
                if (!insideGlyph) continue;
                
                // Color calculation with optimized blending
                colorT = smoothstep(edge0, edge1, depthFactor + combinedNoise * 0.9);
                
                color1 = getColorFromPalette(colorT);
                color2 = getColorFromPalette(1.0 - colorT);
                
                // Apply depth boost with reduced calculations
                float depthBoost = 1.2 + (1.0 - depthFactor) * 0.8;
                color1 *= depthBoost;
                color2 *= depthBoost;
                
                enhancedColor1 = enhanceColor(color1, combinedNoise);
                enhancedColor2 = enhanceColor(color2, combinedNoise);
                
                blendedColor = blendColors(enhancedColor1, enhancedColor2, blendFactor);
                
                // Add to final color with optimized alpha blending
                float alphaFactor = 1.0 - depthNoiseValue * 0.7;
                if (alphaFactor > 0.01) { // Skip negligible contributions
                color.rgb *= 1.0;
                    color += vec4(blendedColor, 1.0) * alphaFactor;
                }
            }
            
            // Final color check
            if (color.a == 0.0) {
                color = u_baseColor;
            }
            
            gl_FragColor = color;
        }
    </script>

    <script>
        let bS = 1.0;     
        const cV = 6;  
        let tS;
        let dM = 3;  // Initially set to 3 which is fullscreen aspect ratio
        let cS;      
        let bN = 0.002;  
        let nS;
        let fS = 0.005;
        let rSS;
        let roA;
        let nOX, nOY;
        let scF = 30;
        let tX = 0, tY = 0;
        let iTX = 0, iTY = 0;
        let pMX, pMY;
        let amV = [0.1, 0.075, 0.05]; 
        let isP = true;
        let stT = 0;
        let cuT = 0;
        let lum = 1.5;
        let vib = 2.5;
        let soS = 0.1;     
        let soF = 0.1;   
        let soA = 0.15;     
        let cuP;                  

        // Add performance monitoring system
        const TARGET_FRAMERATE = 60; // Target frame rate (can be lowered for better performance)
        let lastFrameTime = 0;      // For frame rate control
        let currentFPS = 60;        // Track current FPS
        let fpsUpdateTime = 0;      // Time of last FPS update
        const FPS_UPDATE_INTERVAL = 500; // Update FPS every 500ms
        const MIN_FPS_THRESHOLD = 20;    // Minimum FPS threshold for lowest quality
        const MID_FPS_THRESHOLD = 40;    // Medium FPS threshold for medium quality
        const PERFORMANCE_CHECK_INTERVAL = 2000; // Check performance every 2 seconds
        let lastPerformanceCheck = 0;    // Time of last performance check
        let currentPixelDensity;         // Track current pixel density
        let lastPixelDensityChange = 0;  // Track when we last changed pixel density
        const MIN_DENSITY_CHANGE_INTERVAL = 5000; // Minimum time between density changes (5 seconds)
        let canvasElement;               // Reference to canvas element
        let glContext;                   // Cached reference to WebGL context
        
        // Pre-allocate arrays for better memory management
        const PREALLOCATED_ARRAY_SIZE = 1000;
        const recordingChunkPool = [];   // Pool of pre-allocated chunks for recording
        let recordingChunkIndex = 0;     // Current index in the recording chunk pool
        
        // Memory management flags
        let isMemoryCleanupScheduled = false;
        const MEMORY_CLEANUP_INTERVAL = 30000; // Run memory cleanup every 30 seconds
        let lastMemoryCleanup = 0;
        let isTabVisible = true; // Track tab visibility for better performance

        // Handle visibility changes to pause rendering when tab not active
        function handleVisibilityChange() {
            isTabVisible = document.visibilityState === 'visible';
            
            if (isTabVisible) {
                // Reset frame time tracking to avoid jumps
                lastFrameTime = performance.now();
                // Restart animation if animation is enabled
                if (isP) {
                    requestAnimationFrame(draw);
                }
            }
            
            // Take opportunity to clean up memory when tab is hidden
            if (!isTabVisible) {
                performMemoryCleanup();
            }
        }

        // Memory management function that optimizes memory use
        function performMemoryCleanup() {
            isMemoryCleanupScheduled = true;
            
            // Use setTimeout to defer heavy operations until the tab is idle
            setTimeout(() => {
                // Clear any unused recording chunks
                if (Array.isArray(reCN) && reCN.length > 0) {
                    // Keep only chunks that are actually in use
                    if (!isR) {
                        reCN.length = 0;
                    }
                }
                
                // Reset preallocated arrays to reduce memory fragmentation
                recordingChunkIndex = 0;
                
                // Force garbage collection on WebGL if possible
                if (glContext && !isTabVisible) {
                    // Attempt to reduce GL memory usage by reducing texture size temporarily
                    // Only do this when tab isn't visible to avoid affecting visible rendering
                    const tempDensity = pixelDensity();
                    if (tempDensity > 1) {
                        pixelDensity(1);
                        clear();
                        pixelDensity(tempDensity);
                    }
                }
                
                lastMemoryCleanup = performance.now();
                isMemoryCleanupScheduled = false;
                
                // If tab is visible and animation is playing, restart the animation loop
                if (isTabVisible && isP) {
                    requestAnimationFrame(draw);
                }
            }, 100);
        }

        // Cached uniform values to prevent redundant updates
        const cachedUniforms = {
            bS: null,
            scaleFactor: null,
            translation: [null, null],
            resolution: [null, null],
            time: null,
            cellSize: null,
            flowSpeed: null,
            luminosity: null,
            vibrancy: null,
            sortStrength: null,
            sortFrequency: null,
            sortAnimSpeed: null,
            currentPattern: null,
            noiseScale: null,
            caScaleVariation: null
        };

        let inscription_id = window.location.pathname.split("/").pop();
        
        // REMOVE AFTER TESTING!!!
            let chars = "0123456789abcdefghijklmnopqrstuvwsyz";
            inscription_id = new URLSearchParams(window.location.search).get("seed") || Array(64).fill(0).map(_=>chars[(Math.random()*chars.length)|0]).join('');
        // REMOVE AFTER TESTING!!!



        class Rnd{
            constructor(seed) {
                const i=Math.imul,h=t=>{let e,l=0;for(e=1779033703^t.length;l<t.length;l++){let h=e^t.charCodeAt(l);e=i(h,3432918353),e=e<<13|e>>>19}return()=>(e=i(e^e>>>16,2246822507),e=i(e^e>>>13,3266489909),(e^=e>>>16)>>>0)},a=(e,r,t,a)=>()=>{let l=((e|=0)+(r|=0)|0)+(a|=0)|0;return a=a+1|0,e=r^r>>>9,r=(t|=0)+(t<<3)|0,t=(t=t<<21|t>>>11)+l|0,(l>>>0)/4294967296},X=h(seed);this.R=a(X(),X());
            }
            D=_=>this.R();                  
            N=(r,t)=>r+(t-r)*this.D();     
            I=(r,t)=>0|this.N(r,t+1);      
            B=r=>this.D()<r               
        };
        let R = new Rnd(inscription_id)

        console.log('Inscription ID:', inscription_id)


        function upTC() {
            // Keep the current translation coordinates instead of recalculating
            // This maintains the user's current view when changing zoom level
            // Don't override tX and tY here, we want to keep the current position
        }

        function geT() {
            const d = new Date();
            const pad = n => n.toString().padStart(2, '0');
            return `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
        }

        function preload() {
            // Only initialize shader once for better performance
            if (!tS) {
            let vertexShader = document.getElementById('vertex-shader').textContent;
            let fragmentShader = document.getElementById('fragment-shader').textContent;
            tS = createShader(vertexShader, fragmentShader);
            }
        }

        function suEH() {
            // Cache canvas reference
            const canvas = canvasElement;
            
            // Event listener references for proper cleanup
            const eventListeners = {
                keydown: null,
                keyup: null,
                mousedown: null,
                mousemove: null,
                mouseup: null,
                touchstart: null,
                touchmove: null,
                touchend: null,
                visibilitychange: null,
                resize: null
            };
            
            // Throttling variables for mousemove/touchmove
            let lastMoveTime = 0;
            const MOVE_THROTTLE = 16; // ~ 60fps
            
            // Touch event tracking
            let lastTap = 0;
            let lastTapX = 0;
            let lastTapY = 0;
            let tapCount = 0;
            let tapTimeout = null;
            
            // Key state with Set for faster lookups
            const keyState = new Set();
            
            // Mouse/touch state
            let isDragging = false;
            let startX, startY;
            let startTX, startTY;
            
            // Clean up old event listeners if they exist
            function cleanupEventListeners() {
                // Remove existing listeners if they were created before
                for (const [type, handler] of Object.entries(eventListeners)) {
                    if (handler) {
                        if (type === 'resize') {
                            window.removeEventListener(type, handler);
                        } else if (type.startsWith('touch')) {
                            canvas.removeEventListener(type, handler, { passive: false });
                        } else {
                            document.removeEventListener(type, handler);
                        }
                    }
                }
            }
            
            // Optimized key event handler
            function handleKeyDown(e) {
                if (keyState.has(e.key)) return;
                keyState.add(e.key);
                
                // Debug logging removed to keep console cleaner
                
                switch(e.key.toLowerCase()) {
                    case 'a':
                        dM = (dM + 1) % 4;
                        const aspectModes = ["3:4 Portrait", "1:1 Square", "4:3 Landscape", "Fullscreen"];
                        console.log(`Aspect ratio: ${aspectModes[dM]}`);
                        requestAnimationFrame(upCS);
                        break;
                        
                    case 'r':
                        // Reset position and scale - this should still provide a full reset
                        tX = -width/2;
                        tY = -height/2;
                        scF = 30;
                        console.log("View reset to center");
                        break;
                        
                    case 's':
                        isP = !isP;
                        console.log(`Animation: ${isP ? 'PLAYING' : 'PAUSED'}`);
                        if (isP) {
                            stT = millis() * 0.1;
                            // Ensure draw loop restarts if we're enabling playback
                            requestAnimationFrame(draw);
                        } else {
                            cuT = (millis() - stT) / 1000.0;
                        }
                        break;
                        
                    case '1':
                    case '2':
                    case '3':
                        {  
                            const cuD = pixelDensity();
                            const nwD = e.key === '1' ? 4 : (e.key === '2' ? 5 : 5.5);
                            
                            console.log(`Saving screenshot with pixel density ${nwD}...`);
                            pixelDensity(nwD);
                            draw();
                           
                            const tiS = geT();
                            const prefix = e.key === '1' ? 'shader_' : 'shader_hires_';
                            saveCanvas(prefix + tiS, 'png');
                            console.log(`Screenshot saved as ${prefix}${tiS}.png`);
                            
                            pixelDensity(cuD);
                            draw();
                            break;  
                        }
                        
                    case 'd':
                        if (scF === 30) {
                            scF = 10;
                            console.log("Zoom level: ZOOMED OUT");
                        } else {
                            scF = 30;
                            console.log("Zoom level: ZOOMED IN");
                        }
                        // No need to call upTC here as we want to maintain position
                        break;
                    
                    case 'k':
                        if (!isR) {
                            stRe();
                            console.log("Recording started");
                        } else {
                            noRe();
                            console.log("Recording stopped");
                        }
                        break;
                        
                    // Resolution scaling controls
                    case 'q':
                        adaptiveScaling = !adaptiveScaling;
                        console.log(`Adaptive scaling: ${adaptiveScaling ? 'ON - will adjust automatically based on performance' : 'OFF - using manual settings'}`);
                        break;
                        
                    case '8': // Changed from '[' to '8'
                        if (window.multiBufError) {
                            // If buffer isn't supported, adjust shader complexity instead
                            const oldComplexity = Math.round(shaderComplexity * 100);
                            shaderComplexity = Math.max(0.25, shaderComplexity - 0.1);
                            const newComplexity = Math.round(shaderComplexity * 100);
                            console.log(`Manual shader complexity: ${oldComplexity}% → ${newComplexity}% | Iterations: ${Math.max(2, Math.floor(6 * shaderComplexity))}`);
                            adjustShaderComplexity(currentFPS);
                        } else {
                            const oldScale = renderScale.toFixed(2);
                            renderScale = Math.max(minRenderScale, renderScale - 0.1);
                            console.log(`Manual render scale: ${oldScale} → ${renderScale.toFixed(2)} | Resolution: ${Math.round(width * renderScale)}x${Math.round(height * renderScale)}`);
                            setupOffscreenBuffer();
                        }
                        break;
                        
                    case '9': // Changed from ']' to '9'
                        if (window.multiBufError) {
                            // If buffer isn't supported, adjust shader complexity instead
                            const oldComplexity = Math.round(shaderComplexity * 100);
                            shaderComplexity = Math.min(1.0, shaderComplexity + 0.1);
                            const newComplexity = Math.round(shaderComplexity * 100);
                            console.log(`Manual shader complexity: ${oldComplexity}% → ${newComplexity}% | Iterations: ${Math.max(2, Math.floor(6 * shaderComplexity))}`);
                            adjustShaderComplexity(currentFPS);
                        } else {
                            const oldScale = renderScale.toFixed(2);
                            renderScale = Math.min(maxRenderScale, renderScale + 0.1);
                            console.log(`Manual render scale: ${oldScale} → ${renderScale.toFixed(2)} | Resolution: ${Math.round(width * renderScale)}x${Math.round(height * renderScale)}`);
                            setupOffscreenBuffer();
                        }
                        break;
                        
                    // Additional shortcuts for shader complexity features
                    case 'o':
                        // Toggle specific shader features
                        enableDetails = !enableDetails;
                        setShaderUniform('u_enableGlyphNoiseDetail', enableDetails);
                        console.log(`Detail features: ${enableDetails ? 'ON - higher quality, lower performance' : 'OFF - better performance'}`);
                        break;
                        
                    case 'p':
                        // Toggle domain warping - using a safer approach
                        // Track state in our own variable to avoid direct uniform access
                        window.domainWarpEnabled = !(window.domainWarpEnabled === true);
                        setShaderUniform('u_enableDomainWarp', window.domainWarpEnabled);
                        console.log(`Domain warping: ${window.domainWarpEnabled ? 'ON - higher quality, lower performance' : 'OFF - better performance'}`);
                        break;
                }
            }
            
            function handleKeyUp(e) {
                keyState.delete(e.key);
            }
            
            // Optimized mouse event handlers with throttling
            function handleMouseDown(e) {
                if (e.button !== 0) return; // Only handle left mouse button
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startTX = tX;
                startTY = tY;
                
                // Apply cursor style once
                canvas.style.cursor = 'grabbing';
                
                // Prevent text selection while dragging
                e.preventDefault();
            }
            
            function handleMouseMove(e) {
                // Only process if dragging
                if (!isDragging) return;
                
                // Calculate accurate pan distance with proper scaling
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                // Apply translation with a smooth scaling factor based on current zoom
                // This ensures consistent speed regardless of zoom level
                const panScale = scF / 15;
                
                // Apply translation with smooth interpolation for natural feel
                tX = startTX - dx * panScale;
                tY = startTY + dy * panScale;
                
                // Force redraw for smooth motion even when not animating
                if (!isP && rafID === null) {
                    rafID = requestAnimationFrame(draw);
                }
            }
            
            function handleMouseUp(e) {
                if (isDragging) {
                    isDragging = false;
                    canvas.style.cursor = 'grab';
                    
                    // Force final redraw for smoothness
                    if (!isP && rafID === null) {
                        rafID = requestAnimationFrame(draw);
                    }
                }
            }
            
            // Touch event handlers with optimization
            function handleTouchStart(e) {
                if (e.touches.length !== 1) return;
                
                const touch = e.touches[0];
                const currentTime = performance.now();
                
                isDragging = true;
                startX = touch.clientX;
                startY = touch.clientY;
                startTX = tX;
                startTY = tY;
                
                // Double/triple tap detection
                const tapDistance = Math.sqrt(
                    Math.pow(touch.clientX - lastTapX, 2) + 
                    Math.pow(touch.clientY - lastTapY, 2)
                );
                
                // Clear any existing timeout
                if (tapTimeout) {
                    clearTimeout(tapTimeout);
                }
                
                // Check if this is a quick consecutive tap
                if (currentTime - lastTap < 300 && tapDistance < 30) {
                    tapCount++;
                    
                    if (tapCount === 2) {
                        // Double tap - toggle pause
                        isP = !isP;
                        if (isP) {
                            stT = millis() * 0.1;
                            requestAnimationFrame(draw);
                        } else {
                            cuT = (millis() - stT) / 1000.0;
                        }
                        isDragging = false; // Prevent drag after double tap
                    } else if (tapCount === 3) {
                        // Triple tap - cycle aspect ratio
                        dM = (dM + 1) % 4; // Changed from 3 to 4 modes
                        requestAnimationFrame(upCS);
                        tapCount = 0;
                        isDragging = false; // Prevent drag after triple tap
                    }
                } else {
                    // First tap of potential sequence
                    tapCount = 1;
                }
                
                // Update tap tracking
                lastTap = currentTime;
                lastTapX = touch.clientX;
                lastTapY = touch.clientY;
                
                // Set timeout to reset tap counter if no more taps happen
                tapTimeout = setTimeout(() => {
                    tapCount = 0;
                }, 300);
                
                // Prevent default to avoid scrolling
                e.preventDefault();
            }
            
            function handleTouchMove(e) {
                if (!isDragging || e.touches.length !== 1) return;
                
                const touch = e.touches[0];
                
                // Calculate accurate pan distance with proper scaling
                const dx = touch.clientX - startX;
                const dy = touch.clientY - startY;
                
                // Apply translation with a smooth scaling factor based on current zoom
                const panScale = scF / 15;
                
                // Apply translation with smooth interpolation
                tX = startTX - dx * panScale;
                tY = startTY + dy * panScale;
                
                // Force redraw for smooth motion even when not animating
                if (!isP && rafID === null) {
                    rafID = requestAnimationFrame(draw);
                }
                
                // Prevent default to avoid scrolling
                e.preventDefault();
            }
            
            function handleTouchEnd(e) {
                isDragging = false;
                
                // Force final redraw for smoothness
                if (!isP && rafID === null) {
                    rafID = requestAnimationFrame(draw);
                }
                
                // Don't reset tap state here, as we want to track multi-taps
                // But ensure we prevent default for consistency
                e.preventDefault();
            }
            
            // Optimized resize handler using RAF for better performance
            function handleResize() {
                if (reTO) {
                    clearTimeout(reTO);
                    reTO = null;
                }
                
                reTO = setTimeout(() => {
                    upCS();
                    setupOffscreenBuffer();
                }, 100);
            }
            
            // Clean up existing event listeners
            cleanupEventListeners();
            
            // Set up event listeners with proper options
            eventListeners.keydown = handleKeyDown;
            eventListeners.keyup = handleKeyUp;
            eventListeners.mousedown = handleMouseDown;
            eventListeners.mousemove = handleMouseMove;
            eventListeners.mouseup = handleMouseUp;
            eventListeners.touchstart = handleTouchStart;
            eventListeners.touchmove = handleTouchMove;
            eventListeners.touchend = handleTouchEnd;
            eventListeners.resize = handleResize;
            eventListeners.visibilitychange = handleVisibilityChange;
            
            // Add event listeners with appropriate options
            document.addEventListener('keydown', eventListeners.keydown);
            document.addEventListener('keyup', eventListeners.keyup);
            
            // Mouse events on document to catch cursor movement outside canvas
            document.addEventListener('mousedown', eventListeners.mousedown);
            document.addEventListener('mousemove', eventListeners.mousemove);
            document.addEventListener('mouseup', eventListeners.mouseup);
            
            // Touch events need { passive: false } to prevent scrolling
            canvas.addEventListener('touchstart', eventListeners.touchstart, { passive: false });
            canvas.addEventListener('touchmove', eventListeners.touchmove, { passive: false });
            canvas.addEventListener('touchend', eventListeners.touchend, { passive: false });
            
            // Window events
            window.addEventListener('resize', eventListeners.resize);
            document.addEventListener('visibilitychange', eventListeners.visibilitychange);
            
            // Initialize cursor style
            canvas.style.cursor = 'grab';
            
            // Return cleanup function for proper disposal
            return cleanupEventListeners;
        }

        function setup() {
            let canvas = createCanvas(windowWidth, windowHeight, WEBGL);
            // Store reference to canvas element
            canvasElement = document.querySelector('canvas');
            
            let gl = canvas.GL;
            // Cache GL context for better performance
            glContext = gl;
            
            // Apply WebGL optimizations
            gl.disable(gl.DEPTH_TEST);  
            gl.disable(gl.CULL_FACE);   
            gl.disable(gl.DITHER);      
            gl.disable(gl.STENCIL_TEST);
            
            // Enable optimizations for 2D rendering
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.hint(gl.GENERATE_MIPMAP_HINT, gl.FASTEST);
            
            // Initialize pixel density
            currentPixelDensity = 2;
            pixelDensity(currentPixelDensity);
            
            // Pre-allocate recording chunk pool if WebM recording is supported
            if (typeof MediaRecorder !== 'undefined') {
                // Initialize memory cleanup timer
                lastMemoryCleanup = performance.now();
                
                // Set up event listeners for visibility changes to optimize memory
                document.addEventListener('visibilitychange', handleVisibilityChange);
            }
            
            noStroke();
            
            // Use existing shader if available, otherwise create it
            if (!tS) {
                tS = createShader(
                    document.getElementById('vertex-shader').textContent,
                    document.getElementById('fragment-shader').textContent
                );
            }
            shader(tS);
            
            // Initialize adaptive resolution scaling
            // Start with full resolution and let the system adaptively decrease if needed
            renderScale = 1.0;
            adaptiveScaling = true;
            
            // Initialize shader complexity settings
            shaderComplexity = 1.0;
            maxLoopIterations = 6;
            noiseOctaves = 6;
            enableDetails = true;
            window.domainWarpEnabled = true;
            
            // Test if offscreen buffers are supported
            try {
                const testBuffer = createGraphics(100, 100, WEBGL);
                if (!testBuffer || !testBuffer.GL) {
                    console.log("Multiple WebGL contexts not supported on this device.");
                    console.log("Falling back to shader complexity optimization.");
                    window.multiBufError = true;
                } else {
                    testBuffer.remove();
                    console.log("Offscreen buffer support detected.");
                }
            } catch (e) {
                console.log("Error testing WebGL support:", e);
                console.log("Falling back to shader complexity optimization.");
                window.multiBufError = true;
            }
            
            if (!inscription_id) {
                return;
            }
            
            cuP = R.I(0, 5);
            
            // Set current pattern immediately for better state tracking
            setShaderUniform('u_currentPattern', cuP, 'currentPattern');
            
            upCS();
            
            // Setup event handlers with optimized implementation - CALL ONLY ONCE
            suEH();
            
            nOX = R.I(0,2000)
            nOY = R.I(0,2000)

            let shiftX = -width/2;
            let shiftY = -height/2;
            iTX = shiftX;
            iTY = shiftY;
            tX = shiftX;
            tY = shiftY;

            nS = R.I(0,1000)
            rSS = R.I(0,1000)
            roA = R.I(0, 360)
            
            let teR = R.I(0, amV.length - 1);
            let raA = amV[teR];
            
            let inF = [0.0005, 0.0001, 0.005];
            let seF = inF[R.I(0,2)];
            
            cS = windowHeight / cV;
            
            let noSO = [0.005, 0.003, 0.001];
            bN = noSO[R.I(0, 2)];  

            let baM = R.N(0.5, 2.0);  
            
            function caCD(color1, color2) {
                const dr = color1[0] - color2[0];
                const dg = color1[1] - color2[1];
                const db = color1[2] - color2[2];
                return Math.sqrt(dr * dr + dg * dg + db * db);
            }

            function geRC(brightnessType = 'light', baseHue = null, existingColors = []) {
                const miCD = 0.3;
                let at = 0;
                const maA = 10;

                while (at < maA) {
                    let h;
                    if (brightnessType === 'mid' && baseHue !== null) {
                        h = (baseHue + 0.5) % 1.0;
} else {
                        h = R.D();  
                    }

                    let s = R.N(0.8, 1.0);  
                    let v;
                    
                    switch(brightnessType) {
                        case 'dark':
                            v = R.N(0.15, 0.3);  
                            break;
                        case 'mid':
                            v = R.N(0.5, 0.65);  
                            break;
                        case 'light':
                            v = R.N(0.85, 1.0);  
                            break;
                    }
                    
                    let i = Math.floor(h * 6);
                    let f = h * 6 - i;
                    let p = v * (1 - s);
                    let q = v * (1 - f * s);
                    let t = v * (1 - (1 - f) * s);

                    let r, g, b;
                    switch (i % 6) {
                        case 0: r = v, g = t, b = p; break;
                        case 1: r = q, g = v, b = p; break;
                        case 2: r = p, g = v, b = t; break;
                        case 3: r = p, g = q, b = v; break;
                        case 4: r = t, g = p, b = v; break;
                        case 5: r = v, g = p, b = q; break;
                    }

                    const newColor = [r, g, b];
                   
                    let diC = true;
                    for (const existingColor of existingColors) {
                        if (caCD(newColor, existingColor) < miCD) {
                            diC = false;
                            break;
                        }
                    }

                    if (diC || at === maA - 1) {
                        return { color: newColor, hue: h };
                    }

                    at++;
                }
            }
            
            let liR = geRC('light', null, []);
            let rC1 = liR.color;  
            
            let miR = geRC('mid', liR.hue, [rC1]);
            let rC2 = miR.color;  
            
            let rC3 = geRC('dark', null, [rC1, rC2]).color;  
            
            let baC = [
                [0.05, 0.05, 0.05, 1.0],  
                [0.90, 0.87, 0.82, 1.0]    
            ];
            
            let sBaC = baC[R.D() < 0.6 ? 0 : 1];
            let liBc = sBaC[0] > 0.5;

            // Efficiently set all uniform values using our cached function
            // Set static uniforms that rarely/never change
            setShaderUniform('u_nS', nS);
            setShaderUniform('u_rSS', rSS);
            setShaderUniform('u_roA', radians(roA));
            setShaderUniform('u_nOS', [nOX, nOY]);
            setShaderUniform('u_amplitude', raA);
            setShaderUniform('u_maxDepth', 6);
            setShaderUniform('u_initialFreq', seF);
            setShaderUniform('u_baseModulation', baM);
            setShaderUniform('u_baseColor', sBaC);
            setShaderUniform('u_isLightBackground', liBc);
            
            // Set color values
            setShaderUniform('u_randomColor1', rC1);
            setShaderUniform('u_randomColor2', rC2);
            setShaderUniform('u_randomColor3', rC3);
            
            // Set dynamic uniforms
            setShaderUniform('u_luminosity', lum);
            setShaderUniform('u_vibrancy', vib);
            setShaderUniform('u_sortStrength', soS);
            setShaderUniform('u_sortFrequency', soF);
            setShaderUniform('u_sortAnimSpeed', soA);

            scF = 30;
            upTC();

            stT = millis();  
            
            let cASV = R.N(1.5, 3.0);  
            setShaderUniform('u_caScaleVariation', cASV);
            
            // Add shader complexity control to keyboard instructions
            if (window.multiBufError) {
                console.log("Performance optimization: using shader complexity control");
                console.log("Press 'Q' to toggle adaptive complexity, '8' to decrease complexity, '9' to increase complexity");
                console.log("Press 'O' to toggle detail features, 'P' to toggle domain warping");
            } else {
                console.log("Performance optimization: using resolution scaling");
                console.log("Press 'Q' to toggle adaptive scaling, '8' to decrease scale, '9' to increase scale");
            }
            
            // Start the animation loop
            requestAnimationFrame(draw);
        }

        // Add these variables near the top of the script
        let rafID = null;
        let lastRenderTime = 0;
        const MIN_RENDER_INTERVAL = 16.667; // ~60fps

        function draw() {
            // Skip rendering when tab is not visible
            if (!isTabVisible) {
                return;
            }
            
            // Cancel any pending animation frame to avoid duplicates
            if (rafID !== null) {
                cancelAnimationFrame(rafID);
                rafID = null;
            }
            
            // Request next frame early for better performance
            if (isP || isDragging) {
                rafID = requestAnimationFrame(draw);
            }
            
            // Frame rate control for consistent animation
            const now = performance.now();
            const elapsed = now - lastFrameTime;
            
            // Apply time-based throttling for smoother rendering
            if (now - lastRenderTime < MIN_RENDER_INTERVAL) {
                return;
            }
            
            lastRenderTime = now;
            
            // FPS Calculation
            if (now - fpsUpdateTime > FPS_UPDATE_INTERVAL) {
                currentFPS = 1000 / (elapsed || 1);
                fpsUpdateTime = now;
                
                // Remove periodic status messages - only log when values change
                
                // Update adaptive resolution based on performance
                updateAdaptiveResolution(currentFPS);
            }
            
            // Performance monitoring and adaptation
            if (now - lastPerformanceCheck > PERFORMANCE_CHECK_INTERVAL) {
                lastPerformanceCheck = now;
                
                // Only adjust if enough time has passed since last change
                if (now - lastPixelDensityChange > MIN_DENSITY_CHANGE_INTERVAL) {
                    let targetDensity;
                    
                    // Set quality based on performance
                    if (currentFPS <= MIN_FPS_THRESHOLD) {
                        targetDensity = 1.0;
                    } else if (currentFPS <= MID_FPS_THRESHOLD) {
                        targetDensity = 1.5;
                    } else {
                        targetDensity = 2.0;
                    }
                    
                    // Only change if target is different from current
                    if (targetDensity !== currentPixelDensity) {
                        currentPixelDensity = targetDensity;
                        pixelDensity(currentPixelDensity);
                        lastPixelDensityChange = now;
                        console.log('Adjusting pixel density to:', currentPixelDensity, 'FPS:', currentFPS.toFixed(1));
                    }
                }
            }
            
            // Periodic memory cleanup
            if (now - lastMemoryCleanup >= MEMORY_CLEANUP_INTERVAL) {
                performMemoryCleanup();
            }
            
            // Update last frame time
            lastFrameTime = now;
            
            // Synchronized time handling
            if (isP) {
                cuT = ((millis() - stT) / 1000.0);
            }

            let scT = cuT;
            
            // If the buffer setup fails or resolution is near full, render directly
            if (renderScale >= 0.99 || !setupOffscreenBuffer()) {
                // If at nearly full resolution or buffer failed, render directly to canvas
                clear();
                background(0);
                
                // Use main shader
                shader(tS);
                
                // Update uniforms on main shader
                setShaderUniform('u_bS', bS);
                setShaderUniform('u_scaleFactor', scF);
                setShaderUniform('u_translation', [tX, tY]);
                setShaderUniform('u_resolution', [width, height]);
                setShaderUniform('u_time', scT);
                
                // Calculate cellSize only once
                const cellSize = (height / cV) * bS;
                setShaderUniform('u_cellSize', cellSize);
                
                setShaderUniform('u_flowSpeed', fS);
                setShaderUniform('u_luminosity', lum);
                setShaderUniform('u_vibrancy', vib);
                setShaderUniform('u_sortStrength', soS);
                setShaderUniform('u_sortFrequency', soF);
                setShaderUniform('u_sortAnimSpeed', soA);
                setShaderUniform('u_currentPattern', cuP);
                
                // Calculate noise scale
                let cSP = height / cV;
                let dySN = bN * (100.0 / floor(cSP)); 
                setShaderUniform('u_noiseScale', dySN);
                
                // Draw directly to main canvas
                beginShape();
                vertex(-1, -1, 0, 0, 0);
                vertex(1, -1, 0, 1, 0);
                vertex(1, 1, 0, 1, 1);
                vertex(-1, 1, 0, 0, 1);
                endShape(CLOSE);
                
                // Removed all text rendering code
            } else {
                // Get the buffer from setupOffscreenBuffer
                const buffer = offscreenBuffer;
                
                // Make sure buffer exists and has shader before proceeding
                if (!buffer || !bufferShader) {
                    console.error("Buffer or shader is null, falling back to direct rendering");
                    // Force full resolution for next frame
                    renderScale = 1.0;
                    
                    // Render directly using main shader as fallback
                    shader(tS);
                    clear();
                    background(0);
                    
                    // Draw a basic quad
                    beginShape();
                    vertex(-1, -1, 0, 0, 0);
                    vertex(1, -1, 0, 1, 0);
                    vertex(1, 1, 0, 1, 1);
                    vertex(-1, 1, 0, 0, 1);
                    endShape(CLOSE);
                    return;
                }
                
                // Clear the main canvas
                clear();
                background(0);
                
                // Clear the buffer
                buffer.clear();
                buffer.background(0);
                
                // Make sure shader is set on buffer
                buffer.shader(bufferShader);
                
                // Calculate scaling adjustments
                const scaledScF = scF * (1.0 / renderScale);
                
                // Use direct method calls instead of setUniform for more robust operation
                try {
                    // Basic rendering uniforms
                    bufferShader.setUniform('u_bS', bS);
                    bufferShader.setUniform('u_scaleFactor', scaledScF);
                    bufferShader.setUniform('u_translation', [tX, tY]);
                    bufferShader.setUniform('u_resolution', [buffer.width, buffer.height]);
                    bufferShader.setUniform('u_time', scT);
                    
                    // Cell and rendering properties
                    const cellSize = (buffer.height / cV) * bS;
                    bufferShader.setUniform('u_cellSize', cellSize);
                    bufferShader.setUniform('u_flowSpeed', fS);
                    
                    // Visual adjustments
                    bufferShader.setUniform('u_luminosity', lum);
                    bufferShader.setUniform('u_vibrancy', vib);
                    bufferShader.setUniform('u_sortStrength', soS);
                    bufferShader.setUniform('u_sortFrequency', soF);
                    bufferShader.setUniform('u_sortAnimSpeed', soA);
                    bufferShader.setUniform('u_currentPattern', cuP);
                    
                    // Noise parameters
                    let cSP = buffer.height / cV;
                    let dySN = bN * (100.0 / floor(cSP)); 
                    bufferShader.setUniform('u_noiseScale', dySN);
                    
                    // Static parameters from setup
                    bufferShader.setUniform('u_nS', nS);
                    bufferShader.setUniform('u_rSS', rSS);
                    bufferShader.setUniform('u_roA', radians(roA));
                    bufferShader.setUniform('u_nOS', [nOX, nOY]);
                    bufferShader.setUniform('u_amplitude', raA);
                    bufferShader.setUniform('u_maxDepth', 6);
                    bufferShader.setUniform('u_initialFreq', seF);
                    bufferShader.setUniform('u_baseModulation', baM);
                    bufferShader.setUniform('u_baseColor', sBaC);
                    bufferShader.setUniform('u_isLightBackground', liBc);
                    bufferShader.setUniform('u_randomColor1', rC1);
                    bufferShader.setUniform('u_randomColor2', rC2);
                    bufferShader.setUniform('u_randomColor3', rC3);
                    bufferShader.setUniform('u_caScaleVariation', 0.5);
                    
                    // Optional toggle uniforms (with safe defaults)
                    bufferShader.setUniform('u_enableDomainWarp', true);
                    bufferShader.setUniform('u_enableLayeredNoise', true);
                    bufferShader.setUniform('u_enableFlowFields', true);
                    bufferShader.setUniform('u_enableGlyphNoise', true);
                    bufferShader.setUniform('u_enableGridDistort', true);
                    bufferShader.setUniform('u_enableGlyphNoiseDetail', true);
                    
                    // Render to the offscreen buffer
                    buffer.beginShape();
                    buffer.vertex(-1, -1, 0, 0, 0);
                    buffer.vertex(1, -1, 0, 1, 0);
                    buffer.vertex(1, 1, 0, 1, 1);
                    buffer.vertex(-1, 1, 0, 0, 1);
                    buffer.endShape(CLOSE);
                    
                    // Now draw the buffer to the main canvas, scaling it up
                    texture(buffer);
                    beginShape();
                    vertex(-1, -1, 0, 0, 0);
                    vertex(1, -1, 0, 1, 0);
                    vertex(1, 1, 0, 1, 1);
                    vertex(-1, 1, 0, 0, 1);
                    endShape(CLOSE);
                    
                    // Removed all text rendering code
                } catch (err) {
                    console.error("Error setting shader uniforms:", err);
                    // Fall back to direct rendering on error
                    renderScale = 1.0;
                    
                    clear();
                    background(0);
                    shader(tS);
                    beginShape();
                    vertex(-1, -1, 0, 0, 0);
                    vertex(1, -1, 0, 1, 0);
                    vertex(1, 1, 0, 1, 1);
                    vertex(-1, 1, 0, 0, 1);
                    endShape(CLOSE);
                }
            }
            
            if (isR && (millis() - reST > reDu)) {
                noRe();
            }
        }

        

        function upCS() {
            const wiR = windowWidth / windowHeight;
            let neW, neH;
            
            // Save current position before resize
            const currentTX = tX;
            const currentTY = tY;
            const currentScaleFactor = scF;
            
            switch(dM) {
                case 0: // 3:4 aspect ratio
                    if (wiR > 0.75) {
                        // Width is relatively larger, constrain by height
                    neH = windowHeight;
                        neW = windowHeight * 0.75; // 3:4 ratio (width:height)
                    } else {
                        // Height is relatively larger, constrain by width
                        neW = windowWidth;
                        neH = windowWidth * (4/3); // 4:3 ratio (height:width)
                    }
                    break;
                
                case 1: // 1:1 square aspect ratio
                    if (wiR > 1) {
                        neH = windowHeight;
                        neW = windowHeight;
                    } else {
                        neW = windowWidth;
                        neH = windowWidth;
                    }
                    break;
                
                case 2: // 4:3 aspect ratio
                    if (wiR > (4/3)) {
                        // Width is relatively larger, constrain by height
                        neH = windowHeight;
                        neW = windowHeight * (4/3); // 4:3 ratio (width:height)
                    } else {
                        // Height is relatively larger, constrain by width
                        neW = windowWidth;
                        neH = windowWidth * 0.75; // 3:4 ratio (height:width)
                    }
                    break;
                
                case 3: // Fullscreen (use entire window)
                    neW = windowWidth;
                    neH = windowHeight;
                    break;
            }
           
            if (width !== neW || height !== neH) {
                // Calculate relative position for scaling
                const relXPercent = (currentTX + width/2) / width;
                const relYPercent = (currentTY + height/2) / height;
                
                resizeCanvas(neW, neH);
                
                // Maintain relative position after resize
                tX = (relXPercent * neW) - neW/2;
                tY = (relYPercent * neH) - neH/2;
                
                // Use cached canvas reference instead of querying the DOM again
                if (canvasElement) {
                    canvasElement.style.cssText = 'position:absolute;left:50%;top:50%;transform:translate(-50%,-50%)';
                }
                
                // Force a redraw to update the canvas
                requestAnimationFrame(draw);
            }
        }

        
        let reTO;
        function windowResized() {
            upCS();
            
            // Ensure offscreen buffer is recreated with the new canvas dimensions
            setupOffscreenBuffer();
        }

        
        let meR;
        let reCN = [];
        let isR = false;
        let reST;
        const reDu = 30000; 

        // Add these new functions
        function stRe() {
            // Clear previous chunks but keep the array to reduce allocations
            reCN.length = 0;
            recordingChunkIndex = 0;
            
            // Use cached canvas element reference
            const stream = canvasElement.captureStream(60); 
            meR = new MediaRecorder(stream, {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 50000000 
            });

            meR.ondataavailable = (e) => {
                if (e.data && e.data.size > 0) {
                    // Store only non-empty chunks
                    reCN.push(e.data);
                }
            };

            meR.onstop = saRe;

            // Schedule regular data chunks to avoid memory spikes
            meR.start(1000); // Request data in 1-second chunks
            isR = true;
            reST = millis();
        }

        function noRe() {
            if (meR && meR.state !== 'inactive') {
            meR.stop();
            isR = false;
            }
        }

        function saRe() {
            if (reCN.length === 0) {
                console.log('No recording data available.');
                return;
            }
            
            // Create blob using a single operation
            const blob = new Blob(reCN, {type: 'video/webm'});
            
            // Generate timestamp for filename
            const timestamp = geT();
            
            // Create download link
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `recording_${timestamp}.webm`;
            a.style.display = 'none';
            
            // Add to DOM, click, and remove to trigger download
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
                // Clear chunks array
                reCN.length = 0;
            }, 100);
        }

        // Function to set uniform values to shader with caching
        function setShaderUniform(name, value, cachedName = null) {
            // Use provided cachedName or derive from uniform name
            const cacheKey = cachedName || name.replace('u_', '');
            
            // Handle array values
            if (Array.isArray(value)) {
                // Check each element in array
                if (
                    !cachedUniforms[cacheKey] || 
                    value.some((v, i) => v !== cachedUniforms[cacheKey][i])
                ) {
                    // Update cache with defensive copy
                    cachedUniforms[cacheKey] = [...value];
                    
                    // Set the actual WebGL uniform
                    tS.setUniform(name, value);
                }
            } else {
                // For primitive values, simple comparison
                if (cachedUniforms[cacheKey] !== value) {
                    // Update cache
                    cachedUniforms[cacheKey] = value;
                    
                    // Set the actual WebGL uniform
                    tS.setUniform(name, value);
                }
            }
        }

        function optimizeGLRendering() {
            // Ensure WebGL context is valid
            if (!glContext) return;
            
            // Optimize WebGL state for this specific renderer
            
            // Disable features we don't need (already done in setup, but ensure they stay disabled)
            glContext.disable(glContext.DEPTH_TEST);
            glContext.disable(glContext.CULL_FACE);
            glContext.disable(glContext.DITHER);
            glContext.disable(glContext.STENCIL_TEST);
            
            // Enable optimization features
            glContext.enable(glContext.SCISSOR_TEST); // Enable scissor test for clipping
            
            // Set optimal blend mode for our rendering
            glContext.enable(glContext.BLEND);
            glContext.blendFunc(glContext.SRC_ALPHA, glContext.ONE_MINUS_SRC_ALPHA);
            
            // Set hints for WebGL renderer
            glContext.hint(glContext.GENERATE_MIPMAP_HINT, glContext.FASTEST);
            
            // Optimize viewport to match canvas size exactly
            glContext.viewport(0, 0, glContext.drawingBufferWidth, glContext.drawingBufferHeight);
            
            // Create a static vertex buffer for our quad rendering
            createStaticVertexBuffer();
        }
        
        // Create static vertex buffer for efficient rendering
        function createStaticVertexBuffer() {
            if (!glContext) return;
            
            // We'll set up a better vertex buffer in a real implementation
            // For p5.js integration, we'll rely on p5's own buffer management
            // But we can optimize how we use it
        }

        // Performance optimization variables
        let renderScale = 1.0;                  // Scale factor for internal rendering (0.5 = half resolution)
        let minRenderScale = 0.25;              // Minimum render scale (maximum performance)
        let maxRenderScale = 1.0;               // Maximum render scale (maximum quality)
        let adaptiveScaling = true;             // Automatically adjust render scale based on performance
        let targetFPS = 30;                     // Target FPS for adaptive scaling
        let lowFPSThreshold = 20;               // FPS threshold to decrease resolution
        let highFPSThreshold = 40;              // FPS threshold to increase resolution
        let scaleAdjustRate = 0.05;             // How quickly to adjust render scale
        let scaleChangeInterval = 2000;         // Minimum time between scale changes (ms)
        let lastScaleChange = 0;                // Timestamp of last scale change
        let offscreenBuffer = null;             // Offscreen buffer for rendering at reduced resolution
        let bufferShader = null;                // Shader instance for offscreen buffer

        // Create or resize the offscreen buffer based on current canvas size and render scale
        function setupOffscreenBuffer() {
            // Skip if already at full resolution
            if (renderScale >= 0.99) {
                return false;
            }
            
            // Check if WebGL contexts are supported via feature detection
            const hasWebGLMultiContext = 
                typeof WebGLRenderingContext !== 'undefined' && 
                typeof WebGL2RenderingContext !== 'undefined' && 
                !window.multiBufError;
            
            if (!hasWebGLMultiContext) {
                // If previous attempts failed, avoid retrying
                console.log("Multiple WebGL contexts not supported on this device");
                renderScale = 1.0;
                return false;
            }
            
            try {
                const scaledWidth = Math.max(10, Math.floor(width * renderScale));
                const scaledHeight = Math.max(10, Math.floor(height * renderScale));
                
                // Check if we should create/resize buffer
                const needsNewBuffer = !offscreenBuffer || 
                                    offscreenBuffer.width !== scaledWidth || 
                                    offscreenBuffer.height !== scaledHeight ||
                                    !bufferShader;
                
                if (needsNewBuffer) {
                    console.log(`Setting up offscreen buffer: ${scaledWidth}x${scaledHeight}, scale: ${renderScale.toFixed(2)}`);
                    
                    // Clean up existing buffer if there is one
                    if (offscreenBuffer) {
                        try {
                            offscreenBuffer.remove();
                        } catch (e) {
                            console.warn("Error removing old buffer:", e);
                        }
                        offscreenBuffer = null;
                        bufferShader = null;
                    }
                    
                    // Create a new p5 graphics buffer at the scaled size
                    try {
                        offscreenBuffer = createGraphics(scaledWidth, scaledHeight, WEBGL);
                        
                        if (!offscreenBuffer || !offscreenBuffer.GL) {
                            console.error("Failed to create offscreen buffer with WebGL context");
                            offscreenBuffer = null;
                            window.multiBufError = true; // Mark that multi-context failed for future calls
                            return false;
                        }
                        
                        // Apply same WebGL settings to offscreen buffer
                        const gl = offscreenBuffer.GL;
                        gl.disable(gl.DEPTH_TEST);
                        gl.disable(gl.CULL_FACE);
                        gl.disable(gl.DITHER);
                        gl.disable(gl.STENCIL_TEST);
                        gl.enable(gl.BLEND);
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                        gl.hint(gl.GENERATE_MIPMAP_HINT, gl.FASTEST);
                        
                        // Create a new shader instance for the offscreen buffer context
                        const vertSrc = document.getElementById('vertex-shader').textContent;
                        const fragSrc = document.getElementById('fragment-shader').textContent;
                        
                        bufferShader = offscreenBuffer.createShader(vertSrc, fragSrc);
                        
                        if (!bufferShader) {
                            console.error("Created buffer shader is null");
                            offscreenBuffer = null;
                            window.multiBufError = true;
                            return false;
                        }
                        
                        // Test the shader by setting it once
                        offscreenBuffer.shader(bufferShader);
                        offscreenBuffer.noStroke();
                        
                        console.log("Successfully created offscreen buffer shader");
                    } catch (createError) {
                        console.error("Error creating buffer or shader:", createError);
                        offscreenBuffer = null;
                        bufferShader = null;
                        window.multiBufError = true;
                        return false;
                    }
                }
                
                return offscreenBuffer !== null && bufferShader !== null;
            } catch (error) {
                console.error("Unexpected error in setupOffscreenBuffer:", error);
                offscreenBuffer = null;
                bufferShader = null;
                window.multiBufError = true;
                return false;
            }
        }

        // Add these variables for shader complexity adjustments
        let shaderComplexity = 1.0;   // Scale from 0.25 (lowest) to 1.0 (highest) for shader complexity
        let maxLoopIterations = 6;    // Default maximum loop iterations in the shader
        let noiseOctaves = 6;         // Number of noise octaves to use
        let enableDetails = true;     // Enable/disable detail features

        // Modify updateAdaptiveResolution to use shader complexity if offscreen buffers aren't supported
        function updateAdaptiveResolution(currentFPS) {
            // Only adjust resolution periodically
            const now = performance.now();
            if (now - lastScaleChange < scaleChangeInterval) {
                return;
            }
            
            // Skip if adaptive scaling is disabled
            if (!adaptiveScaling) {
                return;
            }
            
            // Check if multi-context is available
            const canUseMultiContext = !window.multiBufError;
            
            if (canUseMultiContext) {
                // Standard resolution scaling approach
                let newScale = renderScale;
                
                // If FPS is too low, reduce resolution to improve performance
                if (currentFPS < lowFPSThreshold) {
                    newScale = Math.max(minRenderScale, renderScale - scaleAdjustRate);
                } 
                // If FPS is high enough, increase resolution for better quality
                else if (currentFPS > highFPSThreshold && renderScale < maxRenderScale) {
                    newScale = Math.min(maxRenderScale, renderScale + scaleAdjustRate);
                }
                
                // Only update if scale actually changed
                if (newScale !== renderScale) {
                    console.log(`Adjusting render scale: ${renderScale.toFixed(2)} -> ${newScale.toFixed(2)} (FPS: ${currentFPS.toFixed(1)})`);
                    renderScale = newScale;
                    lastScaleChange = now;
                    
                    // If previous buffer creation failed, try a much lower scale
                    if (offscreenBuffer === null && newScale < 0.8) {
                        renderScale = 0.5;
                        console.log("Previous buffer creation failed, jumping to 50% scale");
                    }
                    
                    // Try setting up the buffer with new scale
                    const bufferSuccess = setupOffscreenBuffer();
                    
                    // If buffer setup failed, revert to shader complexity approach
                    if (!bufferSuccess && renderScale < 1.0) {
                        console.log("Failed to create offscreen buffer, switching to shader complexity optimization");
                        renderScale = 1.0;
                        window.multiBufError = true;
                        adjustShaderComplexity(currentFPS);
                    }
                }
            } else {
                // Use shader complexity optimization instead
                adjustShaderComplexity(currentFPS);
            }
        }

        // New function to adjust shader complexity based on FPS
        function adjustShaderComplexity(currentFPS) {
            let newComplexity = shaderComplexity;
            
            // If FPS is too low, reduce shader complexity
            if (currentFPS < lowFPSThreshold) {
                newComplexity = Math.max(0.25, shaderComplexity - 0.1);
            } 
            // If FPS is high, increase shader complexity
            else if (currentFPS > highFPSThreshold && shaderComplexity < 1.0) {
                newComplexity = Math.min(1.0, shaderComplexity + 0.05);
            }
            
            // Only update if complexity changed
            if (newComplexity !== shaderComplexity) {
                shaderComplexity = newComplexity;
                const complexityPercent = Math.round(shaderComplexity * 100);
                console.log(`Adjusting shader complexity: ${complexityPercent}% | FPS: ${currentFPS.toFixed(1)} | Iterations: ${Math.max(2, Math.floor(6 * shaderComplexity))}`);
                
                // Apply complexity to shader parameters
                maxLoopIterations = Math.max(2, Math.floor(6 * shaderComplexity));
                noiseOctaves = Math.max(2, Math.floor(6 * shaderComplexity));
                enableDetails = shaderComplexity > 0.5;
                
                // Update shader uniforms immediately
                if (tS) {
                    setShaderUniform('u_maxDepth', maxLoopIterations);
                    setShaderUniform('u_enableGlyphNoiseDetail', enableDetails);
                    
                    // Add toggles for additional features based on complexity
                    setShaderUniform('u_enableDomainWarp', shaderComplexity > 0.3);
                    setShaderUniform('u_enableLayeredNoise', shaderComplexity > 0.4);
                    setShaderUniform('u_enableFlowFields', shaderComplexity > 0.6);
                    setShaderUniform('u_enableGlyphNoise', shaderComplexity > 0.2);
                    setShaderUniform('u_enableGridDistort', shaderComplexity > 0.5);
                }
                
                lastScaleChange = performance.now();
            }
        }
    </script>
  </body>
</html>
